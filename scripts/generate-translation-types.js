#!/usr/bin/env node
/**
 * Translation Type Generation Script
 *
 * Generates TypeScript types from translation JSON files for compile-time
 * validation of translation keys. This ensures invalid keys are caught
 * by TypeScript rather than appearing as raw strings at runtime.
 *
 * Usage:
 *   node scripts/generate-translation-types.js
 *   npm run generate:i18n-types
 */

import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

// Configuration
const WEB_LOCALES_DIR = path.join(__dirname, '../packages/web/src/i18n/locales/en');
const SHARED_LOCALES_DIR = path.join(__dirname, '../packages/shared/src/i18n/locales/en');
const OUTPUT_FILE = path.join(__dirname, '../packages/shared/src/i18n/translation-keys.generated.ts');

/**
 * Recursively flatten nested object to dot-notation keys
 * @param {object} obj - The object to flatten
 * @param {string} prefix - Current key prefix
 * @returns {string[]} Array of dot-notation keys
 */
function flattenKeys(obj, prefix = '') {
  const keys = [];
  for (const [key, value] of Object.entries(obj)) {
    const fullKey = prefix ? `${prefix}.${key}` : key;
    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
      keys.push(...flattenKeys(value, fullKey));
    } else {
      keys.push(fullKey);
    }
  }
  return keys;
}

/**
 * Convert namespace name to PascalCase type name
 * @param {string} str - Namespace name
 * @returns {string} PascalCase type name
 */
function toPascalCase(str) {
  return str
    .split(/[-_]/)
    .map(part => part.charAt(0).toUpperCase() + part.slice(1))
    .join('');
}

/**
 * Generate TypeScript union type from keys
 * @param {string} namespace - Namespace name
 * @param {string[]} keys - Array of translation keys
 * @returns {string} TypeScript type definition
 */
function generateNamespaceType(namespace, keys) {
  const typeName = `${toPascalCase(namespace)}Keys`;
  if (keys.length === 0) {
    return `export type ${typeName} = never;`;
  }
  const sortedKeys = [...keys].sort();
  const quotedKeys = sortedKeys.map(k => `  | '${k}'`).join('\n');
  return `export type ${typeName} =\n${quotedKeys};`;
}

/**
 * Load all translation files from a directory
 * @param {string} dir - Directory path
 * @returns {Map<string, string[]>} Map of namespace to keys
 */
function loadTranslations(dir) {
  const namespaces = new Map();

  if (!fs.existsSync(dir)) {
    console.warn(`Warning: Directory does not exist: ${dir}`);
    return namespaces;
  }

  const files = fs.readdirSync(dir);
  for (const file of files) {
    if (!file.endsWith('.json')) continue;
    const namespace = path.basename(file, '.json');
    const filePath = path.join(dir, file);

    try {
      const content = JSON.parse(fs.readFileSync(filePath, 'utf8'));
      const keys = flattenKeys(content);
      namespaces.set(namespace, keys);
    } catch (error) {
      console.error(`Error loading ${filePath}:`, error.message);
    }
  }

  return namespaces;
}

/**
 * Main generation logic
 */
function generate() {
  console.log('Generating translation types...');

  // Load web namespaces
  const webNamespaces = loadTranslations(WEB_LOCALES_DIR);
  console.log(`  Loaded ${webNamespaces.size} web namespaces`);

  // Load shared namespace
  const sharedNamespaces = loadTranslations(SHARED_LOCALES_DIR);
  console.log(`  Loaded ${sharedNamespaces.size} shared namespaces`);

  // Merge all namespaces (shared common is accessed as 'shared' namespace)
  const allNamespaces = new Map();

  // Add web namespaces
  for (const [ns, keys] of webNamespaces) {
    allNamespaces.set(ns, keys);
  }

  // Add shared namespace (renamed to 'shared')
  if (sharedNamespaces.has('common')) {
    allNamespaces.set('shared', sharedNamespaces.get('common'));
  }

  // Generate output
  const lines = [
    '// Auto-generated by scripts/generate-translation-types.js',
    '// DO NOT EDIT - Run "npm run generate:i18n-types" to regenerate',
    '',
  ];

  // Generate individual namespace types
  const namespaceNames = [...allNamespaces.keys()].sort();
  for (const ns of namespaceNames) {
    const keys = allNamespaces.get(ns);
    lines.push(generateNamespaceType(ns, keys));
    lines.push('');
  }

  // Generate combined TranslationKey type with namespace prefixes
  lines.push('/**');
  lines.push(' * Union type of all valid translation keys.');
  lines.push(' * Keys can be used with or without namespace prefix.');
  lines.push(' * When used without prefix, the key must exist in at least one namespace.');
  lines.push(' * Examples:');
  lines.push(" *   - 'common:status.pending' (explicit namespace)");
  lines.push(" *   - 'auth:login.email' (explicit namespace)");
  lines.push(" *   - 'status.pending' (works if common namespace is used)");
  lines.push(' */');
  lines.push('export type TranslationKey =');

  // First add prefixed versions (most type-safe)
  for (const ns of namespaceNames) {
    const typeName = `${toPascalCase(ns)}Keys`;
    lines.push(`  | \`${ns}:\${${typeName}}\``);
  }

  // Then allow all namespace keys without prefix
  // This is less strict but matches how react-i18next actually works
  // when a component receives t from a parent that already specified the namespace
  lines.push('  // Allow keys without namespace prefix (for when namespace is contextually known)');
  for (const ns of namespaceNames) {
    const typeName = `${toPascalCase(ns)}Keys`;
    lines.push(`  | ${typeName}`);
  }
  // Remove the last pipe and add semicolon
  const lastIndex = lines.length - 1;
  lines[lastIndex] = lines[lastIndex] + ';';

  lines.push('');

  // Generate namespace list for runtime validation
  lines.push('/**');
  lines.push(' * List of all translation namespaces');
  lines.push(' */');
  lines.push(`export const TRANSLATION_NAMESPACES = [${namespaceNames.map(n => `'${n}'`).join(', ')}] as const;`);
  lines.push('');
  lines.push('export type TranslationNamespace = typeof TRANSLATION_NAMESPACES[number];');
  lines.push('');

  // Write output file
  const output = lines.join('\n');
  fs.writeFileSync(OUTPUT_FILE, output);

  // Calculate stats
  let totalKeys = 0;
  for (const keys of allNamespaces.values()) {
    totalKeys += keys.length;
  }

  console.log(`\nGenerated ${OUTPUT_FILE}`);
  console.log(`  Namespaces: ${allNamespaces.size}`);
  console.log(`  Total keys: ${totalKeys}`);
}

// Run
generate();
