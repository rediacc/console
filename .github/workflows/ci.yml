name: Console CI

on:
  pull_request:
    types: [opened, synchronize, reopened, edited]
  merge_group:
    types: [checks_requested]
  schedule:
    - cron: '0 3 * * *'  # Nightly at 3:00 UTC
  workflow_dispatch:
    inputs:
      browsers:
        description: 'E2E browsers to test'
        required: false
        type: choice
        default: 'chromium-only'
        options:
          - 'chromium-only'
          - 'all-browsers'

# Required for cancel-watchdog to cancel workflow on job failures,
# GitHub Pages deployment, autofix commits, and Docker publishing
permissions:
  actions: write
  contents: write
  pages: write
  id-token: write
  packages: write  # For GHCR push

# Cancel in-progress runs when a new run is triggered for the same branch/PR
# Use 'no-cancel-push' PR label to disable (see .github/labels.yml)
# Note: Cross-PR queueing is handled by the 'queue' job below
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: ${{ !contains(github.event.pull_request.labels.*.name, 'no-cancel-push') }}

# E2E Browser Configuration
# Default: chromium only. Use workflow_dispatch with "all-browsers" to test all.
# To permanently enable all browsers, change the fallback value below.
env:
  E2E_BROWSERS: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.browsers == 'all-browsers' && 'chromium firefox webkit msedge' || 'chromium' }}

jobs:
  # ============================================================================
  # COLUMN 1: INITIALIZE
  # Jobs: initialize, cancel-watchdog
  # No dependencies - starts immediately for fast feedback on Quality checks
  # ============================================================================
  initialize:
    name: Initialize
    runs-on: ubuntu-latest  # Needs Docker for registry cache check
    if: github.event_name != 'push' || (github.actor != 'github-actions[bot]' && github.actor != 'dependabot[bot]' && !contains(github.event.head_commit.message, '[skip ci]'))
    outputs:
      is_bot: ${{ steps.init.outputs.is_bot }}
      next_version: ${{ steps.init.outputs.next_version }}
      api_tag: ${{ steps.init.outputs.api_tag }}
      api_exists: ${{ steps.init.outputs.api_exists }}
      bridge_tag: ${{ steps.init.outputs.bridge_tag }}
      bridge_exists: ${{ steps.init.outputs.bridge_exists }}
      plugins_tag: ${{ steps.init.outputs.plugins_tag }}
      plugins_exists: ${{ steps.init.outputs.plugins_exists }}
      web_tag: ${{ steps.init.outputs.web_tag }}
      web_exists: ${{ steps.init.outputs.web_exists }}
      cli_tag: ${{ steps.init.outputs.cli_tag }}
      cli_exists: ${{ steps.init.outputs.cli_exists }}
      image_tag: ${{ steps.init.outputs.image_tag }}
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6

      # PR Validation (PR events only)
      - name: Validate PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd  # v8
        with:
          script: |
            const pr = context.payload.pull_request;
            const errors = [];
            const warnings = [];

            // Check PR title format (Conventional Commits)
            const titlePattern = /^(feat|fix|docs|style|refactor|perf|test|chore|ci|build|revert)(\(.+\))?: .+/;
            if (!titlePattern.test(pr.title)) {
              errors.push(
                'PR title must follow Conventional Commits format:\n' +
                'type(scope): description\n\n' +
                'Types: feat, fix, docs, style, refactor, perf, test, chore, ci, build, revert\n' +
                'Example: feat(ui): add dark mode toggle'
              );
            }

            // Check PR description length
            const body = pr.body || '';
            if (body.length < 20) {
              errors.push('PR description is too short. Please provide a detailed description.');
            }

            // Check for linked issues (warning only)
            const issuePattern = /(close|closes|closed|fix|fixes|fixed|resolve|resolves|resolved|ref|refs)\s+#\d+/i;
            if (!issuePattern.test(body)) {
              warnings.push('PR does not reference any issues. Consider linking related issues.');
            }

            // Check PR size
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
            });
            const additions = files.reduce((sum, file) => sum + file.additions, 0);
            const deletions = files.reduce((sum, file) => sum + file.deletions, 0);
            const totalChanges = additions + deletions;
            const fileCount = files.length;

            if (totalChanges > 1000) {
              warnings.push(`Large PR detected (${totalChanges} lines changed). Consider breaking it into smaller PRs.`);
            }
            if (fileCount > 30) {
              warnings.push(`Many files changed (${fileCount} files). Consider breaking it into smaller PRs.`);
            }

            // Note: Merge conflicts and rebase checks are handled by Quality / Branch job

            // Write summary
            let summary = `## PR Validation\n\n`;
            summary += `- **Files changed:** ${fileCount}\n`;
            summary += `- **Lines added:** ${additions}\n`;
            summary += `- **Lines deleted:** ${deletions}\n`;
            summary += `- **Total changes:** ${totalChanges}\n\n`;

            if (warnings.length > 0) {
              summary += `### Warnings\n`;
              warnings.forEach(w => {
                core.warning(w);
                summary += `- ⚠️ ${w}\n`;
              });
              summary += '\n';
            }

            if (errors.length > 0) {
              summary += `### Errors\n`;
              errors.forEach(e => summary += `- ❌ ${e}\n`);
              core.summary.addRaw(summary).write();
              core.setFailed(errors.join('\n\n'));
            } else {
              summary += `✅ All PR checks passed\n`;
              core.summary.addRaw(summary).write();
            }

      # Login to GHCR for registry cache check
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GH_PAT }}

      # Run consolidated initialization script
      - name: Initialize CI
        id: init
        env:
          GITHUB_PAT: ${{ secrets.GH_PAT }}
          GITHUB_EVENT_NAME: ${{ github.event_name }}
          GITHUB_ACTOR: ${{ github.actor }}
          COMMIT_AUTHOR: ${{ github.event.head_commit.author.name }}
        run: |
          .ci/scripts/ci/initialize.sh --output "$GITHUB_OUTPUT"

      # Upload CI tags as artifact for debugging
      - name: Upload CI Tags
        if: steps.init.outputs.is_bot != 'true'
        run: |
          cat > ci-tags.txt << EOF
          api_tag=${{ steps.init.outputs.api_tag }}
          bridge_tag=${{ steps.init.outputs.bridge_tag }}
          plugins_tag=${{ steps.init.outputs.plugins_tag }}
          web_tag=${{ steps.init.outputs.web_tag }}
          EOF
      - uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6
        if: steps.init.outputs.is_bot != 'true'
        with:
          name: ci-tags-${{ github.sha }}
          path: ci-tags.txt
          retention-days: 1

  cancel-watchdog:
    name: Cancel Watchdog
    needs: [initialize]
    runs-on: ubuntu-slim
    if: always() && needs.initialize.result == 'success'
    steps:
      - name: Monitor Quality + Build jobs for quick failures
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd  # v8
        with:
          script: |
            const pollInterval = 10000;  // 10 seconds
            const maxRuntime = 300000;   // 5 minutes (quick-fail window)
            const minRuntime = 30000;    // 30 seconds minimum before allowing exit
            const startTime = Date.now();

            // Job prefixes for quick-fail monitoring (Quality + Review Gate + Queue + Build only, NOT tests)
            const quickFailPrefixes = [
              'Quality',
              'Review Gate',
              'Queue',
              'Build (Docker)',
              'Build (Desktop)',
              'Build (CLI)',
              'Deploy Dry-Run'
            ];

            // Check for skip-cancellation label
            let skipCancellationOnFailure = false;
            if (context.payload.pull_request) {
              const labels = context.payload.pull_request.labels.map(l => l.name);
              skipCancellationOnFailure = labels.includes('no-cancel-failure');
              if (skipCancellationOnFailure) {
                console.log('Label "no-cancel-failure" detected - will not cancel on job failures');
              }
            }

            console.log('Cancel Watchdog started - monitoring Quality + Build jobs for quick failures...');
            console.log(`Quick-fail window: ${maxRuntime / 60000} minutes`);

            while (Date.now() - startTime < maxRuntime) {
              const elapsed = Date.now() - startTime;
              const elapsedSec = Math.round(elapsed / 1000);

              const { data: jobs } = await github.rest.actions.listJobsForWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: context.runId
              });

              // Filter to only quick-fail jobs (Quality + Build, not tests)
              const quickJobs = jobs.jobs.filter(j =>
                !j.name.includes('Watchdog') &&
                j.name !== 'Queue' &&
                j.name !== 'Initialize' &&
                j.name !== 'CI Complete' &&
                quickFailPrefixes.some(prefix => j.name.startsWith(prefix))
              );

              const completed = quickJobs.filter(j => j.status === 'completed');
              const inProgress = quickJobs.filter(j => j.status === 'in_progress');
              const queued = quickJobs.filter(j => j.status === 'queued');
              const failed = quickJobs.filter(j => j.conclusion === 'failure');

              console.log(`[${elapsedSec}s] Quick jobs: ${completed.length} done, ${inProgress.length} running, ${queued.length} queued`);

              // Check if workflow was externally cancelled (e.g., by concurrency or manual cancellation)
              const cancelledJobs = quickJobs.filter(job => job.conclusion === 'cancelled');
              if (cancelledJobs.length > 0 && cancelledJobs.length >= completed.length / 2) {
                console.log(`Workflow externally cancelled (${cancelledJobs.length}/${completed.length} jobs cancelled) - exiting watchdog`);
                return;
              }

              // Check for failures in quick-fail jobs
              if (failed.length > 0) {
                const failedJob = failed[0];
                const failureMsg = `Job failed: "${failedJob.name}"`;
                console.log('');
                console.log('='.repeat(70));
                console.log(failureMsg);
                console.log(`   Job URL: https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}/job/${failedJob.id}`);
                console.log('='.repeat(70));

                if (skipCancellationOnFailure) {
                  console.log('');
                  console.log('NOTICE: Skipping workflow cancellation due to "no-cancel-failure" label');
                  console.log('Workflow will continue running despite this failure.');
                  core.setFailed(failureMsg + ' (cancellation skipped due to label)');
                  return;
                }

                await github.rest.actions.cancelWorkflowRun({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  run_id: context.runId
                });

                core.setFailed('PIPELINE CANCELLED: ' + failureMsg);
                return;
              }

              // Exit if all quick jobs completed successfully
              if (inProgress.length === 0 && queued.length === 0 && elapsed >= minRuntime) {
                console.log(`All Quality + Build jobs completed - exiting watchdog (after ${elapsedSec}s)`);
                return;
              }

              await new Promise(resolve => setTimeout(resolve, pollInterval));
            }

            // Quick-fail window closed - exit without error
            console.log('Quick-fail window (5 min) closed - Cancel Watchdog exiting');
            console.log('Long-running tests will be handled by Rerun Watchdog if they fail');
            core.info('Cancel Watchdog completed - quick-fail monitoring done');

  # ============================================================================
  # COLUMN 2: QUALITY
  # Jobs: quality (reusable workflow)
  # Dependencies: [initialize]
  # ============================================================================
  quality:
    name: Quality
    needs: [initialize]
    if: needs.initialize.outputs.is_bot != 'true'
    uses: ./.github/workflows/ci-quality.yml
    with:
      is_bot: ${{ needs.initialize.outputs.is_bot }}
      next_version: ${{ needs.initialize.outputs.next_version }}
    secrets: inherit

  # ============================================================================
  # REVIEW GATE: Trigger Gemini review, wait for it, check resolved threads
  # Dependencies: [initialize, quality]
  # Must pass before Build jobs can start
  #
  # Flow: Quality passes → Trigger Gemini → Wait for response → Check threads
  # ============================================================================
  review-gate:
    name: Review Gate
    needs: [initialize, quality]
    runs-on: ubuntu-slim
    if: needs.initialize.outputs.is_bot != 'true' && github.event_name == 'pull_request'
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6
        with:
          sparse-checkout: .ci/scripts
      - name: Trigger Gemini review
        run: .ci/scripts/quality/trigger-gemini-review.sh
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          GITHUB_REPOSITORY: ${{ github.repository }}
      - name: Wait for Gemini review
        run: .ci/scripts/quality/wait-gemini-review.sh
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          GITHUB_REPOSITORY: ${{ github.repository }}
      - name: Check resolved threads
        run: .ci/scripts/quality/check-resolved-threads.sh
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          GITHUB_REPOSITORY: ${{ github.repository }}

  # ============================================================================
  # QUEUE: Wait for other CI runs to complete (global serialization)
  # Positioned AFTER Quality + Review Gate so fast checks run in parallel.
  # Only heavy Build/Test jobs wait in queue.
  # Same-PR cancellation is handled by the concurrency group above.
  # ============================================================================
  queue:
    name: Queue
    needs: [initialize, quality, review-gate]
    runs-on: ubuntu-slim
    if: always() && needs.initialize.result == 'success' && needs.quality.result == 'success' && (needs.review-gate.result == 'success' || needs.review-gate.result == 'skipped')
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6
        with:
          sparse-checkout: .ci/scripts
      - name: Wait for other CI runs
        env:
          GH_TOKEN: ${{ github.token }}
          GITHUB_RUN_ID: ${{ github.run_id }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: .ci/scripts/ci/wait-for-queue.sh --timeout 7200 --poll-interval 30

  # ============================================================================
  # COLUMN 3: BUILD & DOCKER
  # Jobs: build-docker, build-desktop (parallel reusable workflows)
  # Dependencies: queue (which includes quality + review-gate)
  # ============================================================================
  build-docker:
    name: Build (Docker)
    needs: [initialize, queue]
    if: always() && needs.initialize.result == 'success' && needs.queue.result == 'success'
    uses: ./.github/workflows/ci-build-docker.yml
    with:
      next_version: ${{ needs.initialize.outputs.next_version }}
      api_tag: ${{ needs.initialize.outputs.api_tag }}
      api_exists: ${{ needs.initialize.outputs.api_exists }}
      bridge_tag: ${{ needs.initialize.outputs.bridge_tag }}
      bridge_exists: ${{ needs.initialize.outputs.bridge_exists }}
      plugins_tag: ${{ needs.initialize.outputs.plugins_tag }}
      plugins_exists: ${{ needs.initialize.outputs.plugins_exists }}
      web_tag: ${{ needs.initialize.outputs.web_tag }}
      web_exists: ${{ needs.initialize.outputs.web_exists }}
      cli_tag: ${{ needs.initialize.outputs.cli_tag }}
      cli_exists: ${{ needs.initialize.outputs.cli_exists }}
    secrets: inherit

  build-desktop:
    name: Build (Desktop)
    needs: [initialize, queue]
    if: always() && needs.initialize.result == 'success' && needs.queue.result == 'success'
    uses: ./.github/workflows/ci-build-desktop.yml
    with:
      next_version: ${{ needs.initialize.outputs.next_version }}
    secrets: inherit

  build-cli:
    name: Build (CLI)
    needs: [initialize, queue]
    if: always() && needs.initialize.result == 'success' && needs.queue.result == 'success'
    uses: ./.github/workflows/ci-build-cli.yml
    with:
      next_version: ${{ needs.initialize.outputs.next_version }}
    secrets: inherit

  # ============================================================================
  # COLUMN 3B: DEPLOY DRY-RUN
  # Jobs: deploy-dryrun (reusable workflow)
  # Dependencies: build-docker, build-desktop, build-cli
  # ============================================================================
  deploy-dryrun:
    name: Deploy Dry-Run
    needs: [initialize, build-docker, build-desktop, build-cli]
    if: always() && needs.initialize.outputs.is_bot != 'true' && needs.initialize.result == 'success' && needs.build-docker.result == 'success' && needs.build-desktop.result == 'success' && needs.build-cli.result == 'success'
    uses: ./.github/workflows/cd-dryrun.yml
    with:
      dry_run: true
      next_version: ${{ needs.initialize.outputs.next_version }}
      staging_tag: dryrun-${{ github.sha }}
      api_tag: ${{ needs.initialize.outputs.api_tag }}
      bridge_tag: ${{ needs.initialize.outputs.bridge_tag }}
      plugins_tag: ${{ needs.initialize.outputs.plugins_tag }}
      web_tag: ${{ needs.initialize.outputs.web_tag }}
      cli_tag: ${{ needs.initialize.outputs.cli_tag }}
    secrets: inherit

  # ============================================================================
  # COLUMN 4: TESTS + INFRA
  # Jobs: tests (reusable workflow)
  # Dependencies: build-docker (tests can start without waiting for desktop builds)
  # ============================================================================
  tests:
    name: Tests + Infra
    needs: [initialize, build-docker]
    if: always() && needs.initialize.result == 'success' && needs.build-docker.result == 'success'
    uses: ./.github/workflows/ct-tests.yml
    with:
      api_tag: ${{ needs.initialize.outputs.api_tag }}
      bridge_tag: ${{ needs.initialize.outputs.bridge_tag }}
      web_tag: ${{ needs.initialize.outputs.web_tag }}
      e2e_browsers: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.browsers == 'all-browsers' && 'chromium firefox webkit msedge' || 'chromium' }}
      provision_vms: true
    secrets: inherit

  # ============================================================================
  # CI COMPLETE - Gate for merge queue
  # This job only succeeds if ALL CI jobs pass
  # ============================================================================
  ci-complete:
    name: CI Complete
    runs-on: ubuntu-slim
    needs: [initialize, quality, review-gate, queue, build-docker, build-desktop, build-cli, deploy-dryrun, tests]
    if: always() && !cancelled()
    steps:
      - name: Check all jobs passed
        run: |
          # review-gate and queue can be skipped for non-PR events or bots
          REVIEW_GATE_OK="false"
          if [[ "${{ needs.review-gate.result }}" == "success" ]] || [[ "${{ needs.review-gate.result }}" == "skipped" ]]; then
            REVIEW_GATE_OK="true"
          fi

          if [[ "${{ needs.initialize.result }}" != "success" ]] || \
             [[ "${{ needs.quality.result }}" != "success" ]] || \
             [[ "$REVIEW_GATE_OK" != "true" ]] || \
             [[ "${{ needs.queue.result }}" != "success" ]] || \
             [[ "${{ needs.build-docker.result }}" != "success" ]] || \
             [[ "${{ needs.build-desktop.result }}" != "success" ]] || \
             [[ "${{ needs.build-cli.result }}" != "success" ]] || \
             [[ "${{ needs.deploy-dryrun.result }}" != "success" ]] || \
             [[ "${{ needs.tests.result }}" != "success" ]]; then
            echo "One or more jobs failed:"
            echo "  initialize: ${{ needs.initialize.result }}"
            echo "  quality: ${{ needs.quality.result }}"
            echo "  review-gate: ${{ needs.review-gate.result }}"
            echo "  queue: ${{ needs.queue.result }}"
            echo "  build-docker: ${{ needs.build-docker.result }}"
            echo "  build-desktop: ${{ needs.build-desktop.result }}"
            echo "  build-cli: ${{ needs.build-cli.result }}"
            echo "  deploy-dryrun: ${{ needs.deploy-dryrun.result }}"
            echo "  tests: ${{ needs.tests.result }}"
            exit 1
          fi
          echo "All CI jobs passed successfully!"

  # ============================================================================
  # RERUN WATCHDOG - Auto-retry flaky jobs (max 3 attempts)
  # Waits for ALL jobs to complete before triggering rerun. This ensures we
  # catch all flaky failures (including long-running tests up to 2h).
  # NOTE: Reruns may fail if dependent infrastructure (e.g., Cloudflare tunnel)
  # is no longer available. In such cases, a fresh run is needed.
  # ============================================================================
  rerun-watchdog:
    name: Rerun Watchdog
    runs-on: ubuntu-latest
    needs: [cancel-watchdog, queue]
    # Only start after Queue passes - no point monitoring if quality checks failed
    if: always() && needs.cancel-watchdog.result == 'success' && needs.queue.result == 'success' && fromJSON(github.run_attempt) < 3
    steps:
      - name: Wait for all jobs and trigger rerun on failures
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd  # v8
        with:
          script: |
            const pollInterval = 30000;    // 30 seconds (reduced API calls)
            const maxRuntime = 10800000;   // 3 hours max (safety limit)
            const startTime = Date.now();

            console.log(`Rerun Watchdog started (attempt ${{ github.run_attempt }}/3)`);
            console.log('Monitoring until all jobs complete...');

            while (Date.now() - startTime < maxRuntime) {
              const elapsed = Date.now() - startTime;
              const elapsedMin = Math.round(elapsed / 60000);

              const { data: jobs } = await github.rest.actions.listJobsForWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: context.runId
              });

              // Filter out watchdog and infrastructure jobs
              const otherJobs = jobs.jobs.filter(j =>
                !j.name.includes('Watchdog') &&
                j.name !== 'Queue' &&
                j.name !== 'CI Complete'
              );

              const completed = otherJobs.filter(j => j.status === 'completed');
              const notCompleted = otherJobs.filter(j => j.status !== 'completed');
              const failed = otherJobs.filter(j => j.conclusion === 'failure');

              // Log status breakdown for debugging
              const statusCounts = {};
              notCompleted.forEach(j => {
                statusCounts[j.status] = (statusCounts[j.status] || 0) + 1;
              });
              const statusStr = Object.entries(statusCounts).map(([k, v]) => `${v} ${k}`).join(', ') || 'none';

              console.log(`[${elapsedMin}m] Jobs: ${completed.length}/${otherJobs.length} done, ${failed.length} failed, pending: ${statusStr}`);

              // Wait for ALL jobs to complete (status === 'completed')
              // This catches all non-complete states: queued, in_progress, waiting, pending
              if (notCompleted.length === 0) {
                if (failed.length > 0) {
                  console.log('');
                  console.log('='.repeat(70));
                  console.log(`ALL JOBS COMPLETED - ${failed.length} failure(s) detected:`);
                  failed.forEach(job => {
                    console.log(`  - ${job.name}`);
                  });
                  console.log('Triggering rerun of failed jobs...');
                  console.log('='.repeat(70));

                  // Trigger rerun via workflow dispatch
                  const ref = context.payload.pull_request?.head?.ref || context.ref.replace('refs/heads/', '');
                  console.log(`Dispatching rerun-failed.yml on ref: ${ref}`);

                  await github.rest.actions.createWorkflowDispatch({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    workflow_id: 'rerun-failed.yml',
                    ref: ref,
                    inputs: {
                      run_id: String(context.runId)
                    }
                  });

                  console.log('Rerun triggered successfully');
                  return;
                } else {
                  console.log('All jobs completed successfully - no rerun needed');
                  return;
                }
              }

              await new Promise(resolve => setTimeout(resolve, pollInterval));
            }

            // Safety timeout reached
            console.log('WARNING: Rerun Watchdog reached 3-hour limit');
            core.warning('Watchdog timeout - some jobs may still be running');

