name: Console CI

on:
  pull_request:
    branches:
      - main
    types: [opened, synchronize, reopened, edited]
  push:
    branches:
      - main
  schedule:
    - cron: '0 3 * * *'  # Nightly at 3:00 UTC
  workflow_dispatch:
    inputs:
      browsers:
        description: 'E2E browsers to test'
        required: false
        type: choice
        default: 'chromium-only'
        options:
          - 'chromium-only'
          - 'all-browsers'

# Required for cancel-watchdog to cancel workflow on job failures,
# GitHub Pages deployment, autofix commits, and Docker publishing
permissions:
  actions: write
  contents: write
  pages: write
  id-token: write
  packages: write  # For GHCR push

# Cancel in-progress runs when a new run is triggered for the same branch/PR
# Use 'no-cancel-push' PR label to disable (see .github/labels.yml)
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: ${{ !contains(github.event.pull_request.labels.*.name, 'no-cancel-push') }}

# E2E Browser Configuration
# Default: chromium only. Use workflow_dispatch with "all-browsers" to test all.
# To permanently enable all browsers, change the fallback value below.
env:
  E2E_BROWSERS: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.browsers == 'all-browsers' && 'chromium firefox webkit msedge' || 'chromium' }}

jobs:
  # ============================================================================
  # COLUMN 1: INITIALIZE
  # Jobs: initialize, cancel-watchdog
  # Dependencies: None
  # ============================================================================
  initialize:
    name: Initialize
    runs-on: ubuntu-latest  # Needs Docker for registry cache check
    if: github.event_name != 'push' || (github.actor != 'github-actions[bot]' && github.actor != 'dependabot[bot]' && !contains(github.event.head_commit.message, '[skip ci]'))
    outputs:
      is_bot: ${{ steps.init.outputs.is_bot }}
      next_version: ${{ steps.init.outputs.next_version }}
      api_tag: ${{ steps.init.outputs.api_tag }}
      api_exists: ${{ steps.init.outputs.api_exists }}
      bridge_tag: ${{ steps.init.outputs.bridge_tag }}
      bridge_exists: ${{ steps.init.outputs.bridge_exists }}
      plugins_tag: ${{ steps.init.outputs.plugins_tag }}
      plugins_exists: ${{ steps.init.outputs.plugins_exists }}
      web_tag: ${{ steps.init.outputs.web_tag }}
      web_exists: ${{ steps.init.outputs.web_exists }}
      image_tag: ${{ steps.init.outputs.image_tag }}
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v5

      # PR Validation (PR events only)
      - name: Validate PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd  # v8
        with:
          script: |
            const pr = context.payload.pull_request;
            const errors = [];
            const warnings = [];

            // Check PR title format (Conventional Commits)
            const titlePattern = /^(feat|fix|docs|style|refactor|perf|test|chore|ci|build|revert)(\(.+\))?: .+/;
            if (!titlePattern.test(pr.title)) {
              errors.push(
                'PR title must follow Conventional Commits format:\n' +
                'type(scope): description\n\n' +
                'Types: feat, fix, docs, style, refactor, perf, test, chore, ci, build, revert\n' +
                'Example: feat(ui): add dark mode toggle'
              );
            }

            // Check PR description length
            const body = pr.body || '';
            if (body.length < 20) {
              errors.push('PR description is too short. Please provide a detailed description.');
            }

            // Check for linked issues (warning only)
            const issuePattern = /(close|closes|closed|fix|fixes|fixed|resolve|resolves|resolved|ref|refs)\s+#\d+/i;
            if (!issuePattern.test(body)) {
              warnings.push('PR does not reference any issues. Consider linking related issues.');
            }

            // Check PR size
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
            });
            const additions = files.reduce((sum, file) => sum + file.additions, 0);
            const deletions = files.reduce((sum, file) => sum + file.deletions, 0);
            const totalChanges = additions + deletions;
            const fileCount = files.length;

            if (totalChanges > 1000) {
              warnings.push(`Large PR detected (${totalChanges} lines changed). Consider breaking it into smaller PRs.`);
            }
            if (fileCount > 30) {
              warnings.push(`Many files changed (${fileCount} files). Consider breaking it into smaller PRs.`);
            }

            // Check mergeable state
            const { data: prData } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
            });
            if (prData.mergeable_state === 'dirty') {
              errors.push('PR has merge conflicts. Please resolve them.');
            }

            // Write summary
            let summary = `## PR Validation\n\n`;
            summary += `- **Files changed:** ${fileCount}\n`;
            summary += `- **Lines added:** ${additions}\n`;
            summary += `- **Lines deleted:** ${deletions}\n`;
            summary += `- **Total changes:** ${totalChanges}\n\n`;

            if (warnings.length > 0) {
              summary += `### Warnings\n`;
              warnings.forEach(w => {
                core.warning(w);
                summary += `- ⚠️ ${w}\n`;
              });
              summary += '\n';
            }

            if (errors.length > 0) {
              summary += `### Errors\n`;
              errors.forEach(e => summary += `- ❌ ${e}\n`);
              core.summary.addRaw(summary).write();
              core.setFailed(errors.join('\n\n'));
            } else {
              summary += `✅ All PR checks passed\n`;
              core.summary.addRaw(summary).write();
            }

      # Login to GHCR for registry cache check
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GH_PAT }}

      # Run consolidated initialization script
      - name: Initialize CI
        id: init
        env:
          GITHUB_PAT: ${{ secrets.GH_PAT }}
          GITHUB_EVENT_NAME: ${{ github.event_name }}
          GITHUB_ACTOR: ${{ github.actor }}
          COMMIT_AUTHOR: ${{ github.event.head_commit.author.name }}
        run: |
          .ci/scripts/ci/initialize.sh --output "$GITHUB_OUTPUT"

      # Upload CI tags as artifact for debugging
      - name: Upload CI Tags
        if: steps.init.outputs.is_bot != 'true'
        run: |
          cat > ci-tags.txt << EOF
          api_tag=${{ steps.init.outputs.api_tag }}
          bridge_tag=${{ steps.init.outputs.bridge_tag }}
          plugins_tag=${{ steps.init.outputs.plugins_tag }}
          web_tag=${{ steps.init.outputs.web_tag }}
          EOF
      - uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4  # v4
        if: steps.init.outputs.is_bot != 'true'
        with:
          name: ci-tags-${{ github.sha }}
          path: ci-tags.txt
          retention-days: 1

  cancel-watchdog:
    name: Cancel Watchdog
    runs-on: ubuntu-slim
    if: always() && (github.event_name != 'push' || (github.actor != 'github-actions[bot]' && github.actor != 'dependabot[bot]' && !contains(github.event.head_commit.message, '[skip ci]')))
    steps:
      - name: Monitor jobs and cancel on failure
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd  # v8
        with:
          script: |
            const pollInterval = 10000; // 10 seconds
            const maxRuntime = 600000;  // 10 minutes max
            const minRuntime = 120000;  // 2 minutes minimum before allowing workflow-complete exit
            const startTime = Date.now();

            // Check for skip-cancellation label
            let skipCancellationOnFailure = false;
            if (context.payload.pull_request) {
              const labels = context.payload.pull_request.labels.map(l => l.name);
              skipCancellationOnFailure = labels.includes('no-cancel-failure');
              if (skipCancellationOnFailure) {
                console.log('Label "no-cancel-failure" detected - will not cancel on job failures');
              }
            }

            console.log('Watchdog started - monitoring for job failures...');

            while (Date.now() - startTime < maxRuntime) {
              const elapsed = Date.now() - startTime;
              const elapsedSec = Math.round(elapsed / 1000);

              const { data: run } = await github.rest.actions.getWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: context.runId
              });

              const { data: jobs } = await github.rest.actions.listJobsForWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: context.runId
              });

              const otherJobs = jobs.jobs.filter(j => !j.name.includes('Watchdog'));
              const completed = otherJobs.filter(j => j.status === 'completed').length;
              const inProgress = otherJobs.filter(j => j.status === 'in_progress').length;
              const queued = otherJobs.filter(j => j.status === 'queued').length;

              console.log(`[${elapsedSec}s] Jobs: ${completed} done, ${inProgress} running, ${queued} queued (workflow: ${run.status})`);

              // Check if workflow was externally cancelled (e.g., by concurrency or manual cancellation)
              const cancelledJobs = otherJobs.filter(job => job.conclusion === 'cancelled');
              const completedJobs = otherJobs.filter(job => job.status === 'completed');
              if (cancelledJobs.length > 0 && cancelledJobs.length >= completedJobs.length / 2) {
                console.log(`Workflow externally cancelled (${cancelledJobs.length}/${completedJobs.length} jobs cancelled) - exiting watchdog`);
                return;
              }

              const failedJob = otherJobs.find(job => job.conclusion === 'failure');

              if (failedJob) {
                const failureMsg = `Job failed: "${failedJob.name}"`;
                console.log('');
                console.log('='.repeat(70));
                console.log(failureMsg);
                console.log(`   Job URL: https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}/job/${failedJob.id}`);
                console.log('='.repeat(70));

                if (skipCancellationOnFailure) {
                  console.log('');
                  console.log('NOTICE: Skipping workflow cancellation due to "no-cancel-failure" label');
                  console.log('Workflow will continue running despite this failure.');
                  core.setFailed(failureMsg + ' (cancellation skipped due to label)');
                  return;
                }

                await github.rest.actions.cancelWorkflowRun({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  run_id: context.runId
                });

                core.setFailed('PIPELINE CANCELLED: ' + failureMsg);
                return;
              }

              if (run.status === 'completed' && elapsed >= minRuntime) {
                console.log(`Workflow completed - exiting watchdog (after ${elapsedSec}s)`);
                return;
              }

              await new Promise(resolve => setTimeout(resolve, pollInterval));
            }

            console.log('Watchdog completed - no failures detected in 10 minutes');
            core.info('All monitored jobs healthy during watch period');

  # ============================================================================
  # COLUMN 2: QUALITY
  # Jobs: quality (reusable workflow)
  # Dependencies: [initialize]
  # ============================================================================
  quality:
    name: Quality
    needs: [initialize]
    if: needs.initialize.outputs.is_bot != 'true'
    uses: ./.github/workflows/ci-quality.yml
    with:
      is_bot: ${{ needs.initialize.outputs.is_bot }}
      next_version: ${{ needs.initialize.outputs.next_version }}
    secrets: inherit

  # ============================================================================
  # COLUMN 3: BUILD & DOCKER
  # Jobs: build (reusable workflow)
  # Dependencies: quality
  # ============================================================================
  build:
    name: Build
    needs: [initialize, quality]
    uses: ./.github/workflows/ci-build.yml
    with:
      next_version: ${{ needs.initialize.outputs.next_version }}
      api_tag: ${{ needs.initialize.outputs.api_tag }}
      api_exists: ${{ needs.initialize.outputs.api_exists }}
      bridge_tag: ${{ needs.initialize.outputs.bridge_tag }}
      bridge_exists: ${{ needs.initialize.outputs.bridge_exists }}
      plugins_tag: ${{ needs.initialize.outputs.plugins_tag }}
      plugins_exists: ${{ needs.initialize.outputs.plugins_exists }}
      web_tag: ${{ needs.initialize.outputs.web_tag }}
      web_exists: ${{ needs.initialize.outputs.web_exists }}
    secrets: inherit

  # ============================================================================
  # COLUMN 4: TESTS + INFRA
  # Jobs: tests (reusable workflow)
  # Dependencies: build
  # ============================================================================
  tests:
    name: Tests + Infra
    needs: [initialize, build]
    uses: ./.github/workflows/ci-tests.yml
    with:
      api_tag: ${{ needs.initialize.outputs.api_tag }}
      bridge_tag: ${{ needs.initialize.outputs.bridge_tag }}
      web_tag: ${{ needs.initialize.outputs.web_tag }}
      e2e_browsers: ${{ env.E2E_BROWSERS }}
    secrets: inherit

  # ============================================================================
  # COLUMN 5: DEPLOY/RELEASE
  # Jobs: deploy (reusable workflow)
  # Dependencies: tests
  # ============================================================================
  deploy:
    name: Deploy
    needs: [initialize, build, tests]
    uses: ./.github/workflows/ci-deploy.yml
    with:
      next_version: ${{ needs.initialize.outputs.next_version }}
      api_tag: ${{ needs.initialize.outputs.api_tag }}
      bridge_tag: ${{ needs.initialize.outputs.bridge_tag }}
      plugins_tag: ${{ needs.initialize.outputs.plugins_tag }}
    secrets: inherit

  # ============================================================================
  # COLUMN 6: SUMMARY
  # Jobs: summary
  # Dependencies: All jobs
  # ============================================================================
  summary:
    name: Summary
    runs-on: ubuntu-slim
    needs: [initialize, quality, build, tests, deploy]
    if: always() && (github.event_name != 'push' || (github.actor != 'github-actions[bot]' && github.actor != 'dependabot[bot]' && !contains(github.event.head_commit.message, '[skip ci]'))) && needs.initialize.result != 'skipped' && needs.initialize.outputs.is_bot != 'true'
    steps:
      - name: Check job results
        run: |
          echo "## CI Pipeline Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Column 1: Initialize" >> $GITHUB_STEP_SUMMARY
          echo "- Initialize: ${{ needs.initialize.result }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Column 2: Quality" >> $GITHUB_STEP_SUMMARY
          echo "- Quality: ${{ needs.quality.result }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Column 3: Build & Docker" >> $GITHUB_STEP_SUMMARY
          echo "- Build: ${{ needs.build.result }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Column 4: Tests + Infra" >> $GITHUB_STEP_SUMMARY
          echo "- Tests + Infra: ${{ needs.tests.result }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Column 5: Deploy/Release" >> $GITHUB_STEP_SUMMARY
          echo "- Deploy: ${{ needs.deploy.result }}" >> $GITHUB_STEP_SUMMARY

          FAILED=false

          # Check required jobs (must succeed)
          for result in "${{ needs.quality.result }}" "${{ needs.build.result }}" "${{ needs.tests.result }}"; do
            [ "$result" != "success" ] && FAILED=true
          done

          # Check conditional jobs separately (skipped is acceptable, failure is not)
          for result in "${{ needs.deploy.result }}"; do
            if [ "$result" = "failure" ]; then
              FAILED=true
            fi
          done

          if [ "$FAILED" = "true" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**CI Pipeline Failed**" >> $GITHUB_STEP_SUMMARY
            exit 1
          else
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**All CI Checks Passed**" >> $GITHUB_STEP_SUMMARY
          fi
