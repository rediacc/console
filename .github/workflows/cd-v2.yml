name: Console CD v2

# Publish-only CD workflow triggered when CI completes on main.
# All builds run in CI; CD only publishes artifacts produced by CI.
# 1. init: Resolve CI run context, recalculate version, guard against duplicates
# 2. publish: Promote Docker images, create Release, deploy Pages

on:
  workflow_run:
    workflows: ["Console CI"]
    types: [completed]
    branches: [main]
  workflow_dispatch:
    inputs:
      ci_run_id:
        description: 'CI workflow run ID to publish from'
        required: true
        type: string
      dry_run:
        description: 'Dry-run mode (validate without publishing)'
        required: false
        type: boolean
        default: false

# Required for GitHub Pages deployment and Docker publishing
permissions:
  actions: write
  contents: write
  pages: write
  id-token: write
  packages: write  # For GHCR push

# Queue new releases instead of cancelling in-progress ones
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  # ============================================================================
  # INITIALIZE
  # Resolve CI run context, recalculate version, guard against duplicate publish
  # ============================================================================
  init:
    name: Initialize
    runs-on: ubuntu-latest
    if: >-
      (github.event_name == 'workflow_dispatch') ||
      (github.event_name == 'workflow_run'
        && github.event.workflow_run.conclusion == 'success'
        && github.event.workflow_run.event == 'push')
    outputs:
      ci_run_id: ${{ steps.resolve.outputs.ci_run_id }}
      ci_sha: ${{ steps.resolve.outputs.ci_sha }}
      next_version: ${{ steps.init.outputs.next_version }}
      bump_type: ${{ steps.init.outputs.bump_type }}
      staging_tag: ${{ steps.staging.outputs.staging_tag }}
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6
        with:
          persist-credentials: false

      - uses: ./.github/actions/app-token
        id: app-token
        with:
          app-id: ${{ vars.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}
          preset: cd
          repositories: console,middleware,renet,license-server,homebrew-tap,elite

      # Re-checkout with submodules using app token (needed for submodule branch check)
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6
        with:
          submodules: true
          token: ${{ steps.app-token.outputs.token }}

      # Resolve CI run context from workflow_run event or workflow_dispatch input
      - name: Resolve CI run context
        id: resolve
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          if [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            echo "ci_run_id=${{ github.event.workflow_run.id }}" >> $GITHUB_OUTPUT
            echo "ci_sha=${{ github.event.workflow_run.head_sha }}" >> $GITHUB_OUTPUT
            echo "Resolved from workflow_run: run=${{ github.event.workflow_run.id }}, sha=${{ github.event.workflow_run.head_sha }}"
          else
            CI_RUN_ID="${{ inputs.ci_run_id }}"
            # Fetch the SHA from the specified CI run
            CI_SHA=$(gh api "repos/${{ github.repository }}/actions/runs/${CI_RUN_ID}" --jq '.head_sha')
            echo "ci_run_id=${CI_RUN_ID}" >> $GITHUB_OUTPUT
            echo "ci_sha=${CI_SHA}" >> $GITHUB_OUTPUT
            echo "Resolved from workflow_dispatch: run=${CI_RUN_ID}, sha=${CI_SHA}"
          fi

      # Recalculate version independently (reads current version from git)
      - name: Initialize CI
        id: init
        env:
          GITHUB_PAT: ${{ steps.app-token.outputs.token }}
          GITHUB_EVENT_NAME: ${{ github.event_name }}
          GITHUB_ACTOR: ${{ github.actor }}
          COMMIT_AUTHOR: ${{ github.event.head_commit.author.name }}
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          .ci/scripts/ci/initialize.sh --output "$GITHUB_OUTPUT"

      - name: Generate staging tag
        id: staging
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ inputs.dry_run }}" == "true" ]]; then
            echo "staging_tag=dryrun-${{ steps.resolve.outputs.ci_sha }}" >> $GITHUB_OUTPUT
          else
            echo "staging_tag=staging-${{ steps.resolve.outputs.ci_sha }}" >> $GITHUB_OUTPUT
          fi

      # Version guard: fail early if this version was already published
      - name: Check for existing release
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          VERSION="${{ steps.init.outputs.next_version }}"
          if gh release view "v${VERSION}" --repo "${{ github.repository }}" &>/dev/null; then
            echo "::error::Release v${VERSION} already exists. Aborting to prevent duplicate publish."
            exit 1
          fi
          echo "Version v${VERSION} is available for publishing."

      # Submodule guard: fail early if any submodule has diverged from origin/main
      - name: Check submodule branches
        run: .ci/scripts/release/merge-submodule-branches.sh --dry-run
        env:
          GITHUB_PAT: ${{ steps.app-token.outputs.token }}
          GH_TOKEN: ${{ steps.app-token.outputs.token }}

  # ============================================================================
  # CD WATCHDOG - monitors jobs, auto-retries transient build failures
  # ============================================================================
  cd-watchdog:
    name: CD Watchdog
    needs: [init]
    runs-on: ubuntu-latest
    timeout-minutes: 240  # 4 hours (CD builds take longer than CI)
    if: ${{ !cancelled() && needs.init.result == 'success' }}
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6
        with:
          sparse-checkout: .ci/scripts

      - name: Monitor jobs and auto-retry on failure
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd  # v8
        env:
          WATCHDOG_EXCLUDE_PATTERNS: 'Watchdog,CD Watchdog'
          WATCHDOG_NO_RETRY_PATTERNS: 'Publish,Validate Install Methods,Cleanup'
        with:
          script: return await require('./.ci/scripts/ci/watchdog-monitor.cjs')({github, context, core})

  # ============================================================================
  # PUBLISH
  # Actually publish to GitHub Release, Docker, Pages
  # Downloads artifacts cross-workflow from the CI run using --run-id
  # ============================================================================
  publish:
    name: Publish
    runs-on: ubuntu-latest
    needs: [init]
    if: >-
      success() &&
      !(github.event_name == 'workflow_dispatch' && inputs.dry_run)
    environment:
      name: github-pages
      url: ${{ steps.pages-deploy.outputs.page_url }}
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6

      - uses: ./.github/actions/app-token
        id: app-token
        with:
          app-id: ${{ vars.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}
          preset: cd
          repositories: console,middleware,renet,license-server,homebrew-tap,elite

      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6
        with:
          fetch-depth: 0
          submodules: true
          token: ${{ steps.app-token.outputs.token }}
      - uses: actions/setup-node@395ad3262231945c25e8478fd5baf05154b1d79f  # v6
        with:
          node-version: '22'

      # -----------------------------------------------------------------------
      # Step 1: Promote Docker images (staging -> version + latest)
      # -----------------------------------------------------------------------
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ github.token }}

      - name: Promote Docker images
        run: |
          STAGING_TAG="${{ needs.init.outputs.staging_tag }}"
          VERSION="${{ needs.init.outputs.next_version }}"

          .ci/scripts/docker/retag-image.sh --image api --from "$STAGING_TAG" --to "$VERSION" --push-latest --skip-if-exists
          .ci/scripts/docker/retag-image.sh --image bridge --from "$STAGING_TAG" --to "$VERSION" --push-latest --skip-if-exists
          .ci/scripts/docker/retag-image.sh --image plugin-terminal --from "$STAGING_TAG" --to "$VERSION" --push-latest --skip-if-exists
          .ci/scripts/docker/retag-image.sh --image plugin-browser --from "$STAGING_TAG" --to "$VERSION" --push-latest --skip-if-exists
          .ci/scripts/docker/retag-image.sh --image web --from "$STAGING_TAG" --to "$VERSION" --push-latest --skip-if-exists
          .ci/scripts/docker/retag-image.sh --image cli --from "$STAGING_TAG" --to "$VERSION" --push-latest --skip-if-exists

      # -----------------------------------------------------------------------
      # Step 1b: Deploy License Server to Cloudflare
      # Build shared packages first (license-server imports from @rediacc/shared)
      # -----------------------------------------------------------------------
      - name: Install dependencies
        run: npm ci

      - name: Build shared packages
        run: npm run build:packages

      - name: Deploy License Server
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        run: .ci/scripts/private/run-license-server.sh deploy

      # -----------------------------------------------------------------------
      # Step 1c: Merge submodule PRs to main
      # Must run BEFORE bump-submodules.sh which resets submodules to origin/main
      # -----------------------------------------------------------------------
      - name: Merge submodule branches
        run: .ci/scripts/release/merge-submodule-branches.sh
        env:
          GITHUB_PAT: ${{ steps.app-token.outputs.token }}
          GH_TOKEN: ${{ steps.app-token.outputs.token }}

      # -----------------------------------------------------------------------
      # Step 2: Bump version & commit (includes all submodules)
      # -----------------------------------------------------------------------
      - name: Download staging release artifact
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131  # v7
        with:
          name: staging-release-${{ needs.init.outputs.ci_sha }}
          path: dist/
          run-id: ${{ needs.init.outputs.ci_run_id }}
          github-token: ${{ github.token }}

      - name: Version bump
        run: .ci/scripts/version/bump.sh --version ${{ needs.init.outputs.next_version }}

      - name: Bump submodule versions
        run: |
          .ci/scripts/version/bump-submodules.sh --version ${{ needs.init.outputs.next_version }} --stage-only
        env:
          GITHUB_PAT: ${{ steps.app-token.outputs.token }}

      - name: Update Homebrew formula
        run: |
          .ci/scripts/release/update-homebrew-tap.sh \
            --version ${{ needs.init.outputs.next_version }} \
            --local-checksums dist/cli \
            --stage-only
        env:
          GITHUB_PAT: ${{ steps.app-token.outputs.token }}

      - name: Version commit
        id: commit
        run: |
          .ci/scripts/version/commit.sh --version ${{ needs.init.outputs.next_version }} --bump-type ${{ needs.init.outputs.bump_type }} --push --include-submodules
          echo "release_sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
        env:
          GITHUB_HEAD_REF: main

      # -----------------------------------------------------------------------
      # Step 3: Create GitHub Release (upload packages + binaries)
      # -----------------------------------------------------------------------
      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.init.outputs.next_version }}
          name: v${{ needs.init.outputs.next_version }}
          target_commitish: ${{ steps.commit.outputs.release_sha }}
          files: |
            dist/desktop/**/*
            dist/cli/**/*
            dist/packages/**/*
          draft: false
          prerelease: false
          generate_release_notes: true

      # -----------------------------------------------------------------------
      # Step 4: Download packages from Release for metadata (ensures exact match)
      # -----------------------------------------------------------------------
      - name: Download packages from Release
        run: |
          VERSION="${{ needs.init.outputs.next_version }}"
          mkdir -p dist/release-pkgs

          echo "Downloading packages from GitHub Release v$VERSION..."
          gh release download "v$VERSION" --pattern "*.deb" --pattern "*.rpm" --dir dist/release-pkgs --clobber || true

          # Filter to only CLI packages (exclude desktop packages)
          find dist/release-pkgs -name "rediacc-desktop-*" -delete 2>/dev/null || true

          echo "Downloaded packages:"
          ls -la dist/release-pkgs/
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}

      # -----------------------------------------------------------------------
      # Step 5: Build final APT/RPM repo metadata (matching Release)
      # -----------------------------------------------------------------------
      - name: Install repo build tools
        run: sudo apt-get update -qq && sudo apt-get install -y -qq dpkg-dev createrepo-c rpm gnupg

      - name: Download staging pages artifact
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131  # v7
        with:
          name: staging-pages-${{ needs.init.outputs.ci_sha }}
          path: dist/pages/
          run-id: ${{ needs.init.outputs.ci_run_id }}
          github-token: ${{ github.token }}

      # Inject E2E videos from the same CI run that produced staging artifacts
      - name: Inject E2E videos
        env:
          GH_TOKEN: ${{ github.token }}
        run: >-
          .ci/scripts/docs/inject-e2e-videos.sh
          --run-id "${{ needs.init.outputs.ci_run_id }}"
          --artifact-name "e2e-videos-${{ needs.init.outputs.ci_sha }}"
          --output dist/pages/assets/videos/user-guide/

      - name: Rebuild package metadata from Release packages
        run: |
          VERSION="${{ needs.init.outputs.next_version }}"

          # Rebuild repos using the exact packages from GitHub Release
          # This ensures metadata checksums match the actual release assets
          .ci/scripts/build/build-pkg-repo.sh \
            --version "$VERSION" \
            --local-pkgs dist/release-pkgs \
            --output dist/pages \
            --max-versions 3
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}

      # -----------------------------------------------------------------------
      # Step 6: Deploy GitHub Pages
      # -----------------------------------------------------------------------
      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@7b1f4a764d45c48632c6b24a0339c27f5614fb0b  # v4
        with:
          path: dist/pages/

      - name: Deploy to GitHub Pages
        id: pages-deploy
        uses: actions/deploy-pages@d6db90164ac5ed86f2b6aed7e0febac5b3c0c03e  # v4

      # -----------------------------------------------------------------------
      # Step 7: Cleanup staging tags
      # -----------------------------------------------------------------------
      - name: Cleanup staging Docker tags
        run: |
          STAGING_TAG="${{ needs.init.outputs.staging_tag }}"
          echo "## Cleanup Staging Tags" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Cleanup is non-critical (staging tags are harmless if they remain),
          # so we log failures to the step summary but don't fail the job.
          if .ci/scripts/docker/cleanup-staging.sh --tag "$STAGING_TAG"; then
            echo "**Staging tag cleaned up:** $STAGING_TAG" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Failed to clean up staging tag:** $STAGING_TAG" >> $GITHUB_STEP_SUMMARY
            echo "Staging tag cleanup requires \`delete:packages\` scope (non-critical)." >> $GITHUB_STEP_SUMMARY
          fi
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}

      # -----------------------------------------------------------------------
      # Final summary
      # -----------------------------------------------------------------------
      - name: Deployment summary
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** v${{ needs.init.outputs.next_version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Release SHA:** ${{ steps.commit.outputs.release_sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**CI Run:** ${{ needs.init.outputs.ci_run_id }} (sha: ${{ needs.init.outputs.ci_sha }})" >> $GITHUB_STEP_SUMMARY
          echo "**Pages URL:** ${{ steps.pages-deploy.outputs.page_url }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Docker images:**" >> $GITHUB_STEP_SUMMARY
          echo "- ghcr.io/rediacc/elite/api:${{ needs.init.outputs.next_version }} + :latest" >> $GITHUB_STEP_SUMMARY
          echo "- ghcr.io/rediacc/elite/bridge:${{ needs.init.outputs.next_version }} + :latest" >> $GITHUB_STEP_SUMMARY
          echo "- ghcr.io/rediacc/elite/plugin-terminal:${{ needs.init.outputs.next_version }} + :latest" >> $GITHUB_STEP_SUMMARY
          echo "- ghcr.io/rediacc/elite/plugin-browser:${{ needs.init.outputs.next_version }} + :latest" >> $GITHUB_STEP_SUMMARY
          echo "- ghcr.io/rediacc/elite/web:${{ needs.init.outputs.next_version }} + :latest" >> $GITHUB_STEP_SUMMARY
          echo "- ghcr.io/rediacc/elite/cli:${{ needs.init.outputs.next_version }} + :latest" >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # VALIDATE INSTALL METHODS - Test all documented installation methods
  # ============================================================================
  validate-install-methods:
    name: Validate Install Methods
    needs: [init, publish]
    if: >-
      success() &&
      !(github.event_name == 'workflow_dispatch' && inputs.dry_run)
    uses: ./.github/workflows/ct-install-methods.yml
    with:
      version: ${{ needs.init.outputs.next_version }}
    secrets: inherit

  # ============================================================================
  # CLEANUP ON FAILURE - Remove staging artifacts if publish fails
  # ============================================================================
  cleanup-on-failure:
    name: Cleanup (on failure)
    runs-on: ubuntu-latest
    needs: [init, publish]
    if: |
      always() &&
      !(github.event_name == 'workflow_dispatch' && inputs.dry_run) &&
      needs.publish.result == 'failure'
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6

      - uses: ./.github/actions/app-token
        id: app-token
        with:
          app-id: ${{ vars.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}
          preset: cd
          repositories: console

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ github.token }}

      - name: Cleanup staging Docker tags
        run: |
          STAGING_TAG="${{ needs.init.outputs.staging_tag }}"
          echo "## Cleanup Staging Tags (Failure)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if .ci/scripts/docker/cleanup-staging.sh --tag "$STAGING_TAG"; then
            echo "**Staging tag cleaned up:** $STAGING_TAG" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Failed to clean up staging tag:** $STAGING_TAG" >> $GITHUB_STEP_SUMMARY
            echo "Staging tag cleanup requires \`delete:packages\` scope (non-critical)." >> $GITHUB_STEP_SUMMARY
          fi
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
