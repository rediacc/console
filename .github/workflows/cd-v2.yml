name: Console CD v2

# Publish-only CD workflow triggered when CI completes on main.
# All builds run in CI; CD only publishes artifacts produced by CI.
# 1. init: Resolve CI run context, recalculate version, guard against duplicates
# 2. publish: Promote Docker images, create Release, deploy Pages

on:
  workflow_run:
    workflows: ["Console CI"]
    types: [completed]
    branches: [main]
  workflow_dispatch:
    inputs:
      ci_run_id:
        description: 'CI workflow run ID to publish from'
        required: true
        type: string
      dry_run:
        description: 'Dry-run mode (validate without publishing)'
        required: false
        type: boolean
        default: false

# Required for release publishing, Docker, and Cloudflare Pages deployment
permissions:
  actions: write
  contents: write
  packages: write       # For GHCR push
  attestations: write   # Verify artifact provenance

# Queue new releases instead of cancelling in-progress ones
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  # ============================================================================
  # INITIALIZE
  # Resolve CI run context, recalculate version, guard against duplicate publish
  # ============================================================================
  init:
    name: Initialize
    runs-on: ubuntu-latest
    if: >-
      (github.event_name == 'workflow_dispatch') ||
      (github.event_name == 'workflow_run'
        && github.event.workflow_run.conclusion == 'success'
        && github.event.workflow_run.event == 'push')
    outputs:
      ci_run_id: ${{ steps.resolve.outputs.ci_run_id }}
      ci_sha: ${{ steps.resolve.outputs.ci_sha }}
      next_version: ${{ steps.init.outputs.next_version }}
      bump_type: ${{ steps.init.outputs.bump_type }}
      staging_tag: ${{ steps.staging.outputs.staging_tag }}
      skip_release: ${{ steps.skip-check.outputs.skip_release }}
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6
        with:
          persist-credentials: false

      - uses: ./.github/actions/app-token
        id: app-token
        with:
          app-id: ${{ vars.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}
          preset: cd
          repositories: console,middleware,renet,account,homebrew-tap,elite,sql,growth

      # Re-checkout with submodules using app token (needed for submodule branch check)
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6
        with:
          fetch-depth: 0  # Full history needed for merge-base --is-ancestor in submodule divergence check
          submodules: true
          token: ${{ steps.app-token.outputs.token }}

      # Resolve CI run context from workflow_run event or workflow_dispatch input
      - name: Resolve CI run context
        id: resolve
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          if [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            echo "ci_run_id=${{ github.event.workflow_run.id }}" >> $GITHUB_OUTPUT
            echo "ci_sha=${{ github.event.workflow_run.head_sha }}" >> $GITHUB_OUTPUT
            echo "Resolved from workflow_run: run=${{ github.event.workflow_run.id }}, sha=${{ github.event.workflow_run.head_sha }}"
          else
            CI_RUN_ID="${{ inputs.ci_run_id }}"
            # Fetch the SHA from the specified CI run
            CI_SHA=$(gh api "repos/${{ github.repository }}/actions/runs/${CI_RUN_ID}" --jq '.head_sha')
            echo "ci_run_id=${CI_RUN_ID}" >> $GITHUB_OUTPUT
            echo "ci_sha=${CI_SHA}" >> $GITHUB_OUTPUT
            echo "Resolved from workflow_dispatch: run=${CI_RUN_ID}, sha=${CI_SHA}"
          fi

      # Check if the merged PR has the 'release' label (opt-in to CD pipeline)
      # Without the label, CD is skipped — prevents accidental releases from chore PRs.
      # Manual workflow_dispatch always proceeds (operator explicitly triggered CD).
      - name: Check for release label
        id: skip-check
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          if [[ "${{ github.event_name }}" != "workflow_run" ]]; then
            echo "skip_release=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          CI_SHA="${{ steps.resolve.outputs.ci_sha }}"
          COMMIT_MSG=$(git log -1 --format="%B" "$CI_SHA" 2>/dev/null || true)
          PR_NUM=$(echo "$COMMIT_MSG" | grep -oE '\(#[0-9]+\)' | grep -oE '[0-9]+' | head -1 || true)

          if [[ -z "$PR_NUM" ]]; then
            echo "No PR number found in commit message, skipping release"
            echo "skip_release=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          LABELS=$(gh pr view "$PR_NUM" --repo "${{ github.repository }}" --json labels --jq '.labels[].name' 2>/dev/null || true)
          if echo "$LABELS" | grep -qx "release"; then
            echo "skip_release=false" >> $GITHUB_OUTPUT
          else
            echo "::notice::Skipping release — PR #$PR_NUM does not have 'release' label"
            echo "skip_release=true" >> $GITHUB_OUTPUT
          fi

      # Recalculate version independently (reads current version from git)
      - name: Initialize CI
        if: steps.skip-check.outputs.skip_release != 'true'
        id: init
        env:
          GITHUB_PAT: ${{ steps.app-token.outputs.token }}
          GITHUB_EVENT_NAME: ${{ github.event_name }}
          GITHUB_ACTOR: ${{ github.actor }}
          COMMIT_AUTHOR: ${{ github.event.head_commit.author.name }}
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          .ci/scripts/ci/initialize.sh --output "$GITHUB_OUTPUT"

      - name: Generate staging tag
        if: steps.skip-check.outputs.skip_release != 'true'
        id: staging
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ inputs.dry_run }}" == "true" ]]; then
            echo "staging_tag=dryrun-${{ steps.resolve.outputs.ci_sha }}" >> $GITHUB_OUTPUT
          else
            echo "staging_tag=staging-${{ steps.resolve.outputs.ci_sha }}" >> $GITHUB_OUTPUT
          fi

      # Version guard: fail early if this version was already published
      - name: Check for existing release
        if: steps.skip-check.outputs.skip_release != 'true'
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          VERSION="${{ steps.init.outputs.next_version }}"
          if gh release view "v${VERSION}" --repo "${{ github.repository }}" &>/dev/null; then
            echo "::error::Release v${VERSION} already exists. Aborting to prevent duplicate publish."
            exit 1
          fi
          echo "Version v${VERSION} is available for publishing."

      # Submodule guard: fail early if any submodule has diverged from origin/main
      - name: Check submodule branches
        if: steps.skip-check.outputs.skip_release != 'true'
        run: .ci/scripts/release/merge-submodule-branches.sh --dry-run
        env:
          GITHUB_PAT: ${{ steps.app-token.outputs.token }}
          GH_TOKEN: ${{ steps.app-token.outputs.token }}

  # ============================================================================
  # CD WATCHDOG - monitors jobs, auto-retries transient build failures
  # ============================================================================
  cd-watchdog:
    name: CD Watchdog
    needs: [init]
    runs-on: ubuntu-latest
    timeout-minutes: 240  # 4 hours (CD builds take longer than CI)
    if: ${{ !cancelled() && needs.init.result == 'success' && needs.init.outputs.skip_release != 'true' }}
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6
        with:
          sparse-checkout: .ci/scripts

      - name: Monitor jobs and auto-retry on failure
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd  # v8
        env:
          WATCHDOG_EXCLUDE_PATTERNS: 'Watchdog,CD Watchdog'
          WATCHDOG_NO_RETRY_PATTERNS: 'Publish,Validate Install Methods,Cleanup'
        with:
          script: return await require('./.ci/scripts/ci/watchdog-monitor.cjs')({github, context, core})

  # ============================================================================
  # PUBLISH
  # Actually publish to GitHub Release, Docker, Pages
  # Downloads artifacts cross-workflow from the CI run using --run-id
  # ============================================================================
  publish:
    name: Publish
    runs-on: ubuntu-latest
    needs: [init]
    if: >-
      success() &&
      needs.init.outputs.skip_release != 'true' &&
      !(github.event_name == 'workflow_dispatch' && inputs.dry_run)
    environment:
      name: production
      url: https://www.rediacc.com
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6

      - uses: ./.github/actions/app-token
        id: app-token
        with:
          app-id: ${{ vars.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}
          preset: cd
          repositories: console,middleware,renet,account,homebrew-tap,elite,sql,growth

      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6
        with:
          fetch-depth: 0
          submodules: true
          token: ${{ steps.app-token.outputs.token }}
      - uses: actions/setup-node@395ad3262231945c25e8478fd5baf05154b1d79f  # v6
        with:
          node-version: '22'

      # -----------------------------------------------------------------------
      # Step 1: Promote Docker images (staging -> version + latest)
      # -----------------------------------------------------------------------
      - name: Login to GHCR
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9  # v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ github.token }}

      - name: Promote Docker images
        run: |
          STAGING_TAG="${{ needs.init.outputs.staging_tag }}"
          VERSION="${{ needs.init.outputs.next_version }}"

          .ci/scripts/docker/retag-image.sh --image api --from "$STAGING_TAG" --to "$VERSION" --push-latest --skip-if-exists
          .ci/scripts/docker/retag-image.sh --image bridge --from "$STAGING_TAG" --to "$VERSION" --push-latest --skip-if-exists
          .ci/scripts/docker/retag-image.sh --image plugin-terminal --from "$STAGING_TAG" --to "$VERSION" --push-latest --skip-if-exists
          .ci/scripts/docker/retag-image.sh --image plugin-browser --from "$STAGING_TAG" --to "$VERSION" --push-latest --skip-if-exists
          .ci/scripts/docker/retag-image.sh --image web --from "$STAGING_TAG" --to "$VERSION" --push-latest --skip-if-exists
          .ci/scripts/docker/retag-image.sh --image cli --from "$STAGING_TAG" --to "$VERSION" --push-latest --skip-if-exists

      # -----------------------------------------------------------------------
      # Step 1b: Install dependencies and build shared packages
      # (account code is embedded in the www worker via direct import)
      # -----------------------------------------------------------------------
      - name: Install dependencies
        run: npm ci

      - name: Build shared packages
        run: npm run build:packages

      - name: Install account dependencies
        run: npm install
        working-directory: private/account

      - name: Sync Stripe products/prices
        run: npx tsx scripts/stripe-sync.ts
        working-directory: private/account
        env:
          STRIPE_SECRET_KEY: ${{ secrets.STRIPE_SECRET_KEY }}

      # -----------------------------------------------------------------------
      # Step 1c: Merge submodule PRs to main
      # Must run BEFORE bump-submodules.sh which resets submodules to origin/main
      # -----------------------------------------------------------------------
      - name: Merge submodule branches
        run: .ci/scripts/release/merge-submodule-branches.sh
        env:
          GITHUB_PAT: ${{ steps.app-token.outputs.token }}
          GH_TOKEN: ${{ steps.app-token.outputs.token }}

      # -----------------------------------------------------------------------
      # Step 2: Bump version & commit (includes all submodules)
      # -----------------------------------------------------------------------
      - name: Download staging release artifact
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131  # v7
        with:
          name: staging-release-${{ needs.init.outputs.ci_sha }}
          path: dist/
          run-id: ${{ needs.init.outputs.ci_run_id }}
          github-token: ${{ github.token }}

      - name: Verify staging release attestation
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "Verifying artifact provenance..."
          FAILED=false
          for f in $(find dist/desktop dist/cli dist/packages -type f 2>/dev/null); do
            gh attestation verify "$f" --repo "${{ github.repository }}" 2>/dev/null || {
              echo "::warning::No attestation for $f (expected for first run after attestation is enabled)"
              FAILED=true
            }
          done
          if [[ "$FAILED" == "true" ]]; then
            echo "::warning::Some artifacts lack attestation — this is expected during the transition period"
          fi

      - name: Version bump
        run: .ci/scripts/version/bump.sh --version ${{ needs.init.outputs.next_version }}

      - name: Bump submodule versions
        run: |
          .ci/scripts/version/bump-submodules.sh --version ${{ needs.init.outputs.next_version }} --stage-only
        env:
          GITHUB_PAT: ${{ steps.app-token.outputs.token }}

      - name: Update Homebrew formula
        run: |
          .ci/scripts/release/update-homebrew-tap.sh \
            --version ${{ needs.init.outputs.next_version }} \
            --local-checksums dist/cli \
            --stage-only
        env:
          GITHUB_PAT: ${{ steps.app-token.outputs.token }}

      - name: Version commit
        id: commit
        run: |
          .ci/scripts/version/commit.sh --version ${{ needs.init.outputs.next_version }} --bump-type ${{ needs.init.outputs.bump_type }} --push --include-submodules
          echo "release_sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
        env:
          GITHUB_HEAD_REF: main

      # -----------------------------------------------------------------------
      # Step 3: Create GitHub Release (upload packages + binaries)
      # -----------------------------------------------------------------------
      - name: Create Release
        uses: softprops/action-gh-release@a06a81a03ee405af7f2048a818ed3f03bbf83c7b  # v2
        with:
          tag_name: v${{ needs.init.outputs.next_version }}
          name: v${{ needs.init.outputs.next_version }}
          target_commitish: ${{ steps.commit.outputs.release_sha }}
          files: |
            dist/desktop/**/*
            dist/cli/**/*
            dist/packages/**/*
          draft: false
          prerelease: false
          generate_release_notes: true

      # -----------------------------------------------------------------------
      # Step 4: Download packages from Release for metadata (ensures exact match)
      # -----------------------------------------------------------------------
      - name: Download packages from Release
        run: |
          VERSION="${{ needs.init.outputs.next_version }}"
          mkdir -p dist/release-pkgs

          echo "Downloading packages from GitHub Release v$VERSION..."
          gh release download "v$VERSION" --pattern "*.deb" --pattern "*.rpm" --pattern "*.apk" --pattern "*.pkg.tar.zst" --dir dist/release-pkgs --clobber || true

          # Filter to only CLI packages (exclude desktop packages)
          find dist/release-pkgs -name "rediacc-desktop-*" -delete 2>/dev/null || true

          echo "Downloaded packages:"
          ls -la dist/release-pkgs/
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}

      # -----------------------------------------------------------------------
      # Step 5: Build final APT/RPM repo metadata (matching Release)
      # -----------------------------------------------------------------------
      - name: Install repo build tools
        run: sudo apt-get update -qq && sudo apt-get install -y -qq dpkg-dev createrepo-c gnupg

      - name: Download staging pages artifact
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131  # v7
        with:
          name: staging-pages-${{ needs.init.outputs.ci_sha }}
          path: dist/pages/
          run-id: ${{ needs.init.outputs.ci_run_id }}
          github-token: ${{ github.token }}

      - name: Verify staging pages attestation
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "Verifying pages artifact provenance..."
          SAMPLE=$(find dist/pages -type f -name "*.html" | head -5)
          FAILED=false
          for f in $SAMPLE; do
            gh attestation verify "$f" --repo "${{ github.repository }}" 2>/dev/null || {
              echo "::warning::No attestation for $f"
              FAILED=true
            }
          done
          if [[ "$FAILED" == "true" ]]; then
            echo "::warning::Pages artifacts lack attestation — expected during transition period"
          fi

      # Inject E2E videos from the same CI run that produced staging artifacts
      - name: Inject E2E videos
        env:
          GH_TOKEN: ${{ github.token }}
        run: >-
          .ci/scripts/docs/inject-e2e-videos.sh
          --run-id "${{ needs.init.outputs.ci_run_id }}"
          --artifact-name "e2e-videos-${{ needs.init.outputs.ci_sha }}"
          --output dist/pages/assets/videos/user-guide/

      - name: Rebuild package metadata from Release packages
        run: |
          VERSION="${{ needs.init.outputs.next_version }}"

          # Rebuild repos using the exact packages from GitHub Release
          # This ensures metadata checksums match the actual release assets
          .ci/scripts/build/build-pkg-repo.sh \
            --version "$VERSION" \
            --local-pkgs dist/release-pkgs \
            --output dist/pages \
            --max-versions 3
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}

      # -----------------------------------------------------------------------
      # Step 6: Deploy www Worker (static assets + embedded account server)
      # build-pages.sh already copies assets to workers/www/dist/
      # -----------------------------------------------------------------------
      - name: Copy pages to www worker assets
        run: |
          rm -rf workers/www/dist
          cp -r dist/pages workers/www/dist

      - name: Install www worker dependencies
        run: npm install
        working-directory: workers/www

      - name: Deploy www Worker
        run: .ci/scripts/deploy/deploy-www.sh
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ vars.CLOUDFLARE_ACCOUNT_ID }}

      - name: Set www Worker secrets
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ vars.CLOUDFLARE_ACCOUNT_ID }}
          SECRET_ED25519_PRIVATE_KEY: ${{ secrets.ACCOUNT_ED25519_PRIVATE_KEY }}
          SECRET_ED25519_PUBLIC_KEY: ${{ secrets.ACCOUNT_ED25519_PUBLIC_KEY }}
          SECRET_API_KEY: ${{ secrets.ACCOUNT_SERVER_API_KEY }}
          SECRET_STRIPE_KEY: ${{ secrets.STRIPE_SECRET_KEY }}
          SECRET_STRIPE_WEBHOOK: ${{ secrets.STRIPE_WEBHOOK_SECRET }}
          SECRET_S3_ENDPOINT: ${{ secrets.ACCOUNT_S3_ENDPOINT }}
          SECRET_S3_ACCESS_KEY_ID: ${{ secrets.ACCOUNT_S3_ACCESS_KEY_ID }}
          SECRET_S3_SECRET_ACCESS_KEY: ${{ secrets.ACCOUNT_S3_SECRET_ACCESS_KEY }}
        run: |
          echo "$SECRET_ED25519_PRIVATE_KEY" | npx wrangler secret put ED25519_PRIVATE_KEY --name rediacc-www
          echo "$SECRET_ED25519_PUBLIC_KEY" | npx wrangler secret put ED25519_PUBLIC_KEY --name rediacc-www
          echo "$SECRET_API_KEY" | npx wrangler secret put API_KEY --name rediacc-www
          echo "$SECRET_STRIPE_KEY" | npx wrangler secret put STRIPE_SECRET_KEY --name rediacc-www
          echo "$SECRET_STRIPE_WEBHOOK" | npx wrangler secret put STRIPE_WEBHOOK_SECRET --name rediacc-www
          echo "$SECRET_S3_ENDPOINT" | npx wrangler secret put S3_ENDPOINT --name rediacc-www
          echo "$SECRET_S3_ACCESS_KEY_ID" | npx wrangler secret put S3_ACCESS_KEY_ID --name rediacc-www
          echo "$SECRET_S3_SECRET_ACCESS_KEY" | npx wrangler secret put S3_SECRET_ACCESS_KEY --name rediacc-www

      # -----------------------------------------------------------------------
      # Step 7: Cleanup staging tags
      # -----------------------------------------------------------------------
      - name: Cleanup staging Docker tags
        run: |
          STAGING_TAG="${{ needs.init.outputs.staging_tag }}"
          echo "## Cleanup Staging Tags" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Cleanup is non-critical (staging tags are harmless if they remain),
          # so we log failures to the step summary but don't fail the job.
          if .ci/scripts/docker/cleanup-staging.sh --tag "$STAGING_TAG"; then
            echo "**Staging tag cleaned up:** $STAGING_TAG" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Failed to clean up staging tag:** $STAGING_TAG" >> $GITHUB_STEP_SUMMARY
            echo "Staging tag cleanup requires \`delete:packages\` scope (non-critical)." >> $GITHUB_STEP_SUMMARY
          fi
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}

      # -----------------------------------------------------------------------
      # Final summary
      # -----------------------------------------------------------------------
      - name: Deployment summary
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** v${{ needs.init.outputs.next_version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Release SHA:** ${{ steps.commit.outputs.release_sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**CI Run:** ${{ needs.init.outputs.ci_run_id }} (sha: ${{ needs.init.outputs.ci_sha }})" >> $GITHUB_STEP_SUMMARY
          echo "**Pages URL:** https://www.rediacc.com" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Docker images:**" >> $GITHUB_STEP_SUMMARY
          echo "- ghcr.io/rediacc/elite/api:${{ needs.init.outputs.next_version }} + :latest" >> $GITHUB_STEP_SUMMARY
          echo "- ghcr.io/rediacc/elite/bridge:${{ needs.init.outputs.next_version }} + :latest" >> $GITHUB_STEP_SUMMARY
          echo "- ghcr.io/rediacc/elite/plugin-terminal:${{ needs.init.outputs.next_version }} + :latest" >> $GITHUB_STEP_SUMMARY
          echo "- ghcr.io/rediacc/elite/plugin-browser:${{ needs.init.outputs.next_version }} + :latest" >> $GITHUB_STEP_SUMMARY
          echo "- ghcr.io/rediacc/elite/web:${{ needs.init.outputs.next_version }} + :latest" >> $GITHUB_STEP_SUMMARY
          echo "- ghcr.io/rediacc/elite/cli:${{ needs.init.outputs.next_version }} + :latest" >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # VALIDATE INSTALL METHODS - Test all documented installation methods
  # ============================================================================
  validate-install-methods:
    name: Validate Install Methods
    needs: [init, publish]
    if: >-
      success() &&
      needs.init.outputs.skip_release != 'true' &&
      !(github.event_name == 'workflow_dispatch' && inputs.dry_run)
    uses: ./.github/workflows/ct-install-methods.yml
    with:
      version: ${{ needs.init.outputs.next_version }}
    secrets:
      APP_PRIVATE_KEY: ${{ secrets.APP_PRIVATE_KEY }}

  # ============================================================================
  # CLEANUP ON FAILURE - Remove staging artifacts if publish fails
  # ============================================================================
  cleanup-on-failure:
    name: Cleanup (on failure)
    runs-on: ubuntu-latest
    needs: [init, publish]
    if: |
      always() &&
      needs.init.outputs.skip_release != 'true' &&
      !(github.event_name == 'workflow_dispatch' && inputs.dry_run) &&
      needs.publish.result == 'failure'
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6

      - uses: ./.github/actions/app-token
        id: app-token
        with:
          app-id: ${{ vars.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}
          preset: cd
          repositories: console

      - name: Login to GHCR
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9  # v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ github.token }}

      - name: Cleanup staging Docker tags
        run: |
          STAGING_TAG="${{ needs.init.outputs.staging_tag }}"
          echo "## Cleanup Staging Tags (Failure)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if .ci/scripts/docker/cleanup-staging.sh --tag "$STAGING_TAG"; then
            echo "**Staging tag cleaned up:** $STAGING_TAG" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Failed to clean up staging tag:** $STAGING_TAG" >> $GITHUB_STEP_SUMMARY
            echo "Staging tag cleanup requires \`delete:packages\` scope (non-critical)." >> $GITHUB_STEP_SUMMARY
          fi
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
