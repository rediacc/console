name: Console CD v2

# Simplified CD workflow with 2 main deployment jobs:
# 1. dry-run: Build and validate everything without publishing
# 2. publish: Actually publish (GitHub Release, GitHub Pages, Docker images)

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Run in dry-run mode (validate without publishing)'
        required: false
        type: boolean
        default: false

# Required for GitHub Pages deployment and Docker publishing
permissions:
  actions: write
  contents: write
  pages: write
  id-token: write
  packages: write  # For GHCR push

# Queue new releases instead of cancelling in-progress ones
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  # ============================================================================
  # INITIALIZE
  # ============================================================================
  init:
    name: Initialize
    runs-on: ubuntu-latest
    if: github.actor != 'github-actions[bot]' && github.actor != 'dependabot[bot]' && !contains(github.event.head_commit.message, '[skip ci]')
    outputs:
      is_bot: ${{ steps.init.outputs.is_bot }}
      next_version: ${{ steps.init.outputs.next_version }}
      staging_tag: ${{ steps.staging.outputs.staging_tag }}
      api_tag: ${{ steps.init.outputs.api_tag }}
      api_exists: ${{ steps.init.outputs.api_exists }}
      bridge_tag: ${{ steps.init.outputs.bridge_tag }}
      bridge_exists: ${{ steps.init.outputs.bridge_exists }}
      plugins_tag: ${{ steps.init.outputs.plugins_tag }}
      plugins_exists: ${{ steps.init.outputs.plugins_exists }}
      web_tag: ${{ steps.init.outputs.web_tag }}
      web_exists: ${{ steps.init.outputs.web_exists }}
      cli_tag: ${{ steps.init.outputs.cli_tag }}
      cli_exists: ${{ steps.init.outputs.cli_exists }}
      image_tag: ${{ steps.init.outputs.image_tag }}
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GH_PAT }}

      - name: Initialize CI
        id: init
        env:
          GITHUB_PAT: ${{ secrets.GH_PAT }}
          GITHUB_EVENT_NAME: ${{ github.event_name }}
          GITHUB_ACTOR: ${{ github.actor }}
          COMMIT_AUTHOR: ${{ github.event.head_commit.author.name }}
        run: |
          .ci/scripts/ci/initialize.sh --output "$GITHUB_OUTPUT"

      - name: Generate staging tag
        id: staging
        run: |
          if [[ "${{ inputs.dry_run }}" == "true" ]]; then
            echo "staging_tag=dryrun-${{ github.sha }}" >> $GITHUB_OUTPUT
          else
            echo "staging_tag=staging-${{ github.sha }}" >> $GITHUB_OUTPUT
          fi

  # ============================================================================
  # BUILD (parallel reusable workflows)
  # ============================================================================
  build-docker:
    name: Build (Docker)
    needs: [init]
    uses: ./.github/workflows/ci-build-docker.yml
    with:
      next_version: ${{ needs.init.outputs.next_version }}
      api_tag: ${{ needs.init.outputs.api_tag }}
      api_exists: ${{ needs.init.outputs.api_exists }}
      bridge_tag: ${{ needs.init.outputs.bridge_tag }}
      bridge_exists: ${{ needs.init.outputs.bridge_exists }}
      plugins_tag: ${{ needs.init.outputs.plugins_tag }}
      plugins_exists: ${{ needs.init.outputs.plugins_exists }}
      web_tag: ${{ needs.init.outputs.web_tag }}
      web_exists: ${{ needs.init.outputs.web_exists }}
      cli_tag: ${{ needs.init.outputs.cli_tag }}
      cli_exists: ${{ needs.init.outputs.cli_exists }}
    secrets: inherit

  build-desktop:
    name: Build (Desktop)
    needs: [init]
    uses: ./.github/workflows/ci-build-desktop.yml
    with:
      next_version: ${{ needs.init.outputs.next_version }}
    secrets: inherit

  build-cli:
    name: Build (CLI)
    needs: [init]
    uses: ./.github/workflows/ci-build-cli.yml
    with:
      next_version: ${{ needs.init.outputs.next_version }}
    secrets: inherit

  # ============================================================================
  # JOB 1: DRY-RUN (Reusable Workflow)
  # Build and validate everything without publishing
  # Uses shared cd-dryrun.yml workflow (same as CI uses)
  # ============================================================================
  dry-run:
    name: Dry-Run
    needs: [init, build-docker, build-desktop, build-cli]
    uses: ./.github/workflows/cd-dryrun.yml
    with:
      dry_run: ${{ inputs.dry_run || false }}
      next_version: ${{ needs.init.outputs.next_version }}
      staging_tag: ${{ needs.init.outputs.staging_tag }}
      api_tag: ${{ needs.init.outputs.api_tag }}
      bridge_tag: ${{ needs.init.outputs.bridge_tag }}
      plugins_tag: ${{ needs.init.outputs.plugins_tag }}
      web_tag: ${{ needs.init.outputs.web_tag }}
      cli_tag: ${{ needs.init.outputs.cli_tag }}
    secrets: inherit

  # ============================================================================
  # RERUN WATCHDOG - Auto-retry flaky build/dry-run jobs (max 3 attempts)
  # Only monitors Build and Dry-Run jobs. Publish is NOT retried (not idempotent).
  # ============================================================================
  rerun-watchdog:
    name: Rerun Watchdog
    runs-on: ubuntu-latest
    needs: [init]
    if: always() && needs.init.result == 'success' && fromJSON(github.run_attempt) < 3
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6

      - name: Wait for build/dry-run jobs and trigger rerun on failures
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          .ci/scripts/ci/rerun-watchdog.sh \
            --timeout 120 \
            --monitor "Build (*" \
            --monitor "Dry-Run"

  # ============================================================================
  # JOB 2: PUBLISH
  # Actually publish to GitHub Release, Docker, Pages
  # Only runs if dry-run succeeds AND not in dry_run mode
  # ============================================================================
  publish:
    name: Publish
    runs-on: ubuntu-latest
    needs: [init, dry-run]
    if: success() && !inputs.dry_run
    environment:
      name: github-pages
      url: ${{ steps.pages-deploy.outputs.page_url }}
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6
        with:
          fetch-depth: 0
          submodules: true
          token: ${{ secrets.GH_PAT || github.token }}
      - uses: actions/setup-node@395ad3262231945c25e8478fd5baf05154b1d79f  # v6
        with:
          node-version: '22'

      # -----------------------------------------------------------------------
      # Step 1: Promote Docker images (staging -> version + latest)
      # -----------------------------------------------------------------------
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GH_PAT }}

      - name: Promote Docker images
        run: |
          STAGING_TAG="${{ needs.init.outputs.staging_tag }}"
          VERSION="${{ needs.init.outputs.next_version }}"

          .ci/scripts/docker/retag-image.sh --image api --from "$STAGING_TAG" --to "$VERSION" --push-latest --skip-if-exists
          .ci/scripts/docker/retag-image.sh --image bridge --from "$STAGING_TAG" --to "$VERSION" --push-latest --skip-if-exists
          .ci/scripts/docker/retag-image.sh --image plugin-terminal --from "$STAGING_TAG" --to "$VERSION" --push-latest --skip-if-exists
          .ci/scripts/docker/retag-image.sh --image plugin-browser --from "$STAGING_TAG" --to "$VERSION" --push-latest --skip-if-exists
          .ci/scripts/docker/retag-image.sh --image web --from "$STAGING_TAG" --to "$VERSION" --push-latest --skip-if-exists
          .ci/scripts/docker/retag-image.sh --image cli --from "$STAGING_TAG" --to "$VERSION" --push-latest --skip-if-exists

      # -----------------------------------------------------------------------
      # Step 2: Bump version & commit
      # -----------------------------------------------------------------------
      - name: Version bump
        run: .ci/scripts/version/bump.sh --version ${{ needs.init.outputs.next_version }}

      - name: Bump submodule versions
        run: |
          .ci/scripts/version/bump-submodules.sh --version ${{ needs.init.outputs.next_version }} --stage-only
        env:
          GITHUB_PAT: ${{ secrets.GH_PAT }}

      - name: Version commit
        id: commit
        run: |
          .ci/scripts/version/commit.sh --version ${{ needs.init.outputs.next_version }} --push --include-submodules
          echo "release_sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
        env:
          GITHUB_HEAD_REF: main

      # -----------------------------------------------------------------------
      # Step 3: Create GitHub Release (upload packages + binaries)
      # -----------------------------------------------------------------------
      - name: Download staging release artifact
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131  # v7
        with:
          name: staging-release-${{ github.sha }}
          path: dist/

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.init.outputs.next_version }}
          name: v${{ needs.init.outputs.next_version }}
          target_commitish: ${{ steps.commit.outputs.release_sha }}
          files: |
            dist/desktop/**/*
            dist/cli/**/*
            dist/packages/**/*
          draft: false
          prerelease: false
          generate_release_notes: true

      # -----------------------------------------------------------------------
      # Step 3.5: Update Homebrew formula
      # -----------------------------------------------------------------------
      - name: Update Homebrew formula
        run: |
          .ci/scripts/release/update-homebrew-tap.sh \
            --version ${{ needs.init.outputs.next_version }} \
            --push
        env:
          GITHUB_PAT: ${{ secrets.GH_PAT }}
          GH_TOKEN: ${{ secrets.GH_PAT }}

      # -----------------------------------------------------------------------
      # Step 4: Download packages from Release for metadata (ensures exact match)
      # -----------------------------------------------------------------------
      - name: Download packages from Release
        run: |
          VERSION="${{ needs.init.outputs.next_version }}"
          mkdir -p dist/release-pkgs

          echo "Downloading packages from GitHub Release v$VERSION..."
          gh release download "v$VERSION" --pattern "*.deb" --pattern "*.rpm" --dir dist/release-pkgs --clobber || true

          # Filter to only CLI packages (exclude desktop packages)
          find dist/release-pkgs -name "rediacc-desktop-*" -delete 2>/dev/null || true

          echo "Downloaded packages:"
          ls -la dist/release-pkgs/
        env:
          GH_TOKEN: ${{ secrets.GH_PAT || github.token }}

      # -----------------------------------------------------------------------
      # Step 5: Build final APT/RPM repo metadata (matching Release)
      # -----------------------------------------------------------------------
      - name: Install repo build tools
        run: sudo apt-get update -qq && sudo apt-get install -y -qq dpkg-dev createrepo-c rpm gnupg

      - name: Download staging pages artifact
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131  # v7
        with:
          name: staging-pages-${{ github.sha }}
          path: dist/pages/

      - name: Rebuild package metadata from Release packages
        run: |
          VERSION="${{ needs.init.outputs.next_version }}"

          # Rebuild repos using the exact packages from GitHub Release
          # This ensures metadata checksums match the actual release assets
          .ci/scripts/build/build-pkg-repo.sh \
            --version "$VERSION" \
            --local-pkgs dist/release-pkgs \
            --output dist/pages \
            --max-versions 3
        env:
          GH_TOKEN: ${{ secrets.GH_PAT || github.token }}
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}

      # -----------------------------------------------------------------------
      # Step 6: Deploy GitHub Pages
      # -----------------------------------------------------------------------
      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@7b1f4a764d45c48632c6b24a0339c27f5614fb0b  # v4
        with:
          path: dist/pages/

      - name: Deploy to GitHub Pages
        id: pages-deploy
        uses: actions/deploy-pages@d6db90164ac5ed86f2b6aed7e0febac5b3c0c03e  # v4

      # -----------------------------------------------------------------------
      # Step 7: Cleanup staging tags
      # -----------------------------------------------------------------------
      - name: Cleanup staging Docker tags
        run: |
          STAGING_TAG="${{ needs.init.outputs.staging_tag }}"
          echo "## Cleanup Staging Tags" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Staging tag cleaned up:** $STAGING_TAG" >> $GITHUB_STEP_SUMMARY

          .ci/scripts/docker/cleanup-staging.sh --tag "$STAGING_TAG"
        env:
          GH_TOKEN: ${{ secrets.GH_PAT || github.token }}

      # -----------------------------------------------------------------------
      # Final summary
      # -----------------------------------------------------------------------
      - name: Deployment summary
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** v${{ needs.init.outputs.next_version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Release SHA:** ${{ steps.commit.outputs.release_sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Pages URL:** ${{ steps.pages-deploy.outputs.page_url }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Docker images:**" >> $GITHUB_STEP_SUMMARY
          echo "- ghcr.io/rediacc/elite/api:${{ needs.init.outputs.next_version }} + :latest" >> $GITHUB_STEP_SUMMARY
          echo "- ghcr.io/rediacc/elite/bridge:${{ needs.init.outputs.next_version }} + :latest" >> $GITHUB_STEP_SUMMARY
          echo "- ghcr.io/rediacc/elite/plugin-terminal:${{ needs.init.outputs.next_version }} + :latest" >> $GITHUB_STEP_SUMMARY
          echo "- ghcr.io/rediacc/elite/plugin-browser:${{ needs.init.outputs.next_version }} + :latest" >> $GITHUB_STEP_SUMMARY
          echo "- ghcr.io/rediacc/elite/web:${{ needs.init.outputs.next_version }} + :latest" >> $GITHUB_STEP_SUMMARY
          echo "- ghcr.io/rediacc/elite/cli:${{ needs.init.outputs.next_version }} + :latest" >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # VALIDATE INSTALL METHODS - Test all documented installation methods
  # ============================================================================
  validate-install-methods:
    name: Validate Install Methods
    needs: [init, publish]
    if: success() && !inputs.dry_run
    uses: ./.github/workflows/ct-install-methods.yml
    with:
      version: ${{ needs.init.outputs.next_version }}
    secrets: inherit

  # ============================================================================
  # CLEANUP ON FAILURE - Remove staging artifacts if dry-run or publish fails
  # ============================================================================
  cleanup-on-failure:
    name: Cleanup (on failure)
    runs-on: ubuntu-latest
    needs: [init, dry-run, publish]
    if: |
      always() &&
      !inputs.dry_run &&
      (needs.dry-run.result == 'failure' || needs.publish.result == 'failure')
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GH_PAT }}

      - name: Cleanup staging Docker tags
        run: |
          STAGING_TAG="${{ needs.init.outputs.staging_tag }}"
          echo "## Cleanup Staging Tags (Failure)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Staging tag to cleanup:** $STAGING_TAG" >> $GITHUB_STEP_SUMMARY

          .ci/scripts/docker/cleanup-staging.sh --tag "$STAGING_TAG"
        env:
          GH_TOKEN: ${{ secrets.GH_PAT || github.token }}
