name: Console CT - Tests

on:
  workflow_call:
    inputs:
      api_tag:
        required: true
        type: string
      bridge_tag:
        required: true
        type: string
      web_tag:
        required: true
        type: string
      e2e_browsers:
        required: true
        type: string
      provision_vms:
        required: false
        type: boolean
        default: false
    secrets:
      GH_PAT:
        required: false
      DOCKERHUB_USERNAME:
        required: false
      DOCKERHUB_TOKEN:
        required: false

env:
  E2E_BROWSERS: ${{ inputs.e2e_browsers }}

jobs:
  # ============================================================================
  # BUILD VM DISK IMAGE: Pre-build VM image with renet setup
  # Builds a custom VM image with Docker, CRIU, and packages pre-installed.
  # This reduces disk space usage in infra-backend by avoiding on-the-fly builds.
  # ============================================================================
  build-disk-image:
    name: Build VM Disk Image
    runs-on: ubuntu-latest
    if: inputs.provision_vms
    timeout-minutes: 30
    outputs:
      image-name: ${{ steps.build.outputs.image-name }}
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6
        with:
          sparse-checkout: .ci/scripts

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GH_PAT }}

      - name: Extract renet binary
        run: .ci/scripts/infra/extract-renet-binary.sh --image "ghcr.io/rediacc/elite/bridge:${{ inputs.bridge_tag }}"
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT }}
          GITHUB_ACTOR: ${{ github.actor }}

      - name: Setup KVM Host
        run: sudo /tmp/renet ops host setup

      - name: Build VM Image
        id: build
        run: |
          .ci/scripts/image/build-vm-image.sh --output "$RUNNER_TEMP/vm-image"
          IMAGE_PATH=$(ls $RUNNER_TEMP/vm-image/*.img | head -1)
          IMAGE_NAME=$(basename "$IMAGE_PATH")
          echo "image-name=$IMAGE_NAME" >> $GITHUB_OUTPUT
          echo "Built image: $IMAGE_NAME ($(du -h "$IMAGE_PATH" | cut -f1))"

      - name: Upload VM Image Artifact
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6
        with:
          name: vm-disk-image
          path: ${{ runner.temp }}/vm-image/*.img
          retention-days: 1
          compression-level: 0  # Already compressed qcow2

  # ============================================================================
  # GATEWAY JOB: Wait for tunnel-url artifact
  # Lightweight job that waits for infra-backend to upload the tunnel URL.
  # Test jobs depend on this instead of polling independently, saving runner minutes.
  # NOTE: No 'needs: [infra-backend]' - allows infra-backend to continue in background.
  # ============================================================================
  wait-for-tunnel:
    name: Wait for Tunnel
    needs: [build-disk-image]
    if: always() && (needs.build-disk-image.result == 'success' || needs.build-disk-image.result == 'skipped')
    runs-on: ubuntu-slim
    timeout-minutes: 25
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6
        with:
          sparse-checkout: .ci/scripts
      - name: Wait for tunnel-url artifact
        env:
          GH_TOKEN: ${{ github.token }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: .ci/scripts/tunnel/wait-for-artifact.sh --run-id ${{ github.run_id }}

  infra-backend:
    name: Infra - Backend
    needs: [build-disk-image]
    # Run if: (a) build succeeded when provision_vms=true, or (b) provision_vms=false (skipped build)
    if: always() && (needs.build-disk-image.result == 'success' || needs.build-disk-image.result == 'skipped')
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      CI: 'true'
      BRIDGE_TIMEOUT: 120000
      RENET_DOCKER_IMAGE: ghcr.io/rediacc/elite/bridge:${{ inputs.bridge_tag }}
      DOCKER_REGISTRY: ghcr.io/rediacc/elite
      # Per-image tags for backend services
      API_TAG: ${{ inputs.api_tag }}
      BRIDGE_TAG: ${{ inputs.bridge_tag }}
      WEB_TAG: ${{ inputs.web_tag }}
    steps:
      - name: Checkout Console Repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6
        with:
          submodules: true
          token: ${{ secrets.GH_PAT }}

      - name: Pull Backend Docker Images
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT }}
          GITHUB_ACTOR: ${{ github.actor }}
        run: .ci/scripts/infra/ci-pull-images.sh

      - name: Install sqlcmd (go-sqlcmd)
        run: sudo private/middleware/scripts/install-sqlcmd.sh

      - name: Start Backend Services
        uses: ./.github/actions/start-backend
        with:
          keep-alive: 'true'
          ci-mode: 'true'

      - name: Wait for Services
        run: .ci/scripts/infra/wait-for-health.sh --url http://localhost/health --timeout 120 --message "Backend services are ready"

      - name: Create Cloudflare Tunnel
        id: tunnel
        uses: rediacc/action-cloudflare-tunnel@v1
        with:
          url: http://localhost
          timeout: 60

      - name: Verify Cloudflare Tunnel
        run: |
          TUNNEL_URL="${{ steps.tunnel.outputs.tunnel-url }}"
          for i in {1..20}; do
            if curl -sf "$TUNNEL_URL/health"; then
              echo "Cloudflare tunnel verified"
              exit 0
            fi
            sleep 3
          done
          exit 1

      - name: Start Pinggy Tunnel
        id: pinggy-tunnel
        run: |
          PINGGY_URL=$(.ci/scripts/tunnel/start-pinggy.sh --port 80 --timeout 60) || true
          echo "tunnel-url=${PINGGY_URL}" >> $GITHUB_OUTPUT
          if [[ -n "${PINGGY_URL}" ]]; then
            echo "Pinggy tunnel: $PINGGY_URL"
          else
            echo "Pinggy tunnel failed to start (non-fatal)"
          fi

      - name: Verify Pinggy Tunnel
        if: steps.pinggy-tunnel.outputs.tunnel-url != ''
        run: |
          VERIFIED=false
          for i in {1..5}; do
            if curl -sf --max-time 10 "${{ steps.pinggy-tunnel.outputs.tunnel-url }}/health"; then
              echo "Pinggy tunnel verified"
              VERIFIED=true
              break
            fi
            sleep 3
          done
          if [[ "$VERIFIED" != "true" ]]; then
            echo "Pinggy tunnel verification failed (non-fatal)"
          fi

      # Upload tunnel URLs immediately after verification (before CLI build / VM provisioning)
      # so test jobs can start as soon as possible and artifacts survive cancellations.
      - name: Upload Cloudflare Tunnel URL
        run: echo "${{ steps.tunnel.outputs.tunnel-url }}" > ${{ runner.temp }}/tunnel-url.txt
      - uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6
        with:
          name: tunnel-url
          path: ${{ runner.temp }}/tunnel-url.txt
          retention-days: 3

      - name: Upload Pinggy Tunnel URL
        if: steps.pinggy-tunnel.outputs.tunnel-url != ''
        run: |
          mkdir -p ${{ runner.temp }}/pinggy-artifact
          echo "${{ steps.pinggy-tunnel.outputs.tunnel-url }}" > ${{ runner.temp }}/pinggy-artifact/tunnel-url.txt
      - uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6
        if: steps.pinggy-tunnel.outputs.tunnel-url != ''
        with:
          name: tunnel-url-pinggy
          path: ${{ runner.temp }}/pinggy-artifact/tunnel-url.txt
          retention-days: 3

      # Bridge tests
      - uses: actions/setup-node@395ad3262231945c25e8478fd5baf05154b1d79f  # v6
        with:
          node-version: '22'
          cache: 'npm'

      - name: Build CLI
        run: |
          npm ci
          npm run build:packages
          npm run build:cli
          npm run build:bundle -w @rediacc/cli

      - name: Install CLI Globally
        run: .ci/scripts/setup/install-cli-global.sh

      # Login to Docker Hub to avoid rate limiting
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Pre-pull Bridge Image
        run: .ci/scripts/infra/docker-pull-ghcr.sh --image "$RENET_DOCKER_IMAGE" --quiet
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT }}
          GITHUB_ACTOR: ${{ github.actor }}

      # VM Provisioning (conditional - only when provision_vms is true)
      # Download pre-built VM image (built in build-disk-image job)
      - name: Download VM Image Artifact
        if: inputs.provision_vms
        uses: actions/download-artifact@v4
        with:
          name: vm-disk-image
          path: ${{ runner.temp }}/vm-image

      - name: Provision VMs
        id: vms
        if: inputs.provision_vms
        uses: ./.github/actions/provision-vms
        with:
          bridge-tag: ${{ inputs.bridge_tag }}
          vm-image-path: ${{ runner.temp }}/vm-image
          bridge-env-output: ${{ runner.temp }}/bridge.env

      # Free disk space before long-running signal wait
      # Docker images, build cache, and npm cache consume most space
      - name: Free Disk Space
        run: |
          echo "=== Disk usage before cleanup ==="
          df -h / || true
          # Remove Docker build cache and dangling images (keep running containers)
          docker system prune -f 2>/dev/null || true
          # Clear npm cache (builds are complete)
          npm cache clean --force 2>/dev/null || true
          # Remove extracted renet binary (VM provisioning is done)
          rm -f /tmp/renet 2>/dev/null || true
          echo "=== Disk usage after cleanup ==="
          df -h / || true

      - name: Wait for Completion Signals
        run: .ci/scripts/infra/wait-for-signals.sh --timeout 7200
        env:
          GH_TOKEN: ${{ github.token }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_RUN_ID: ${{ github.run_id }}
          E2E_BROWSERS: ${{ env.E2E_BROWSERS }}

      - name: Collect Backend Logs
        if: always()
        run: .ci/scripts/infra/collect-backend-logs.sh ${{ runner.temp }}/backend-logs

      - name: Upload Backend Logs
        if: always()
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6
        with:
          name: infra-backend-logs-${{ github.sha }}
          path: ${{ runner.temp }}/backend-logs/
          retention-days: 3

      - name: Cleanup
        if: always()
        run: |
          # Stop VMs
          sudo /tmp/renet ops down || true
          # Stop backend services
          cd .ci/docker/ci && docker compose down --volumes --remove-orphans || true
          rm -rf mssql || true

  # ============================================================================
  # COLUMN 4: TESTS + INFRA
  # Jobs: test-unit, test-vscode, test-cli, test-e2e, test-e2e-electron,
  #       test-bridge-workers, test-bridge-ceph, test-renet, infra-backend
  # Dependencies: All build jobs (runs in parallel with infra-backend)
  # Note: Tests that need the backend tunnel URL will download the artifact
  #       uploaded by infra-backend early in its execution
  # ============================================================================
  test-unit:
    name: Unit
    runs-on: ubuntu-slim
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6
      - uses: actions/setup-node@395ad3262231945c25e8478fd5baf05154b1d79f  # v6
        with:
          node-version: '22'
          cache: 'npm'
      - run: .ci/scripts/setup/install-deps.sh
      - run: .ci/scripts/setup/build-packages.sh
      - run: .ci/scripts/test/run-unit.sh --coverage
      - uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6
        if: always()
        with:
          name: test-unit-coverage-${{ github.sha }}
          path: packages/web/coverage/
          retention-days: 3

  test-vscode:
    name: VSCode (${{ matrix.os }})
    timeout-minutes: 15
    strategy:
      fail-fast: true
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6
      - uses: actions/setup-node@395ad3262231945c25e8478fd5baf05154b1d79f  # v6
        with:
          node-version: '22'
          cache: 'npm'
      - run: .ci/scripts/setup/install-deps.sh ${{ runner.os == 'Windows' && '--ignore-scripts' || '' }}
        shell: bash
      - run: .ci/scripts/setup/build-packages.sh
        shell: bash
      - run: .ci/scripts/build/build-cli.sh
        shell: bash
      - run: .ci/scripts/env/create-cli-env.sh --minimal --output packages/cli/tests/.env
        shell: bash
      - name: Run VS Code detection tests
        working-directory: packages/cli
        run: npx playwright test --config tests/playwright.config.ts tests/tests/09-vscode/detection.test.ts
        env:
          PLAYWRIGHT_SKIP_GLOBAL_SETUP: 'true'
      - uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6
        if: failure()
        with:
          name: test-vscode-${{ matrix.os }}-${{ github.sha }}
          path: packages/cli/tests/test-results/
          retention-days: 3
          if-no-files-found: ignore

  test-cli:
    name: CLI (${{ matrix.platform }})
    needs: [wait-for-tunnel]
    runs-on: ${{ matrix.os }}
    timeout-minutes: 120
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            platform: Linux
          - os: windows-latest
            platform: Windows
          - os: macos-latest
            platform: macOS
    env:
      REDIACC_TEST_EMAIL: admin@rediacc.io
      REDIACC_TEST_PASSWORD: admin
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6
      - uses: actions/setup-node@395ad3262231945c25e8478fd5baf05154b1d79f  # v6
        with:
          node-version: '22'
          cache: 'npm'
      - run: .ci/scripts/setup/install-deps.sh ${{ runner.os == 'Windows' && '--ignore-scripts' || '' }}
        shell: bash
      - run: .ci/scripts/setup/build-packages.sh
        shell: bash
      - run: .ci/scripts/build/build-cli.sh
        shell: bash
      - name: Download Cloudflare Tunnel URL
        id: cf-tunnel
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          TUNNEL_URL=$(.ci/scripts/tunnel/download-url.sh --run-id ${{ github.run_id }} --artifact-name tunnel-url) || true
          echo "tunnel-url=${TUNNEL_URL}" >> $GITHUB_OUTPUT
      - name: Download Pinggy Tunnel URL
        id: pinggy-tunnel
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          TUNNEL_URL=$(.ci/scripts/tunnel/download-url.sh --run-id ${{ github.run_id }} --artifact-name tunnel-url-pinggy) || true
          echo "tunnel-url=${TUNNEL_URL}" >> $GITHUB_OUTPUT
      - name: Select Working Tunnel
        id: tunnel
        shell: bash
        run: |
          TUNNEL_URL=$(.ci/scripts/tunnel/select-tunnel.sh \
            --url "${{ steps.cf-tunnel.outputs.tunnel-url }}" \
            --url "${{ steps.pinggy-tunnel.outputs.tunnel-url }}")
          echo "tunnel-url=$TUNNEL_URL" >> $GITHUB_OUTPUT
      - run: .ci/scripts/env/create-cli-env.sh --api-url "${{ steps.tunnel.outputs.tunnel-url }}/api" --email ${{ env.REDIACC_TEST_EMAIL }} --password ${{ env.REDIACC_TEST_PASSWORD }} --output packages/cli/tests/.env
        shell: bash
      - run: .ci/scripts/setup/install-vscode.sh
        shell: bash
      - run: .ci/scripts/test/run-cli.sh
        shell: bash
      - if: always()
        run: .ci/scripts/signal/create-complete.sh --name "cli-${{ matrix.platform }}" --status ${{ job.status }}
        shell: bash
      - uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6
        if: always()
        with:
          name: test-complete-cli-${{ matrix.platform }}
          path: ${{ runner.temp }}/complete.txt
          retention-days: 3
          overwrite: true
      - uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6
        if: always()
        with:
          name: test-cli-report-${{ matrix.platform }}-${{ github.sha }}
          path: packages/cli/tests/reports/cli/
          retention-days: 3

  test-e2e:
    name: E2E
    needs: [wait-for-tunnel]
    runs-on: ubuntu-latest
    timeout-minutes: 60
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6
      - uses: actions/setup-node@395ad3262231945c25e8478fd5baf05154b1d79f  # v6
        with:
          node-version: '22'
          cache: 'npm'
      - run: .ci/scripts/setup/install-deps.sh
      - run: .ci/scripts/setup/build-packages.sh
      - name: Install Playwright Browsers
        run: .ci/scripts/setup/install-playwright.sh --browsers "chromium webkit ${{ env.E2E_BROWSERS }}"
      - name: Download Cloudflare Tunnel URL
        id: cf-tunnel
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          TUNNEL_URL=$(.ci/scripts/tunnel/download-url.sh --run-id ${{ github.run_id }} --artifact-name tunnel-url) || true
          echo "tunnel-url=${TUNNEL_URL}" >> $GITHUB_OUTPUT
      - name: Download Pinggy Tunnel URL
        id: pinggy-tunnel
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          TUNNEL_URL=$(.ci/scripts/tunnel/download-url.sh --run-id ${{ github.run_id }} --artifact-name tunnel-url-pinggy) || true
          echo "tunnel-url=${TUNNEL_URL}" >> $GITHUB_OUTPUT
      - name: Select Working Tunnel
        id: tunnel
        run: |
          TUNNEL_URL=$(.ci/scripts/tunnel/select-tunnel.sh \
            --url "${{ steps.cf-tunnel.outputs.tunnel-url }}" \
            --url "${{ steps.pinggy-tunnel.outputs.tunnel-url }}")
          echo "tunnel-url=$TUNNEL_URL" >> $GITHUB_OUTPUT
      - run: .ci/scripts/env/create-e2e-env.sh --api-url ${{ steps.tunnel.outputs.tunnel-url }} --output packages/e2e/.env
      - name: Run E2E Tests - Browser Only
        run: |
          .ci/scripts/test/run-e2e.sh --projects \
            ${{ env.E2E_BROWSERS }}
      - name: Create Completion Signal
        if: always()
        run: .ci/scripts/signal/create-complete.sh --name "e2e-chromium" --status ${{ job.status }}
      - uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6
        if: always()
        with:
          name: test-complete-e2e-chromium
          path: ${{ runner.temp }}/complete.txt
          retention-days: 3
          overwrite: true
      - uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6
        if: always()
        with:
          name: test-e2e-report-${{ github.sha }}
          path: packages/e2e/reports/e2e/
          retention-days: 3
          if-no-files-found: ignore

  test-e2e-electron:
    name: E2E Electron (${{ matrix.project }})
    needs: [wait-for-tunnel]
    runs-on: ${{ matrix.os }}
    timeout-minutes: 60
    strategy:
      fail-fast: true
      matrix:
        include:
          - os: ubuntu-latest
            project: electron-linux-x64
            install: npx playwright install --with-deps chromium
          - os: ubuntu-24.04-arm
            project: electron-linux-arm64
            install: npx playwright install --with-deps chromium
          - os: macos-15-intel
            project: electron-macos-x64
            install: npx playwright install chromium
          - os: macos-latest
            project: electron-macos-arm64
            install: npx playwright install chromium
          - os: windows-latest
            project: electron-windows-x64
            install: npx playwright install chromium
          - os: windows-11-arm
            project: electron-windows-arm64
            install: npx playwright install chromium
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6
      - uses: actions/setup-node@395ad3262231945c25e8478fd5baf05154b1d79f  # v6
        with:
          node-version: '22'
          cache: 'npm'
      - run: .ci/scripts/setup/install-deps.sh ${{ runner.os == 'Windows' && '--ignore-scripts' || '' }}
        shell: bash
      - run: .ci/scripts/setup/build-packages.sh
        shell: bash
      - if: runner.os == 'Windows'
        name: Install Electron binary
        working-directory: packages/desktop
        shell: bash
        run: |
          echo "Installing Electron binary (skipped during --ignore-scripts)..."
          npm rebuild electron
      - name: Build desktop
        working-directory: packages/desktop
        run: npm run build
      - name: Install Playwright
        working-directory: packages/e2e
        run: ${{ matrix.install }}
      - if: runner.os == 'Linux'
        run: .ci/scripts/setup/setup-display.sh
      - name: Download Cloudflare Tunnel URL
        id: cf-tunnel
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          TUNNEL_URL=$(.ci/scripts/tunnel/download-url.sh --run-id ${{ github.run_id }} --artifact-name tunnel-url) || true
          echo "tunnel-url=${TUNNEL_URL}" >> $GITHUB_OUTPUT
      - name: Download Pinggy Tunnel URL
        id: pinggy-tunnel
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          TUNNEL_URL=$(.ci/scripts/tunnel/download-url.sh --run-id ${{ github.run_id }} --artifact-name tunnel-url-pinggy) || true
          echo "tunnel-url=${TUNNEL_URL}" >> $GITHUB_OUTPUT
      - name: Select Working Tunnel
        id: tunnel
        shell: bash
        run: |
          TUNNEL_URL=$(.ci/scripts/tunnel/select-tunnel.sh \
            --url "${{ steps.cf-tunnel.outputs.tunnel-url }}" \
            --url "${{ steps.pinggy-tunnel.outputs.tunnel-url }}")
          echo "tunnel-url=$TUNNEL_URL" >> $GITHUB_OUTPUT
      - run: .ci/scripts/env/create-e2e-env.sh --api-url ${{ steps.tunnel.outputs.tunnel-url }} --output packages/e2e/.env
        shell: bash
      - name: Run Electron E2E Tests
        working-directory: packages/e2e
        run: npx playwright test --project=${{ matrix.project }}
        env:
          DISPLAY: ${{ env.DISPLAY }}
      - if: always()
        run: .ci/scripts/signal/create-complete.sh --name "e2e-${{ matrix.project }}" --status ${{ job.status }}
        shell: bash
      - uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6
        if: always()
        with:
          name: test-complete-e2e-${{ matrix.project }}
          path: ${{ runner.temp }}/complete.txt
          retention-days: 3
          overwrite: true

  test-bridge-workers:
    name: Bridge Workers (${{ matrix.os-image }})
    runs-on: ubuntu-latest
    timeout-minutes: 45
    strategy:
      fail-fast: false
      matrix:
        os-image:
          - ubuntu-24.04
          - debian-12
          - fedora-43
          - opensuse-15.6
    env:
      CI: 'true'
      BRIDGE_TIMEOUT: 120000
      RENET_DOCKER_IMAGE: ghcr.io/rediacc/elite/bridge:${{ inputs.bridge_tag }}
      VM_BRIDGE: '1'
      VM_WORKERS: '11 12'
      VM_CEPH_NODES: ''
      VM_IMAGE: ${{ matrix.os-image }}
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6
      - uses: actions/setup-node@395ad3262231945c25e8478fd5baf05154b1d79f  # v6
        with:
          node-version: '22'
          cache: 'npm'
      - run: .ci/scripts/setup/install-deps.sh
      - run: .ci/scripts/setup/build-packages.sh
      - run: .ci/scripts/build/build-cli.sh
      - name: Install CLI Globally
        run: .ci/scripts/setup/install-cli-global.sh

      - name: Pull Renet Docker Image
        run: .ci/scripts/infra/docker-pull-ghcr.sh --image "$RENET_DOCKER_IMAGE" --quiet
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT }}
          GITHUB_ACTOR: ${{ github.actor }}

      - name: Extract renet binary
        run: .ci/scripts/infra/extract-renet-binary.sh --image "$RENET_DOCKER_IMAGE"

      - name: Setup KVM Host
        run: sudo /tmp/renet ops host setup

      - name: Create Bridge Test Environment
        run: .ci/scripts/env/create-bridge-env.sh --output packages/bridge-tests/.env

      - name: Run Bridge Tests (Workers)
        run: .ci/scripts/test/run-bridge.sh --workers 1

      - if: always()
        run: .ci/scripts/signal/create-complete.sh --name "bridge-workers-${{ matrix.os-image }}" --status ${{ job.status }}

      - uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6
        if: always()
        with:
          name: test-bridge-workers-${{ matrix.os-image }}-${{ github.sha }}
          path: |
            ${{ runner.temp }}/complete.txt
            packages/bridge-tests/reports/bridge/
            packages/bridge-tests/reports/bridge-logs/
          retention-days: 3
          if-no-files-found: ignore

  test-bridge-ceph:
    name: Bridge Ceph
    runs-on: ubuntu-latest
    timeout-minutes: 45
    env:
      CI: 'true'
      BRIDGE_TIMEOUT: 120000
      RENET_DOCKER_IMAGE: ghcr.io/rediacc/elite/bridge:${{ inputs.bridge_tag }}
      VM_BRIDGE: '1'
      VM_WORKERS: ''
      VM_CEPH_NODES: '21 22 23'
      CEPH_MODE: 'true'
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6
      - uses: actions/setup-node@395ad3262231945c25e8478fd5baf05154b1d79f  # v6
        with:
          node-version: '22'
          cache: 'npm'
      - run: .ci/scripts/setup/install-deps.sh
      - run: .ci/scripts/setup/build-packages.sh
      - run: .ci/scripts/build/build-cli.sh
      - name: Install CLI Globally
        run: .ci/scripts/setup/install-cli-global.sh

      - name: Pull Renet Docker Image
        run: .ci/scripts/infra/docker-pull-ghcr.sh --image "$RENET_DOCKER_IMAGE" --quiet
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT }}
          GITHUB_ACTOR: ${{ github.actor }}

      - name: Extract renet binary
        run: .ci/scripts/infra/extract-renet-binary.sh --image "$RENET_DOCKER_IMAGE"

      - name: Setup KVM Host
        run: sudo /tmp/renet ops host setup

      - name: Create Bridge Test Environment
        run: .ci/scripts/env/create-bridge-env.sh --ceph --output packages/bridge-tests/.env

      - name: Run Bridge Tests (Ceph)
        run: .ci/scripts/test/run-bridge.sh --workers 1 --config playwright.ceph.config.ts

      - if: always()
        run: .ci/scripts/signal/create-complete.sh --name "bridge-ceph" --status ${{ job.status }}

      - uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6
        if: always()
        with:
          name: test-bridge-ceph-${{ github.sha }}
          path: |
            ${{ runner.temp }}/complete.txt
            packages/bridge-tests/reports/bridge-ceph/
            packages/bridge-tests/reports/bridge-logs/
          retention-days: 3
          if-no-files-found: ignore

  test-cli-local:
    name: CLI Local E2E
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      CI: 'true'
      RENET_DOCKER_IMAGE: ghcr.io/rediacc/elite/bridge:${{ inputs.bridge_tag }}
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6
      - uses: actions/setup-node@395ad3262231945c25e8478fd5baf05154b1d79f  # v6
        with:
          node-version: '22'
          cache: 'npm'
      - run: .ci/scripts/setup/install-deps.sh
      - run: .ci/scripts/setup/build-packages.sh

      # Renet setup (same pattern as test-bridge-workers)
      - name: Pull Renet Docker Image
        run: .ci/scripts/infra/docker-pull-ghcr.sh --image "$RENET_DOCKER_IMAGE" --quiet
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT }}
          GITHUB_ACTOR: ${{ github.actor }}
      - name: Extract renet binary
        run: .ci/scripts/infra/extract-renet-binary.sh --image "$RENET_DOCKER_IMAGE"
      - name: Add renet to PATH
        run: sudo cp /tmp/renet /usr/bin/renet && sudo chmod +x /usr/bin/renet

      # VM provisioning
      - name: Setup KVM Host
        run: sudo /tmp/renet ops host setup
      - name: Generate SSH keypair
        run: |
          ssh-keygen -t ed25519 -f ~/.ssh/id_ed25519 -N "" -q
          # Also create id_rsa symlink (tests may reference it)
          cp ~/.ssh/id_ed25519 ~/.ssh/id_rsa
          cp ~/.ssh/id_ed25519.pub ~/.ssh/id_rsa.pub
      - name: Provision VM
        run: sudo -E /tmp/renet ops up --force --parallel
        env:
          VM_WORKERS: '11'
          VM_CEPH_NODES: ''
          VM_BRIDGE: '1'
      - name: Wait for VM SSH readiness
        run: |
          # Wait for both bridge (111.1) and worker (111.11) VMs
          for vm in 192.168.111.1 192.168.111.11; do
            echo "Waiting for $vm..."
            for i in {1..30}; do
              if ssh -o StrictHostKeyChecking=accept-new -o ConnectTimeout=5 root@$vm echo ready 2>/dev/null; then
                echo "VM $vm is SSH-ready"
                ssh-keyscan $vm >> ~/.ssh/known_hosts 2>/dev/null
                echo "Host keys added for $vm"
                break
              fi
              echo "Waiting for VM $vm SSH... ($i/30)"
              sleep 5
              if [[ $i -eq 30 ]]; then
                echo "VM $vm SSH not ready after 150s"
                exit 1
              fi
            done
          done

      # Start RustFS for S3 integration tests (sudo required â€” renet data dir is root-owned)
      - name: Start RustFS
        run: sudo -E .ci/scripts/infra/start-rustfs.sh --bucket rediacc-test
        env:
          RENET_BINARY_PATH: /usr/bin/renet

      # Run tests
      - name: Create CLI local E2E env
        run: .ci/scripts/env/create-cli-local-env.sh --output packages/cli/tests/.env
      - name: Append S3 test env
        run: .ci/scripts/env/create-cli-s3-env.sh --output packages/cli/tests/.env
      - name: Run CLI local E2E tests
        run: .ci/scripts/test/run-cli-local.sh

      - name: Run S3 integration tests (Vitest)
        working-directory: packages/cli
        run: npx vitest run --config vitest.s3.config.ts --reporter=verbose
        env:
          S3_TEST_ENDPOINT: http://192.168.111.1:9000
          S3_TEST_ACCESS_KEY: rustfsadmin
          S3_TEST_SECRET_KEY: rustfsadmin
          S3_TEST_BUCKET: rediacc-test

      - name: Run S3 CLI tests (Playwright)
        working-directory: packages/cli
        run: npx playwright test --config tests/playwright.config.ts --project=s3 --workers=1 --reporter=list

      # Artifacts
      - uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6
        if: always()
        with:
          name: test-cli-local-${{ github.sha }}
          path: packages/cli/tests/reports/
          retention-days: 3
          if-no-files-found: ignore

  test-renet:
    name: Renet
    runs-on: ubuntu-latest
    timeout-minutes: 60
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6
        with:
          submodules: true
          token: ${{ secrets.GH_PAT }}

      - uses: actions/setup-go@7a3fe6cf4cb3a834922a1244abfce67bcef6a0c5  # v6
        with:
          go-version: 'stable'
          cache: true
          cache-dependency-path: private/renet/go.sum

      # Unit tests
      - name: Run renet tests
        run: .ci/scripts/private/run-renet.sh test

      - uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6
        if: always()
        with:
          name: test-renet-coverage-${{ github.sha }}
          path: private/renet/coverage.out
          retention-days: 3
          if-no-files-found: ignore

      - uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6
        if: always()
        with:
          name: test-renet-results-${{ github.sha }}
          path: private/renet/test-results.xml
          retention-days: 3
          if-no-files-found: ignore

      # Integration tests (needs sudo for KVM)
      - name: Run integration tests
        run: sudo .ci/scripts/private/renet-integration.sh --no-cleanup

      - uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6
        if: always()
        with:
          name: test-renet-integration-${{ github.sha }}
          path: private/renet/test-results.xml
          retention-days: 3
          if-no-files-found: ignore
