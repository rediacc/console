name: Standalone Run
run-name: "${{ inputs.run-name || 'Manual Service Run' }}"

# Standalone workflow to run backend services for a specified duration
# Supports optional desktop environment (noVNC) for browser-based access
# Can be triggered manually (workflow_dispatch) or called from CI (workflow_call)
on:
  workflow_call:
    inputs:
      run-name:
        type: string
        default: 'CI Validation'
      duration:
        type: string
        default: '5'
      version:
        description: 'Docker image version tag (required for workflow_call)'
        type: string
        required: true
      api-tag:
        description: 'API image tag (overrides version for API)'
        type: string
        default: ''
      web-tag:
        description: 'Web image tag (overrides version for Web)'
        type: string
        default: ''
      bridge-tag:
        description: 'Bridge image tag (overrides version for Bridge)'
        type: string
        default: ''
      ci-mode:
        type: boolean
        default: true
      enable-desktop:
        type: boolean
        default: false
      desktop-environment:
        type: string
        default: 'xfce'
      desktop-resolution:
        type: string
        default: '1600x900'
      enable-debug:
        type: boolean
        default: false
      vm-os:
        description: 'VM OS (none = disabled)'
        type: string
        default: 'none'
      vm-os-list:
        description: 'JSON array of VM OS variants for matrix runs (overrides vm-os)'
        type: string
        default: ''
  workflow_dispatch:
    inputs:
      run-name:
        description: 'Custom name for this run'
        type: string
        default: 'Manual Service Run'
      duration:
        description: 'Duration (minutes)'
        type: choice
        default: '30'
        options:
          - '5'
          - '10'
          - '15'
          - '30'
          - '45'
          - '60'
          - '90'
          - '120'
          - '180'
          - '240'
          - '300'
      version:
        description: 'Docker image version tag (leave empty to auto-derive from branch/tag)'
        type: string
        default: ''
      ci-mode:
        description: 'Enable CI/TEST mode'
        type: boolean
        default: true
      enable-desktop:
        description: 'Enable desktop environment (noVNC)'
        type: boolean
        default: false
      desktop-environment:
        description: 'Desktop environment'
        type: choice
        default: 'xfce'
        options:
          - 'xfce'
          - 'gnome'
          - 'mate'
      desktop-resolution:
        description: 'Desktop resolution'
        type: choice
        default: '1600x900'
        options:
          - '1024x768'
          - '1280x720'
          - '1366x768'
          - '1600x900'
          - '1920x1080'
          - '2560x1440'
      enable-debug:
        description: 'Enable tmate SSH debugging'
        type: boolean
        default: false
      vm-os:
        description: 'VM OS (none = disabled, or select OS)'
        type: choice
        default: 'none'
        options:
          - 'none'
          - 'ubuntu-24.04'
          - 'debian-12'
          # TODO: Add fedora-43 and opensuse-15.6 once cloud-init compatibility is resolved

# Cancel in-progress runs when a new run is triggered
# Each run (workflow_dispatch or workflow_call) gets its own concurrency group via run_id
concurrency:
  group: ${{ github.workflow }}-${{ github.run_id }}
  cancel-in-progress: true

jobs:
  run-services:
    name: ${{ matrix.vm-os != 'none' && matrix.vm-os || 'Services' }}
    runs-on: ubuntu-latest
    timeout-minutes: 420  # 7 hours max
    strategy:
      fail-fast: false
      matrix:
        # When vm-os-list is provided (CI), use it as matrix; otherwise wrap single vm-os input
        vm-os: ${{ fromJSON(inputs.vm-os-list || format('["{0}"]', inputs.vm-os || 'none')) }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Set Image Tags
        run: |
          # Use reusable script to derive/validate base image tag
          # --version: explicit override (empty = auto-derive)
          # --env-file: exports TAG, API_TAG, WEB_TAG, BRIDGE_TAG to GITHUB_ENV
          .ci/scripts/ci/derive-image-tag.sh \
            ${{ inputs.version && format('--version "{0}"', inputs.version) || '' }} \
            --env-file

          # Override individual tags if provided (CI passes separate tags)
          if [[ -n "${{ inputs.api-tag }}" ]]; then
            echo "API_TAG=${{ inputs.api-tag }}" >> $GITHUB_ENV
          fi
          if [[ -n "${{ inputs.web-tag }}" ]]; then
            echo "WEB_TAG=${{ inputs.web-tag }}" >> $GITHUB_ENV
          fi
          if [[ -n "${{ inputs.bridge-tag }}" ]]; then
            echo "BRIDGE_TAG=${{ inputs.bridge-tag }}" >> $GITHUB_ENV
          fi

      - name: Pre-pull Docker Images
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_ACTOR: ${{ github.actor }}
          TAG: ${{ env.TAG }}
        run: .ci/scripts/infra/ci-pull-images.sh

      - name: Install sqlcmd
        run: |
          echo "Installing go-sqlcmd..."
          curl -fsSL https://github.com/microsoft/go-sqlcmd/releases/download/v1.8.0/sqlcmd-linux-amd64.tar.bz2 | \
            sudo tar -xjf - -C /usr/local/bin sqlcmd
          sqlcmd --version

      - name: Create Debug Session
        if: inputs.enable-debug
        id: tmate
        uses: rediacc/action-tmate@v1
        with:
          timeout: 60

      # SECURITY NOTE: tmate debug session is started BEFORE services
      # This ensures no GITHUB_TOKEN is present in the environment when debug access is available
      # All required images have been pre-pulled, so no authentication is needed from this point forward

      - name: Start Backend Services
        id: backend
        uses: ./.github/actions/start-backend
        with:
          keep-alive: 'true'
          ci-mode: ${{ inputs.ci-mode && 'true' || 'false' }}
        env:
          TAG: ${{ env.TAG }}
          CI_MODE: ${{ inputs.ci-mode && 'true' || 'false' }}

      # VM Provisioning (optional - builds image on-demand since no pre-built artifact)
      - name: Pull Bridge Image for VM Provisioning
        if: matrix.vm-os != 'none'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_ACTOR: ${{ github.actor }}
        run: .ci/scripts/infra/docker-pull-ghcr.sh --image "ghcr.io/rediacc/elite/bridge:${{ env.TAG }}" --quiet

      - name: Provision VMs
        id: vms
        if: matrix.vm-os != 'none'
        uses: ./.github/actions/provision-vms
        with:
          bridge-tag: ${{ env.TAG }}
          vm-os: ${{ matrix.vm-os }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_ACTOR: ${{ github.actor }}

      - name: Display VM Information
        if: matrix.vm-os != 'none' && steps.vms.outputs.kvm-available == 'true'
        run: |
          echo ""
          echo "================================================================"
          echo "  VMs Provisioned (${{ matrix.vm-os }})"
          echo "================================================================"
          echo "  OS:       ${{ matrix.vm-os }}"
          echo "  Bridge:   ${{ steps.vms.outputs.bridge-ip }}"
          echo "  Workers:  ${{ steps.vms.outputs.worker-ips }}"
          echo "================================================================"
          echo ""

      - name: Setup Desktop Environment
        if: inputs.enable-desktop
        id: desktop
        env:
          DESKTOP_ENVIRONMENT: ${{ inputs.desktop-environment }}
          DESKTOP_RESOLUTION: ${{ inputs.desktop-resolution }}
        run: |
          chmod +x .ci/scripts/infra/ci-desktop.sh
          .ci/scripts/infra/ci-desktop.sh --keep-running

      - name: Start Caddy Gateway
        if: inputs.enable-desktop
        run: |
          echo "Starting Caddy gateway for desktop routing..."
          cd .ci/docker/ci
          docker compose -f docker-compose.yml -f docker-compose.desktop.yml up -d gateway

          # Wait for gateway to be ready
          timeout 30 bash -c 'until curl -sf http://localhost:8080/health > /dev/null 2>&1; do sleep 1; done' || {
            echo "Gateway health check timed out, checking status..."
            docker logs rediacc-gateway --tail 20 || true
          }
          echo "Caddy gateway started"

      - name: Create Cloudflare Tunnel
        id: tunnel
        uses: rediacc/action-cloudflare-tunnel@v1
        with:
          # When desktop is enabled, route through Caddy gateway on port 8080
          url: ${{ inputs.enable-desktop && 'http://localhost:8080' || 'http://localhost' }}
          timeout: 30

      - name: Verify Tunnel
        run: |
          TUNNEL_URL="${{ steps.tunnel.outputs.tunnel-url }}"
          echo "Verifying tunnel connectivity..."

          # Wait for tunnel to be accessible
          timeout 60 bash -c "until curl -sf '${TUNNEL_URL}/health' > /dev/null 2>&1; do sleep 2; done" || {
            echo "WARNING: Tunnel health check failed, but continuing..."
          }

          echo "Tunnel verified: ${TUNNEL_URL}"

      - name: Display Access Information
        run: |
          TUNNEL_URL="${{ steps.tunnel.outputs.tunnel-url }}"
          DURATION_MIN="${{ inputs.duration }}"

          echo ""
          echo "================================================================"
          echo "  Rediacc Console Services Ready"
          echo "================================================================"
          echo ""
          echo "DOCKER IMAGE VERSION: ${{ env.TAG }}"
          echo "DURATION: ${DURATION_MIN} minutes"
          echo ""
          echo "WEB ACCESS:"
          echo "  Tunnel URL: ${TUNNEL_URL}"

          if [ "${{ inputs.enable-desktop }}" == "true" ]; then
            echo "  Desktop:    ${TUNNEL_URL}/desktop"
            echo ""
            echo "DESKTOP:"
            echo "  Environment: ${{ inputs.desktop-environment }}"
            echo "  Resolution:  ${{ inputs.desktop-resolution }}"
          fi

          echo ""
          echo "LOCAL ACCESS:"
          echo "  Web UI:  http://localhost"
          echo "  API:     http://localhost/api"

          if [ "${{ inputs.enable-desktop }}" == "true" ]; then
            echo "  Desktop: http://localhost:6080/vnc.html"
            echo "  Gateway: http://localhost:8080"
          fi

          if [ "${{ inputs.enable-debug }}" == "true" ]; then
            echo ""
            echo "DEBUG ACCESS:"
            echo "  SSH:     ${{ steps.tmate.outputs.ssh-connection }}"
            echo "  Web:     ${{ steps.tmate.outputs.web-url }}"
          fi

          if [ "${{ matrix.vm-os }}" != "none" ] && [ "${{ steps.vms.outputs.kvm-available }}" == "true" ]; then
            echo ""
            echo "VMs (${{ matrix.vm-os }}):"
            echo "  Bridge:  ${{ steps.vms.outputs.bridge-ip }}"
            echo "  Workers: ${{ steps.vms.outputs.worker-ips }}"
          fi

          echo ""
          echo "================================================================"

      - name: Keep Services Alive
        run: |
          DURATION_MIN="${{ inputs.duration }}"
          DURATION_SEC=$((DURATION_MIN * 60))
          END_TIME=$(($(date +%s) + DURATION_SEC))
          CHECK_INTERVAL=300  # Check every 5 minutes

          echo ""
          echo "Keeping services alive for ${DURATION_MIN} minutes..."
          echo "  Start time: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "  End time:   $(date -d @${END_TIME} '+%Y-%m-%d %H:%M:%S')"
          echo ""

          while [ $(date +%s) -lt ${END_TIME} ]; do
            REMAINING=$(( (END_TIME - $(date +%s)) / 60 ))

            # Run health check
            if curl -sf http://localhost/health > /dev/null 2>&1; then
              echo "${REMAINING} min remaining - services healthy"
            else
              echo "${REMAINING} min remaining - WARNING: health check failed"
              echo ""
              echo "Container Status:"
              docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | grep -E "(NAME|rediacc)" || true
              echo ""
            fi

            # Calculate next check or remaining time
            TIME_LEFT=$((END_TIME - $(date +%s)))
            if [ ${TIME_LEFT} -lt ${CHECK_INTERVAL} ]; then
              SLEEP_TIME=${TIME_LEFT}
            else
              SLEEP_TIME=${CHECK_INTERVAL}
            fi

            if [ ${SLEEP_TIME} -gt 0 ]; then
              sleep ${SLEEP_TIME}
            fi
          done

          echo ""
          echo "================================================================"
          echo "Duration completed at $(date '+%Y-%m-%d %H:%M:%S')"
          echo "================================================================"

      - name: Final Service Status
        if: always()
        run: |
          echo ""
          echo "Final Container Status:"
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | grep -E "(NAME|rediacc)" || true
          echo ""
          echo "Recent API Logs (last 30 lines):"
          docker logs rediacc-api --tail=30 2>&1 || true

      - name: Cleanup
        if: always()
        run: |
          echo ""
          echo "Cleaning up..."

          # Stop tmate session if enabled
          if [ "${{ inputs.enable-debug }}" == "true" ]; then
            TMATE_PID="${{ steps.tmate.outputs.session-pid }}"
            if [ -n "$TMATE_PID" ] && ps -p $TMATE_PID > /dev/null 2>&1; then
              echo "Stopping tmate session (PID: $TMATE_PID)..."
              kill $TMATE_PID || true
            fi
          fi

          # Stop cloudflared tunnel
          TUNNEL_PID="${{ steps.tunnel.outputs.tunnel-pid }}"
          if [ -n "$TUNNEL_PID" ] && ps -p $TUNNEL_PID > /dev/null 2>&1; then
            echo "Stopping Cloudflare Tunnel (PID: $TUNNEL_PID)..."
            kill $TUNNEL_PID || true
          fi

          # Cleanup desktop processes
          if [ "${{ inputs.enable-desktop }}" == "true" ]; then
            echo "Stopping desktop environment..."
            .ci/scripts/infra/ci-desktop-cleanup.sh || true
          fi

          # Stop VMs if enabled
          if [ "${{ matrix.vm-os }}" != "none" ]; then
            echo "Stopping VMs..."
            sudo /tmp/renet ops down || true
          fi

          # Stop Docker services
          echo "Stopping Docker services..."
          cd .ci/docker/ci

          # Stop gateway if running
          if docker ps --format "{{.Names}}" | grep -q "^rediacc-gateway$"; then
            docker compose -f docker-compose.yml -f docker-compose.desktop.yml down gateway || true
          fi

          # Stop all backend services
          docker compose down --volumes --remove-orphans || true

          # Cleanup mssql directory
          sudo rm -rf mssql || rm -rf mssql || true

          echo "Cleanup complete"

      - name: Summary
        if: always()
        run: |
          echo ""
          echo "================================================================"
          echo "  Run Summary"
          echo "================================================================"
          echo "  Duration: ${{ inputs.duration }} minutes"
          echo "  Status:   ${{ job.status }}"
          echo "  Version:  ${{ env.TAG }}"
          echo "  Desktop:  ${{ inputs.enable-desktop && 'enabled' || 'disabled' }}"
          echo "  VMs:      ${{ matrix.vm-os != 'none' && matrix.vm-os || 'disabled' }}"
          echo "  Debug:    ${{ inputs.enable-debug && 'enabled' || 'disabled' }}"
          echo "  End time: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "================================================================"
