name: Standalone Run
run-name: "${{ inputs.run-name || 'Manual Service Run' }}"

# Standalone workflow to run backend services for a specified duration
# Supports optional desktop environment (noVNC) for browser-based access
# Can be triggered manually (workflow_dispatch) or called from CI (workflow_call)
on:
  workflow_call:
    inputs:
      run-name:
        type: string
        default: 'CI Validation'
      duration:
        type: string
        default: '5'
      version:
        description: 'Docker image version tag (required for workflow_call)'
        type: string
        required: true
      api-tag:
        description: 'API image tag (overrides version for API)'
        type: string
        default: ''
      web-tag:
        description: 'Web image tag (overrides version for Web)'
        type: string
        default: ''
      bridge-tag:
        description: 'Bridge image tag (overrides version for Bridge)'
        type: string
        default: ''
      ci-mode:
        type: boolean
        default: true
      desktop-environment:
        type: string
        default: 'none'
      desktop-resolution:
        type: string
        default: '1600x900'
      enable-debug:
        type: boolean
        default: false
      vm-os:
        description: 'VM OS (none = disabled)'
        type: string
        default: 'ubuntu-24.04'
      vm-os-list:
        description: 'JSON array of VM OS variants for matrix runs (overrides vm-os)'
        type: string
        default: ''
    secrets:
      APP_PRIVATE_KEY:
        required: false
  workflow_dispatch:
    inputs:
      run-name:
        description: 'Custom name for this run'
        type: string
        default: 'Manual Service Run'
      duration:
        description: 'Duration (minutes)'
        type: choice
        default: '30'
        options:
          - '5'
          - '10'
          - '15'
          - '30'
          - '45'
          - '60'
          - '90'
          - '120'
          - '180'
          - '240'
          - '300'
      version:
        description: 'Docker image version tag (leave empty to auto-derive from branch/tag)'
        type: string
        default: ''
      ci-mode:
        description: 'Enable CI/TEST mode'
        type: boolean
        default: true
      desktop-environment:
        description: 'Desktop environment (none = disabled)'
        type: choice
        default: 'none'
        options:
          - 'none'
          - 'xfce'
          - 'gnome'
          - 'mate'
      desktop-resolution:
        description: 'Desktop resolution'
        type: choice
        default: '1600x900'
        options:
          - '1024x768'
          - '1280x720'
          - '1366x768'
          - '1600x900'
          - '1920x1080'
          - '2560x1440'
      enable-debug:
        description: 'Enable tmate SSH debugging'
        type: boolean
        default: false
      vm-os:
        description: 'VM OS (none = disabled, or select OS)'
        type: choice
        default: 'ubuntu-24.04'
        options:
          - 'none'
          - 'ubuntu-24.04'
          - 'debian-12'
          # TODO: Add fedora-43 and opensuse-15.6 once cloud-init compatibility is resolved

permissions:
  contents: read
  packages: read

# Cancel in-progress runs when a new run is triggered
# Each run (workflow_dispatch or workflow_call) gets its own concurrency group via run_id
concurrency:
  group: ${{ github.workflow }}-${{ github.run_id }}
  cancel-in-progress: true

jobs:
  run-services:
    name: ${{ matrix.vm-os != 'none' && matrix.vm-os || 'Services' }}
    runs-on: ubuntu-latest
    timeout-minutes: 420  # 7 hours max
    strategy:
      matrix:
        # When vm-os-list is provided (CI), use it as matrix; otherwise wrap single vm-os input
        vm-os: ${{ fromJSON(inputs.vm-os-list || format('["{0}"]', inputs.vm-os || 'none')) }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5  # v4

      - uses: ./.github/actions/app-token
        id: app-token
        with:
          app-id: ${{ vars.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}
          repositories: console,middleware,renet,account,sql,elite,homebrew-tap,growth

      - name: Checkout with Submodules
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5  # v4
        with:
          submodules: recursive
          token: ${{ steps.app-token.outputs.token }}

      - name: Set Image Tags
        run: |
          # Use reusable script to derive/validate base image tag
          # --version: explicit override (empty = auto-derive)
          # --env-file: exports TAG, API_TAG, WEB_TAG, BRIDGE_TAG to GITHUB_ENV
          .ci/scripts/ci/derive-image-tag.sh \
            ${{ inputs.version && format('--version "{0}"', inputs.version) || '' }} \
            --env-file

          # Override individual tags if provided (CI passes separate tags)
          if [[ -n "${{ inputs.api-tag }}" ]]; then
            echo "API_TAG=${{ inputs.api-tag }}" >> $GITHUB_ENV
          fi
          if [[ -n "${{ inputs.web-tag }}" ]]; then
            echo "WEB_TAG=${{ inputs.web-tag }}" >> $GITHUB_ENV
          fi
          if [[ -n "${{ inputs.bridge-tag }}" ]]; then
            echo "BRIDGE_TAG=${{ inputs.bridge-tag }}" >> $GITHUB_ENV
          fi

      - name: Pre-pull Docker Images
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_ACTOR: ${{ github.actor }}
          TAG: ${{ env.TAG }}
        run: .ci/scripts/infra/ci-pull-images.sh

      - name: Install sqlcmd (go-sqlcmd)
        run: sudo private/middleware/scripts/install-sqlcmd.sh

      - name: Create Debug Session
        if: inputs.enable-debug
        id: tmate
        uses: ./.github/actions/tmate
        with:
          timeout: 60

      # SECURITY NOTE: tmate debug session is started BEFORE services
      # This ensures no GITHUB_TOKEN is present in the environment when debug access is available
      # All required images have been pre-pulled, so no authentication is needed from this point forward

      - name: Start Backend Services
        id: backend
        uses: ./.github/actions/start-backend
        with:
          keep-alive: 'true'
          ci-mode: ${{ inputs.ci-mode && 'true' || 'false' }}
        env:
          TAG: ${{ env.TAG }}
          CI_MODE: ${{ inputs.ci-mode && 'true' || 'false' }}

      # VM Provisioning (optional - builds renet from source and image on-demand)
      - name: Provision VMs
        id: vms
        if: matrix.vm-os != 'none'
        uses: ./.github/actions/provision-vms
        with:
          vm-os: ${{ matrix.vm-os }}

      - name: Setup Desktop Environment
        if: inputs.desktop-environment != 'none'
        id: desktop
        env:
          DESKTOP_ENVIRONMENT: ${{ inputs.desktop-environment }}
          DESKTOP_RESOLUTION: ${{ inputs.desktop-resolution }}
        run: |
          chmod +x .ci/scripts/infra/ci-desktop.sh
          .ci/scripts/infra/ci-desktop.sh --keep-running

      - name: Start Caddy Gateway
        if: inputs.desktop-environment != 'none'
        run: |
          echo "Starting Caddy gateway for desktop routing..."
          cd .ci/docker/ci
          docker compose -f docker-compose.yml -f docker-compose.desktop.yml up -d --no-recreate gateway

          # Wait for gateway to be ready
          timeout 30 bash -c 'until curl -sf http://localhost:8080/health > /dev/null 2>&1; do sleep 1; done' || {
            echo "Gateway health check timed out, checking status..."
            docker logs rediacc-gateway --tail 20 || true
          }
          echo "Caddy gateway started"

      - name: Create Cloudflare Tunnel
        id: tunnel
        run: |
          LOCAL_URL="${{ inputs.desktop-environment != 'none' && 'http://localhost:8080' || 'http://localhost' }}"
          TUNNEL_URL=$(.ci/scripts/tunnel/start-cloudflare.sh --url "$LOCAL_URL" --timeout 60) || true
          echo "tunnel-url=${TUNNEL_URL}" >> $GITHUB_OUTPUT
          if [[ -n "$TUNNEL_URL" ]]; then
            echo "Cloudflare tunnel: $TUNNEL_URL"
          else
            echo "::warning::Cloudflare tunnel failed â€” services available only via localhost"
          fi

      - name: Display Access Information and Keep Services Alive
        run: |
          # Display Access Information
          TUNNEL_URL="${{ steps.tunnel.outputs.tunnel-url }}"
          DURATION_MIN="${{ inputs.duration }}"

          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸŒ ACCESS INFORMATION"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "ğŸ“¦ DOCKER IMAGE VERSION: ${{ env.TAG }}"
          echo "â±ï¸  DURATION: ${DURATION_MIN} minutes"
          echo ""
          echo "ğŸŒ WEB ACCESS:"
          echo "   â€¢ Cloudflare Tunnel: ${TUNNEL_URL}"
          if [ "${{ inputs.desktop-environment }}" != "none" ]; then
            echo "   â€¢ Desktop (noVNC): ${TUNNEL_URL}/desktop"
            echo "   â€¢ Environment: ${{ inputs.desktop-environment }}"
            echo "   â€¢ Resolution: ${{ inputs.desktop-resolution }}"
          fi
          echo ""

          # Display VM infrastructure details if enabled
          if [ "${{ matrix.vm-os }}" != "none" ] && [ "${{ steps.vms.outputs.kvm-available }}" == "true" ]; then
            echo "ğŸ–¥ï¸  VM INFRASTRUCTURE:"
            echo "   â€¢ Provider: KVM"
            echo "   â€¢ OS: ${{ matrix.vm-os }}"
            echo "   â€¢ Bridge IP: ${{ steps.vms.outputs.bridge-ip }}"
            echo "   â€¢ Worker IPs: ${{ steps.vms.outputs.worker-ips }}"
            echo ""
            echo "ğŸ“ VM SERVICE URLS:"
            echo "   â€¢ API: http://${{ steps.vms.outputs.bridge-ip }}"
            echo "   â€¢ Web UI: http://${{ steps.vms.outputs.bridge-ip }}"
            echo "   â€¢ Registry: ${{ steps.vms.outputs.bridge-ip }}:5000"
            echo ""
            echo "ğŸ” VM CREDENTIALS:"
            echo "   â€¢ Username: ${{ steps.vms.outputs.machine-user }}"
            echo "   â€¢ Password: ${{ steps.vms.outputs.machine-password }}"
            echo ""
            echo "ğŸ”‘ SSH ACCESS TO VMS:"
            echo "   â€¢ Bridge:  ssh ${{ steps.vms.outputs.machine-user }}@${{ steps.vms.outputs.bridge-ip }}"

            # Parse and display worker IPs
            IFS=',' read -ra WORKER_ARRAY <<< "${{ steps.vms.outputs.worker-ips }}"
            for i in "${!WORKER_ARRAY[@]}"; do
              echo "   â€¢ Worker $((i+1)): ssh ${{ steps.vms.outputs.machine-user }}@${WORKER_ARRAY[$i]}"
            done
            echo ""
          fi

          echo "ğŸ³ LOCAL SERVICES:"
          echo "   â€¢ Web UI:  http://localhost"
          echo "   â€¢ API:     http://localhost/api"
          if [ "${{ inputs.desktop-environment }}" != "none" ]; then
            echo "   â€¢ Desktop: http://localhost:6080/vnc.html"
            echo "   â€¢ Gateway: http://localhost:8080"
          fi
          echo ""

          echo "ğŸ—„ï¸  DATABASE:"
          echo "   â€¢ SQL Server: ${{ env.CONNECTION_STRING }}"
          echo ""

          # Display debug access if enabled
          if [ "${{ inputs.enable-debug }}" == "true" ]; then
            echo "ğŸ”§ DEBUG ACCESS:"
            echo "   â€¢ SSH: ${{ steps.tmate.outputs.ssh-connection }}"
            echo "   â€¢ Web: ${{ steps.tmate.outputs.web-url }}"
            echo ""
          fi

          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""

          # Keep Services Alive
          DURATION_SEC=$((DURATION_MIN * 60))
          END_TIME=$(($(date +%s) + DURATION_SEC))
          CHECK_INTERVAL=300  # Check every 5 minutes

          echo "â³ Keeping services alive for ${DURATION_MIN} minutes..."
          echo "   Start time: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "   End time:   $(date -d @${END_TIME} '+%Y-%m-%d %H:%M:%S')"
          echo ""

          while [ $(date +%s) -lt ${END_TIME} ]; do
            REMAINING=$(( (END_TIME - $(date +%s)) / 60 ))

            # Run health check
            if curl -sf http://localhost/health > /dev/null 2>&1; then
              echo "â±ï¸  ${REMAINING} minutes remaining - services healthy"
            else
              echo "â±ï¸  ${REMAINING} minutes remaining - âš ï¸  health check failed"
              echo ""
              echo "ğŸ“‹ Container Status:"
              docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | grep -E "(NAME|rediacc)" || true
              echo ""
            fi

            # Calculate next check or remaining time
            TIME_LEFT=$((END_TIME - $(date +%s)))
            if [ ${TIME_LEFT} -lt ${CHECK_INTERVAL} ]; then
              SLEEP_TIME=${TIME_LEFT}
            else
              SLEEP_TIME=${CHECK_INTERVAL}
            fi

            if [ ${SLEEP_TIME} -gt 0 ]; then
              sleep ${SLEEP_TIME}
            fi
          done

          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "â° Duration completed at $(date '+%Y-%m-%d %H:%M:%S')"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

      - name: Final Service Status
        if: always()
        run: |
          echo ""
          echo "Final Container Status:"
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | grep -E "(NAME|rediacc)" || true
          echo ""
          echo "Recent Account Server Logs (last 50 lines):"
          docker logs rediacc-account --tail=50 2>&1 || true
          echo ""
          echo "Recent API Logs (last 30 lines):"
          docker logs rediacc-api --tail=30 2>&1 || true

      - name: Cleanup
        if: always()
        run: |
          echo ""
          echo "Cleaning up..."

          # Stop tmate session if enabled
          if [ "${{ inputs.enable-debug }}" == "true" ]; then
            TMATE_PID="${{ steps.tmate.outputs.session-pid }}"
            if [ -n "$TMATE_PID" ] && ps -p $TMATE_PID > /dev/null 2>&1; then
              echo "Stopping tmate session (PID: $TMATE_PID)..."
              kill $TMATE_PID || true
            fi
          fi

          # Stop cloudflared tunnel
          if [ -f "$RUNNER_TEMP/cloudflared.pid" ]; then
            TUNNEL_PID=$(cat "$RUNNER_TEMP/cloudflared.pid")
            if [ -n "$TUNNEL_PID" ] && ps -p $TUNNEL_PID > /dev/null 2>&1; then
              echo "Stopping Cloudflare Tunnel (PID: $TUNNEL_PID)..."
              kill $TUNNEL_PID || true
            fi
          fi

          # Cleanup desktop processes
          if [ "${{ inputs.desktop-environment }}" != "none" ]; then
            echo "Stopping desktop environment..."
            .ci/scripts/infra/ci-desktop-cleanup.sh || true
          fi

          # Stop VMs if enabled
          if [ "${{ matrix.vm-os }}" != "none" ]; then
            echo "Stopping VMs..."
            .ci/scripts/infra/ci-provision-stop.sh || true
          fi

          # Stop gateway if running (desktop overlay)
          if docker ps --format "{{.Names}}" | grep -q "^rediacc-gateway$"; then
            cd .ci/docker/ci
            docker compose -f docker-compose.yml -f docker-compose.desktop.yml down gateway || true
          fi

          # Stop all backend services
          .ci/scripts/infra/ci-stop.sh

          echo "Cleanup complete"

      - name: Summary
        if: always()
        run: |
          echo ""
          echo "================================================================"
          echo "  Run Summary"
          echo "================================================================"
          echo "  Duration: ${{ inputs.duration }} minutes"
          echo "  Status:   ${{ job.status }}"
          echo "  Version:  ${{ env.TAG }}"
          echo "  Desktop:  ${{ inputs.desktop-environment != 'none' && 'enabled' || 'disabled' }}"
          echo "  VMs:      ${{ matrix.vm-os != 'none' && matrix.vm-os || 'disabled' }}"
          echo "  Debug:    ${{ inputs.enable-debug && 'enabled' || 'disabled' }}"
          echo "  End time: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "================================================================"
