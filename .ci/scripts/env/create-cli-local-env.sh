#!/bin/bash
# Create CLI local mode E2E test environment file
# Usage: create-cli-local-env.sh --output <path> [options]
#
# Generates a .env file for CLI local mode E2E tests with VM network configuration.
# Also ensures VM host keys are in known_hosts for SSH connectivity.
#
# Options:
#   --output        Output .env file path (required)
#   --vm-net-base   VM network base (default: 192.168.111)
#   --vm-workers    Worker VM IDs, space-separated (default: "11")
#   --ssh-user      SSH user (default: current user)
#   --ssh-key       Path to SSH private key (auto-detected if not specified)
#   --skip-keyscan  Skip ssh-keyscan for known_hosts population
#
# Environment:
#   VM_CEPH_NODES   When set, E2E_CEPH_NODES is included in the output (enables Ceph tests)
#
# Example:
#   .ci/scripts/env/create-cli-local-env.sh --output packages/cli/tests/.env
#   .ci/scripts/env/create-cli-local-env.sh --output .env --vm-workers "11 12"
#   VM_CEPH_NODES="21 22 23" .ci/scripts/env/create-cli-local-env.sh --output .env --vm-workers "11"

set -euo pipefail
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/../lib/common.sh"

# Auto-detect SSH key for VM access.
# Prefers RSA because renet OPS provisions VMs with RSA public keys
# and the ssh2 library (used by the CLI provisioner) doesn't read
# SSH config files — it only uses the key passed programmatically.
detect_ssh_key() {
    local key_path=""
    for candidate in "$HOME/.ssh/id_rsa" "$HOME/.ssh/id_ed25519" "$HOME/.ssh/id_ecdsa"; do
        if [[ -f "$candidate" ]]; then
            key_path="$candidate"
            break
        fi
    done
    if [[ -z "$key_path" ]]; then
        log_warn "No SSH key found in ~/.ssh/ — tests will fail without SSH key"
        key_path="$HOME/.ssh/id_rsa"
    fi
    echo "$key_path"
}

# Parse arguments
parse_args "$@"

OUTPUT="${ARG_OUTPUT:-}"
VM_NET_BASE="${ARG_VM_NET_BASE:-192.168.111}"
VM_WORKERS="${ARG_VM_WORKERS:-11}"
SSH_USER="${ARG_SSH_USER:-${USER:-$(whoami)}}"
SSH_KEY="${ARG_SSH_KEY:-$(detect_ssh_key)}"
SKIP_KEYSCAN="${ARG_SKIP_KEYSCAN:-false}"

# Validate required arguments
if [[ -z "$OUTPUT" ]]; then
    log_error "Usage: create-cli-local-env.sh --output <path>"
    exit 1
fi

# Create output directory if needed
mkdir -p "$(dirname "$OUTPUT")"

log_step "Creating CLI local E2E test environment: $OUTPUT"

# Compute VM IPs from worker IDs
read -ra WORKER_IDS <<<"$VM_WORKERS"
VM1_IP="${VM_NET_BASE}.${WORKER_IDS[0]}"
VM2_IP=""
[[ ${#WORKER_IDS[@]} -ge 2 ]] && VM2_IP="${VM_NET_BASE}.${WORKER_IDS[1]}"

REPO_ROOT="$(get_repo_root)"
RENET_PATH="${RENET_BINARY:-$REPO_ROOT/private/renet/bin/renet}"

cat >"$OUTPUT" <<EOF
# CLI Local Mode E2E Test Environment
# Generated by .ci/scripts/env/create-cli-local-env.sh

E2E_VM1_IP=$VM1_IP
E2E_VM2_IP=$VM2_IP
E2E_SSH_USER=$SSH_USER
E2E_SSH_KEY=$SSH_KEY
E2E_RENET_PATH=$RENET_PATH
PLAYWRIGHT_SKIP_GLOBAL_SETUP=true
CI=true
EOF

# Propagate Ceph node configuration from environment
if [[ -n "${VM_CEPH_NODES:-}" ]]; then
    echo "E2E_CEPH_NODES=$VM_CEPH_NODES" >>"$OUTPUT"
fi

log_info "Created CLI local E2E env: $OUTPUT"

# Populate known_hosts for VM IPs (ensures SSH won't fail with "key is unknown")
if [[ "$SKIP_KEYSCAN" != "true" ]]; then
    log_step "Ensuring VM host keys are in known_hosts..."
    mkdir -p "$HOME/.ssh"
    touch "$HOME/.ssh/known_hosts"

    ALL_IPS=("$VM1_IP")
    [[ -n "$VM2_IP" ]] && ALL_IPS+=("$VM2_IP")
    # Also include bridge IP
    BRIDGE_IP="${VM_NET_BASE}.1"
    ALL_IPS+=("$BRIDGE_IP")

    for vm_ip in "${ALL_IPS[@]}"; do
        # Check if already in known_hosts
        if ssh-keygen -F "$vm_ip" &>/dev/null; then
            log_debug "Host key already known for $vm_ip"
        else
            if ssh-keyscan -T 5 "$vm_ip" >>"$HOME/.ssh/known_hosts" 2>/dev/null; then
                log_info "Added host key for $vm_ip"
            else
                log_warn "Could not scan host key for $vm_ip (VM may not be running)"
            fi
        fi
    done
fi

# Display contents for debugging
if [[ "${DEBUG:-false}" == "true" ]]; then
    echo ""
    echo "Contents:"
    cat "$OUTPUT"
fi
