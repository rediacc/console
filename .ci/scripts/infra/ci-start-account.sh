#!/bin/bash
# CI Account Server Startup Script
# Starts the account server on-premise docker-compose stack and waits for health checks
# Uses RustFS (S3-compatible) for local object storage instead of Cloudflare R2/S3
#
# Usage:
#   .ci/scripts/infra/ci-start-account.sh
#
# Required environment variables (from GitHub secrets):
#   ED25519_PRIVATE_KEY        - Ed25519 private key for subscription signing
#   ED25519_PUBLIC_KEY         - Ed25519 public key for subscription verification
#   ACCOUNT_SERVER_API_KEY     - Account server API key
#
# Outputs (for GitHub Actions):
#   account_server_url - The base URL for the account server (http://localhost:3000)

set -e

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONSOLE_ROOT="$(cd "$SCRIPT_DIR/../../.." && pwd)"
CI_DOCKER_DIR="$CONSOLE_ROOT/.ci/docker/ci"

echo "Starting Rediacc Account Server CI services..."

# =============================================================================
# VALIDATE REQUIRED SECRETS
# =============================================================================
if [[ -z "${ED25519_PRIVATE_KEY:-}" ]]; then
    echo "ERROR: ED25519_PRIVATE_KEY is not set"
    echo "This must be configured as a GitHub secret"
    exit 1
fi
if [[ -z "${ED25519_PUBLIC_KEY:-}" ]]; then
    echo "ERROR: ED25519_PUBLIC_KEY is not set"
    echo "This must be configured as a GitHub secret"
    exit 1
fi
if [[ -z "${ACCOUNT_SERVER_API_KEY:-}" ]]; then
    echo "ERROR: ACCOUNT_SERVER_API_KEY is not set"
    echo "This must be configured as a GitHub secret"
    exit 1
fi

# Save production credentials — ci-env.sh would overwrite them
# because it regenerates the key pair when it runs
_PROD_ED25519_PRIVATE_KEY="$ED25519_PRIVATE_KEY"
_PROD_ED25519_PUBLIC_KEY="$ED25519_PUBLIC_KEY"
_PROD_ACCOUNT_SERVER_API_KEY="$ACCOUNT_SERVER_API_KEY"

# =============================================================================
# SOURCE BASE ENVIRONMENT
# =============================================================================
# ci-env.sh generates RustFS credentials, webhook secret, etc.
# shellcheck source=ci-env.sh
source "$SCRIPT_DIR/ci-env.sh"

# =============================================================================
# RESTORE PRODUCTION CREDENTIALS
# =============================================================================
export ED25519_PRIVATE_KEY="$_PROD_ED25519_PRIVATE_KEY"
export ED25519_PUBLIC_KEY="$_PROD_ED25519_PUBLIC_KEY"
export ACCOUNT_SERVER_API_KEY="$_PROD_ACCOUNT_SERVER_API_KEY"

# =============================================================================
# WRITE .ENV FOR DOCKER COMPOSE
# =============================================================================
echo "Writing .env to $CI_DOCKER_DIR..."
{
    echo "# Auto-generated by ci-start-account.sh — do not edit"
    echo "ED25519_PRIVATE_KEY=${ED25519_PRIVATE_KEY}"
    echo "ED25519_PUBLIC_KEY=${ED25519_PUBLIC_KEY}"
    echo "ACCOUNT_SERVER_API_KEY=${ACCOUNT_SERVER_API_KEY}"
    echo "RUSTFS_ACCESS_KEY=${RUSTFS_ACCESS_KEY}"
    echo "RUSTFS_SECRET_KEY=${RUSTFS_SECRET_KEY}"
    echo "STRIPE_WEBHOOK_SECRET=${STRIPE_WEBHOOK_SECRET:-}"
    echo "JWT_SECRET=${JWT_SECRET}"
} >"$CI_DOCKER_DIR/.env"

# =============================================================================
# START ACCOUNT SERVICES
# =============================================================================
echo "Starting Account Server Docker Compose services..."
cd "$CI_DOCKER_DIR"

# Start only account-server (auto-pulls dependencies: rustfs, volume-init, bucket-init)
docker compose -f docker-compose.yml up -d account-server

# =============================================================================
# WAIT FOR HEALTH CHECKS
# =============================================================================
echo "Waiting for Account Server to be ready..."

wait_for_account_server() {
    local timeout=120
    local elapsed=0
    local interval=3

    echo "  Waiting for account-server..."
    while [[ $elapsed -lt $timeout ]]; do
        if docker inspect rediacc-account-server --format='{{.State.Health.Status}}' 2>/dev/null | grep -q "healthy"; then
            echo "  Account server is healthy"
            return 0
        fi
        # Check if container is still running
        if ! docker ps --format "{{.Names}}" | grep -q "^rediacc-account-server$"; then
            echo "  Account server container stopped unexpectedly"
            docker logs rediacc-account-server --tail 50 || true
            return 1
        fi
        sleep $interval
        elapsed=$((elapsed + interval))
        if ((elapsed % 15 == 0)); then
            echo "    Still waiting... (${elapsed}s / ${timeout}s)"
        fi
    done
    echo "  Account server failed to become healthy within ${timeout}s"
    docker logs rediacc-account-server --tail 100 || true
    return 1
}

wait_for_account_server || {
    echo "Account server startup failed"
    docker compose -f docker-compose.yml logs account-server account-rustfs
    exit 1
}

echo ""
echo "Account server is ready!"

# =============================================================================
# OUTPUT FOR GITHUB ACTIONS
# =============================================================================
if [[ -n "${GITHUB_OUTPUT:-}" ]]; then
    echo "account_server_url=http://localhost:3000" >>"$GITHUB_OUTPUT"
fi

# Show running containers
echo ""
echo "Running containers:"
docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | grep -E "(NAME|account)" || true
