#!/bin/bash
# CI Elite Service Startup Script
# Starts the elite on-premise docker-compose stack and waits for health checks
# Tests the same setup customers deploy before changes affect them
#
# Usage:
#   .ci/scripts/infra/ci-start-elite.sh
#
# Required environment variables (from GitHub secrets):
#   LICENSE_SERVER_API_KEY     - Production license server API key
#   ED25519_PUBLIC_KEY         - Production Ed25519 public key
#
# Outputs (for GitHub Actions):
#   api-url - The base URL for the API (http://localhost)

set -e

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONSOLE_ROOT="$(cd "$SCRIPT_DIR/../../.." && pwd)"
ELITE_DIR="$CONSOLE_ROOT/private/elite"

echo "Starting Rediacc Elite CI services..."

# =============================================================================
# VALIDATE LICENSE SERVER CREDENTIALS (before ci-env.sh may overwrite them)
# =============================================================================
if [[ -z "${LICENSE_SERVER_API_KEY:-}" ]]; then
    echo "ERROR: LICENSE_SERVER_API_KEY is not set"
    echo "This must be configured as a GitHub secret"
    exit 1
fi
if [[ -z "${ED25519_PUBLIC_KEY:-}" ]]; then
    echo "ERROR: ED25519_PUBLIC_KEY is not set"
    echo "This must be configured as a GitHub secret"
    exit 1
fi

# Save production credentials — ci-env.sh would overwrite ED25519_PUBLIC_KEY
# because it regenerates the key pair when ED25519_PRIVATE_KEY is unset
_PROD_LICENSE_SERVER_API_KEY="$LICENSE_SERVER_API_KEY"
_PROD_ED25519_PUBLIC_KEY="$ED25519_PUBLIC_KEY"

# =============================================================================
# SOURCE BASE ENVIRONMENT
# =============================================================================
# ci-env.sh generates passwords, connection strings, image tags, etc.
# It writes .env to .ci/docker/ci/.env — we write a separate one for elite below
# shellcheck source=ci-env.sh
source "$SCRIPT_DIR/ci-env.sh"

# =============================================================================
# OVERRIDE FOR ELITE + CI
# =============================================================================
# Restore production license credentials (overwritten by ci-env.sh key generation)
export LICENSE_SERVER_API_KEY="$_PROD_LICENSE_SERVER_API_KEY"
export ED25519_PUBLIC_KEY="$_PROD_ED25519_PUBLIC_KEY"
# Elite uses the production license server (not a local one)
export LICENSE_SERVER_URL="${LICENSE_SERVER_URL:-https://lic.rediacc.com}"

# CI-specific overrides
export CI_MODE="true"
export DOCKER_BRIDGE_NETWORK_MODE="host"
export DOCKER_BRIDGE_API_URL="http://localhost"
export ENABLE_HTTPS="false"
export HTTP_PORT="80"
export HTTPS_PORT="443"
export SQL_PORT="1433"

# =============================================================================
# WRITE .ENV FOR ELITE DOCKER COMPOSE
# =============================================================================
echo "Writing .env to $ELITE_DIR..."
{
    echo "# Auto-generated by ci-start-elite.sh — do not edit"
    echo "DOCKER_REGISTRY=${DOCKER_REGISTRY}"
    echo "TAG=${TAG}"
    echo "API_TAG=${API_TAG}"
    echo "WEB_TAG=${WEB_TAG}"
    echo "BRIDGE_TAG=${BRIDGE_TAG}"
    echo "DOCKER_BRIDGE_IMAGE=${DOCKER_BRIDGE_IMAGE}"
    echo "DOCKER_INTERNET_NETWORK=rediacc_internet"
    echo "DOCKER_BRIDGE_NETWORK_MODE=${DOCKER_BRIDGE_NETWORK_MODE}"
    echo "DOCKER_BRIDGE_API_URL=${DOCKER_BRIDGE_API_URL}"
    echo "CONNECTION_STRING=${CONNECTION_STRING}"
    echo "MSSQL_SA_PASSWORD=${MSSQL_SA_PASSWORD}"
    echo "MSSQL_RA_PASSWORD=${MSSQL_RA_PASSWORD}"
    echo "REDIACC_DATABASE_NAME=${REDIACC_DATABASE_NAME}"
    echo "REDIACC_SQL_USERNAME=${REDIACC_SQL_USERNAME}"
    echo "SYSTEM_DOMAIN=${SYSTEM_DOMAIN}"
    echo "SYSTEM_ADMIN_EMAIL=${SYSTEM_ADMIN_EMAIL}"
    echo "SYSTEM_ADMIN_PASSWORD=${SYSTEM_ADMIN_PASSWORD}"
    echo "SYSTEM_ORGANIZATION_NAME=${SYSTEM_ORGANIZATION_NAME}"
    echo "SYSTEM_ORGANIZATION_VAULT_DEFAULTS=${SYSTEM_ORGANIZATION_VAULT_DEFAULTS:-}"
    echo "SYSTEM_DEFAULT_BRIDGE_NAME=${SYSTEM_DEFAULT_BRIDGE_NAME}"
    echo "SYSTEM_DEFAULT_REGION_NAME=${SYSTEM_DEFAULT_REGION_NAME}"
    echo "SYSTEM_DEFAULT_TEAM_NAME=${SYSTEM_DEFAULT_TEAM_NAME}"
    echo "CI_MODE=${CI_MODE}"
    echo "LICENSE_SERVER_URL=${LICENSE_SERVER_URL}"
    echo "LICENSE_SERVER_API_KEY=${LICENSE_SERVER_API_KEY}"
    echo "ED25519_PUBLIC_KEY=${ED25519_PUBLIC_KEY}"
    echo "SQL_BASE_IMAGE=mcr.microsoft.com/mssql/server:2022-CU21-ubuntu-22.04"
    echo "HTTP_PORT=${HTTP_PORT}"
    echo "HTTPS_PORT=${HTTPS_PORT}"
    echo "SQL_PORT=${SQL_PORT}"
    echo "ENABLE_HTTPS=${ENABLE_HTTPS}"
} >"$ELITE_DIR/.env"

# =============================================================================
# VERIFY SQLCMD AVAILABILITY
# =============================================================================
if ! command -v sqlcmd &>/dev/null; then
    echo "ERROR: sqlcmd (go-sqlcmd) not found in PATH"
    exit 1
fi

# =============================================================================
# PREPARE MSSQL DIRECTORY
# =============================================================================
MSSQL_DIR="$ELITE_DIR/mssql"
echo "Preparing SQL Server data directory: $MSSQL_DIR"

if [[ -d "$MSSQL_DIR" ]]; then
    sudo rm -rf "$MSSQL_DIR" 2>/dev/null || rm -rf "$MSSQL_DIR" 2>/dev/null || true
fi

mkdir -p "$MSSQL_DIR"
sudo chown -R 10001:10001 "$MSSQL_DIR" 2>/dev/null || {
    chmod -R 777 "$MSSQL_DIR"
}

# =============================================================================
# START ELITE SERVICES
# =============================================================================
echo "Starting Elite Docker Compose services..."
cd "$ELITE_DIR"

docker compose -f docker-compose.yml -f docker-compose.standalone.yml up -d

# =============================================================================
# WAIT FOR HEALTH CHECKS
# =============================================================================
echo "Waiting for Elite services to be ready..."

# Wait for SQL Server (using external go-sqlcmd connection)
wait_for_sql() {
    local timeout=120
    local elapsed=0
    local interval=2
    local sql_port="${SQL_PORT:-1433}"

    echo "  Waiting for SQL Server (via go-sqlcmd on port $sql_port)..."
    while [[ $elapsed -lt $timeout ]]; do
        if SQLCMDPASSWORD="$MSSQL_SA_PASSWORD" sqlcmd \
            -S "localhost,$sql_port" -U sa -Q "SELECT 1" -C &>/dev/null; then
            echo "  SQL Server is ready"
            return 0
        fi
        sleep $interval
        elapsed=$((elapsed + interval))
    done
    echo "  SQL Server failed to start within ${timeout}s"
    return 1
}

# Wait for API
wait_for_api() {
    local timeout=180
    local elapsed=0
    local interval=2

    echo "  Waiting for API..."
    while [[ $elapsed -lt $timeout ]]; do
        if docker inspect rediacc-api --format='{{.State.Health.Status}}' 2>/dev/null | grep -q "healthy"; then
            echo "  API is healthy"
            return 0
        fi
        # Also check if container is running
        if ! docker ps --format "{{.Names}}" | grep -q "^rediacc-api$"; then
            echo "  API container stopped unexpectedly"
            docker logs rediacc-api --tail 50 || true
            return 1
        fi
        sleep $interval
        elapsed=$((elapsed + interval))
        if ((elapsed % 20 == 0)); then
            echo "    Still waiting... (${elapsed}s / ${timeout}s)"
        fi
    done
    echo "  API failed to become healthy within ${timeout}s"
    docker logs rediacc-api --tail 100 || true
    return 1
}

# Wait for Web
wait_for_web() {
    local timeout=60
    local elapsed=0
    local interval=2

    echo "  Waiting for Web (nginx)..."
    while [[ $elapsed -lt $timeout ]]; do
        if curl -sf http://localhost/health &>/dev/null; then
            echo "  Web is ready"
            return 0
        fi
        sleep $interval
        elapsed=$((elapsed + interval))
    done
    echo "  Web failed to start within ${timeout}s"
    return 1
}

# Execute health checks in sequence (no license server — elite uses production)
wait_for_sql || {
    echo "Elite startup failed: SQL Server"
    docker compose -f docker-compose.yml -f docker-compose.standalone.yml logs sql
    exit 1
}

wait_for_api || {
    echo "Elite startup failed: API"
    docker compose -f docker-compose.yml -f docker-compose.standalone.yml logs api
    exit 1
}

wait_for_web || {
    echo "Elite startup failed: Web"
    docker compose -f docker-compose.yml -f docker-compose.standalone.yml logs web
    exit 1
}

echo ""
echo "All Elite services are ready!"

# =============================================================================
# OUTPUT FOR GITHUB ACTIONS
# =============================================================================
if [[ -n "${GITHUB_OUTPUT:-}" ]]; then
    echo "api-url=http://localhost" >>"$GITHUB_OUTPUT"
fi

# Show running containers
echo ""
echo "Running containers:"
docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | grep -E "(NAME|rediacc)" || true
