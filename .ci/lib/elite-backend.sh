#!/bin/bash
# Elite backend management for local development
# Mirrors CI behavior from .github/workflows/ci.yml
#
# ⚠️  IMPORTANT: When adding/modifying backend functions:
# ⚠️  1. Update this file (elite-backend.sh)
# ⚠️  2. Add corresponding commands to the main 'go' script (console/go)
# ⚠️  3. Update documentation (console/docs/BACKEND.md)

# Source constants and utilities
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/../config/constants.sh"
source "$SCRIPT_DIR/../scripts/lib/common.sh"

# =============================================================================
# REPOSITORY MANAGEMENT
# =============================================================================

# Clone elite repository if missing
elite_clone() {
    if [[ -d "$ELITE_LOCAL_PATH/.git" ]]; then
        log_debug "Elite repository already cloned at: $ELITE_LOCAL_PATH"
        return 0
    fi

    log_step "Cloning elite repository"
    log_info "URL: $ELITE_REPO_URL"
    log_info "Path: $ELITE_LOCAL_PATH"

    mkdir -p "$(dirname "$ELITE_LOCAL_PATH")"

    git clone --depth 1 "$ELITE_REPO_URL" "$ELITE_LOCAL_PATH" || {
        log_error "Failed to clone elite repository"
        return 1
    }

    log_info "Elite repository cloned successfully"
}

# Update elite repository (local mode only)
elite_update() {
    if [[ ! -d "$ELITE_LOCAL_PATH/.git" ]]; then
        log_error "Elite repository not found at: $ELITE_LOCAL_PATH"
        return 1
    fi

    log_step "Updating elite repository"
    (cd "$ELITE_LOCAL_PATH" && git pull) || {
        log_error "Failed to update elite repository"
        return 1
    }
}

# =============================================================================
# IMAGE MANAGEMENT
# =============================================================================

# Pull ghcr.io images (mirrors ci-pull-images.sh)
elite_pull_images() {
    check_docker

    log_step "Pulling elite Docker images from ghcr.io"

    # Authenticate with GitHub (if GITHUB_TOKEN set)
    if [[ -n "${GITHUB_TOKEN:-}" ]]; then
        log_debug "Authenticating with ghcr.io"
        echo "$GITHUB_TOKEN" | docker login ghcr.io -u "${GITHUB_USER:-$(whoami)}" --password-stdin &>/dev/null || {
            log_warn "GitHub authentication failed, proceeding without auth"
            log_warn "Set GITHUB_TOKEN environment variable for authentication"
        }
    fi

    # Pull images
    local images=("$ELITE_IMAGE_WEB" "$ELITE_IMAGE_API" "$ELITE_IMAGE_SQL")
    local image

    for image in "${images[@]}"; do
        log_info "Pulling: $image"
        run_with_timeout "$TIMEOUT_DOCKER_PULL" docker pull --quiet "$image" || {
            log_error "Failed to pull image: $image"
            return 1
        }
    done

    log_info "All images pulled successfully"
}

# Build images from source (local mode)
elite_build_images() {
    if [[ ! -d "$ELITE_LOCAL_PATH" ]]; then
        log_error "Elite repository not found at: $ELITE_LOCAL_PATH"
        return 1
    fi

    check_docker

    log_step "Building elite Docker images from source"

    (cd "$ELITE_LOCAL_PATH" && ./go build) || {
        log_error "Failed to build elite images"
        return 1
    }

    log_info "Images built successfully"
}

# =============================================================================
# SERVICE LIFECYCLE
# =============================================================================

# Generate .env file for elite (mirrors ci-env.sh)
elite_generate_env() {
    local mode="$1"

    log_step "Generating elite environment configuration"

    mkdir -p "$ELITE_LOCAL_PATH"

    # Generate random passwords
    local sa_password
    local ra_password
    sa_password=$(openssl rand -base64 20 | tr -d "=+/" | cut -c1-20)
    ra_password=$(openssl rand -base64 20 | tr -d "=+/" | cut -c1-20)

    # Database name with instance
    local db_name="${SQL_DATABASE_PREFIX}_${SQL_INSTANCE_NAME}"
    local sql_user="${SQL_RA_USER_PREFIX}_${SQL_INSTANCE_NAME}"

    cat > "$BACKEND_ENV_FILE" <<EOF
# Generated by console ./go backend setup
# Matches CI configuration from elite/action/ci-env.sh

# Instance Configuration
INSTANCE_NAME=${SQL_INSTANCE_NAME}
BUILD_TYPE=${BUILD_TYPE_DEFAULT}
TAG=${ELITE_TAG}

# Docker Registry
$(if [[ "$mode" == "$BACKEND_MODE_GHCR" ]]; then
    echo "DOCKER_REGISTRY=$ELITE_DOCKER_REGISTRY"
else
    echo "DOCKER_REGISTRY=rediacc"
fi)

# Network Configuration (matches CI)
DOCKER_BRIDGE_NETWORK_MODE=host
DOCKER_BRIDGE_API_URL=http://localhost

# SQL Configuration
MSSQL_SA_PASSWORD=${sa_password}
MSSQL_RA_PASSWORD=${ra_password}
REDIACC_DATABASE_NAME=${db_name}
REDIACC_SQL_USERNAME=${sql_user}

# Connection String
CONNECTION_STRING=Server=localhost,${PORT_SQL};Database=${db_name};User Id=${sql_user};Password=${ra_password};Encrypt=False;TrustServerCertificate=True;MultipleActiveResultSets=True;Connection Timeout=30;Max Pool Size=100;
EOF

    log_info "Environment file created: $BACKEND_ENV_FILE"
}

# Start elite services (mirrors ci-start.sh)
elite_start() {
    local mode="${1:-$BACKEND_MODE_DEFAULT}"

    check_docker

    if [[ ! -d "$ELITE_LOCAL_PATH" ]]; then
        log_error "Elite repository not found. Run: ./go backend setup"
        return 1
    fi

    # Generate .env if missing
    if [[ ! -f "$BACKEND_ENV_FILE" ]]; then
        elite_generate_env "$mode"
    fi

    log_step "Starting elite services"

    # Load environment
    load_env "$BACKEND_ENV_FILE"

    # Start docker-compose (matches CI)
    (cd "$ELITE_LOCAL_PATH" && \
        docker compose -f docker-compose.yml -f docker-compose.standalone.yml up -d) || {
        log_error "Failed to start elite services"
        return 1
    }

    log_info "Elite services started"

    # Save backend state
    echo "mode=$mode" > "$BACKEND_STATE_FILE"
    echo "started=$(date +%s)" >> "$BACKEND_STATE_FILE"
}

# Wait for backend health check (mirrors CI timeout logic)
elite_health() {
    local endpoint="${API_URL_LOCAL}${API_HEALTH_ENDPOINT}"
    local timeout="${API_HEALTH_TIMEOUT}"
    local interval="${API_HEALTH_INTERVAL}"
    local elapsed=0

    log_step "Waiting for backend health check (timeout: ${timeout}s)"

    while [[ $elapsed -lt $timeout ]]; do
        if curl -sf --connect-timeout 2 --max-time 5 "$endpoint" &>/dev/null; then
            log_info "Backend is healthy"
            return 0
        fi

        sleep "$interval"
        elapsed=$((elapsed + interval))

        # Progress indicator
        if (( elapsed % 10 == 0 )); then
            log_debug "Waiting... (${elapsed}s / ${timeout}s)"
        fi
    done

    log_error "Backend health check timed out after ${timeout}s"
    log_info "Check logs with: ./go backend logs"
    return 1
}

# Stop elite services
elite_stop() {
    check_docker

    if [[ ! -d "$ELITE_LOCAL_PATH" ]]; then
        log_warn "Elite repository not found, attempting to stop containers directly"
        docker stop "$ELITE_CONTAINER_WEB" "$ELITE_CONTAINER_API" "$ELITE_CONTAINER_SQL" 2>/dev/null || true
        docker rm "$ELITE_CONTAINER_WEB" "$ELITE_CONTAINER_API" "$ELITE_CONTAINER_SQL" 2>/dev/null || true
        rm -f "$BACKEND_STATE_FILE"
        return 0
    fi

    log_step "Stopping elite services"

    (cd "$ELITE_LOCAL_PATH" && \
        docker compose -f docker-compose.yml -f docker-compose.standalone.yml down) || {
        log_warn "Docker compose down failed, forcing container removal"
        docker stop "$ELITE_CONTAINER_WEB" "$ELITE_CONTAINER_API" "$ELITE_CONTAINER_SQL" 2>/dev/null || true
        docker rm "$ELITE_CONTAINER_WEB" "$ELITE_CONTAINER_API" "$ELITE_CONTAINER_SQL" 2>/dev/null || true
    }

    # Remove state file
    rm -f "$BACKEND_STATE_FILE"

    log_info "Elite services stopped"
}

# Show service logs
elite_logs() {
    local service="${1:-all}"

    check_docker

    case "$service" in
        api)
            docker logs -f "$ELITE_CONTAINER_API"
            ;;
        sql)
            docker logs -f "$ELITE_CONTAINER_SQL"
            ;;
        web)
            docker logs -f "$ELITE_CONTAINER_WEB"
            ;;
        all|"")
            log_info "Showing logs for all services (Ctrl+C to exit)"
            docker logs -f "$ELITE_CONTAINER_API" 2>&1 &
            docker logs -f "$ELITE_CONTAINER_SQL" 2>&1 &
            docker logs -f "$ELITE_CONTAINER_WEB" 2>&1 &
            wait
            ;;
        *)
            log_error "Unknown service: $service"
            log_info "Valid services: api, sql, web, all"
            return 1
            ;;
    esac
}

# Show service status
elite_status() {
    check_docker

    log_info "Elite Backend Status"
    log_info "===================="
    echo ""

    # Check if containers are running
    local running=0
    local containers=("$ELITE_CONTAINER_WEB" "$ELITE_CONTAINER_API" "$ELITE_CONTAINER_SQL")
    local container

    for container in "${containers[@]}"; do
        if docker ps --format "{{.Names}}" | grep -q "^${container}$"; then
            local status
            status=$(docker inspect -f '{{.State.Status}}' "$container")
            local health
            health=$(docker inspect -f '{{.State.Health.Status}}' "$container" 2>/dev/null || echo "N/A")

            echo -e "${COLOR_GREEN}✓${COLOR_NC} $container (status: $status, health: $health)"
            running=$((running + 1))
        else
            echo -e "${COLOR_RED}✗${COLOR_NC} $container (not running)"
        fi
    done

    echo ""

    # Check health endpoint
    if curl -sf "${API_URL_LOCAL}${API_HEALTH_ENDPOINT}" &>/dev/null; then
        echo -e "${COLOR_GREEN}✓${COLOR_NC} API health check: PASSED"
    else
        echo -e "${COLOR_RED}✗${COLOR_NC} API health check: FAILED"
    fi

    echo ""

    # Show backend mode
    if [[ -f "$BACKEND_STATE_FILE" ]]; then
        local mode
        mode=$(grep "^mode=" "$BACKEND_STATE_FILE" | cut -d= -f2)
        echo "Backend mode: $mode"

        local started
        started=$(grep "^started=" "$BACKEND_STATE_FILE" | cut -d= -f2)
        local uptime=$(($(date +%s) - started))
        echo "Uptime: $(printf '%02d:%02d:%02d' $((uptime/3600)) $((uptime%3600/60)) $((uptime%60)))"
    fi
}

# Reset backend (stop, remove volumes, fresh start)
elite_reset() {
    check_docker

    log_warn "This will delete all backend data (SQL database, volumes)"

    if ! prompt_continue "Are you sure"; then
        log_info "Reset cancelled"
        return 0
    fi

    log_step "Resetting backend"

    # Stop services
    elite_stop

    # Remove volumes
    log_info "Removing Docker volumes"
    docker volume rm elite_sql-data 2>/dev/null || true
    docker volume rm elite_api-data 2>/dev/null || true

    # Remove .env to force regeneration
    rm -f "$BACKEND_ENV_FILE"

    log_info "Backend reset complete"
    log_info "Start fresh with: ./go backend start"
}
