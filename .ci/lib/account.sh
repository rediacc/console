#!/bin/bash
# Account service development functions
# Sourced lazily by run.sh when 'account' command is invoked
#
# Provides: account_dev, account_stop, account_test, account_setup

# Prevent re-sourcing
[[ -n "${ACCOUNT_LIB_LOADED:-}" ]] && return 0
readonly ACCOUNT_LIB_LOADED=1

# Source port utilities
source "$CI_LIB_DIR/find-port.sh"

# =============================================================================
# INTERNAL HELPERS
# =============================================================================

ACCOUNT_DIR="$CONSOLE_ROOT_DIR/private/account"
ACCOUNT_PIDS=()

account_cleanup() {
    local exit_code=$?
    for pid in "${ACCOUNT_PIDS[@]}"; do
        kill "$pid" 2>/dev/null || true
        wait "$pid" 2>/dev/null || true
    done
    ACCOUNT_PIDS=()
    exit "$exit_code"
}

# Find 4 consecutive free ports starting from preferred base
account_allocate_ports() {
    local base
    base=$(find_preferred_port "$ACCOUNT_DEV_PORT_PREFERRED" \
        "$ACCOUNT_DEV_PORT_PREFERRED" "$ACCOUNT_DEV_PORT_RANGE_END")

    # Verify next 3 ports are also free; if not, scan for 4 consecutive
    if is_port_in_use $((base + 1)) || is_port_in_use $((base + 2)) || is_port_in_use $((base + 3)); then
        local found=false
        for candidate in $(seq "$ACCOUNT_DEV_PORT_PREFERRED" "$ACCOUNT_DEV_PORT_RANGE_END"); do
            if ! is_port_in_use "$candidate" &&
                ! is_port_in_use $((candidate + 1)) &&
                ! is_port_in_use $((candidate + 2)) &&
                ! is_port_in_use $((candidate + 3)); then
                base=$candidate
                found=true
                break
            fi
        done
        if [[ "$found" != "true" ]]; then
            log_error "Cannot find 4 consecutive free ports in range ${ACCOUNT_DEV_PORT_PREFERRED}-${ACCOUNT_DEV_PORT_RANGE_END}"
            exit 1
        fi
    fi

    GATEWAY_PORT=$base
    VITE_PORT=$((base + 1))
    ASTRO_PORT=$((base + 2))
    S3_BROWSER_PORT=$((base + 3))
    export GATEWAY_PORT VITE_PORT ASTRO_PORT S3_BROWSER_PORT
}

# Wait for a port to become active (max timeout seconds)
account_wait_port() {
    local port="$1"
    local name="$2"
    local timeout="${3:-30}"
    local elapsed=0

    while [[ $elapsed -lt $timeout ]]; do
        if is_port_in_use "$port"; then
            return 0
        fi
        sleep 1
        elapsed=$((elapsed + 1))
    done

    log_error "$name failed to start on port $port within ${timeout}s"
    log_info "Check logs: $ACCOUNT_LOG_DIR/"
    return 1
}

# =============================================================================
# ENSURE .ENV
# =============================================================================

account_ensure_env() {
    if [[ -f "$ACCOUNT_DIR/.env" ]]; then
        log_debug "Account .env already exists" 2>/dev/null || true
        return 0
    fi

    log_step "Generating account .env..."

    # Generate Ed25519 key pair using Node.js crypto
    local keys
    keys=$(node --eval "
        const crypto = require('crypto');
        const { privateKey, publicKey } = crypto.generateKeyPairSync('ed25519');
        const priv = privateKey.export({ type: 'pkcs8', format: 'der' }).toString('base64');
        const pub = publicKey.export({ type: 'spki', format: 'der' }).toString('base64');
        process.stdout.write(priv + '\n' + pub);
    ")
    local private_key
    private_key=$(echo "$keys" | head -1)
    local public_key
    public_key=$(echo "$keys" | tail -1)

    # Generate random secrets
    local jwt_secret
    jwt_secret=$(openssl rand -base64 48 | tr -d '/+=' | cut -c1-64)
    local api_key
    api_key=$(openssl rand -base64 48 | tr -d '/+=' | cut -c1-64)

    cat >"$ACCOUNT_DIR/.env" <<EOF
# Auto-generated by ./run.sh account setup — $(date -u +%Y-%m-%dT%H:%M:%SZ)

# Account server URL (used by rdc CLI for subscription commands)
# Updated automatically by dev-gateway on startup with the actual port
REDIACC_ACCOUNT_SERVER=http://localhost:4800

# S3-compatible storage (RustFS)
S3_ENDPOINT=http://localhost:9000
S3_BUCKET=subscriptions
S3_ACCESS_KEY_ID=rustfsadmin
S3_SECRET_ACCESS_KEY=rustfsadmin
S3_REGION=us-east-1

# Ed25519 key pair (for subscription/license signing)
ED25519_PRIVATE_KEY=${private_key}
ED25519_PUBLIC_KEY=${public_key}

# Admin API key
API_KEY=${api_key}

# JWT secret for session tokens
JWT_SECRET=${jwt_secret}

# Stripe sandbox (uncomment and fill to enable Stripe features)
# STRIPE_SANDBOX_SECRET_KEY=sk_test_...
# STRIPE_SANDBOX_WEBHOOK_SECRET is auto-captured from stripe listen

# Fixed webhook secret for E2E webhook simulation tests
STRIPE_WEBHOOK_SECRET=whsec_e2e_test_webhook_secret_for_simulation_only

# Admin email (receives alerts for disputes, refunds, etc.)
ADMIN_EMAIL=admin@example.com

# Server port (used by standalone node entry, not the dev gateway)
PORT=3000
EOF

    log_info "Generated private/account/.env with fresh keys"
}

# =============================================================================
# ENSURE RUSTFS
# =============================================================================

account_ensure_rustfs() {
    # Check if S3 storage is already reachable on port 9000 (from any source)
    if curl -sf --connect-timeout 2 --max-time 3 http://localhost:9000/health &>/dev/null; then
        log_info "S3 storage already available on port 9000"
        return 0
    fi

    log_step "Starting RustFS (S3-compatible storage)..."

    # Start RustFS and its init containers. Use --wait only on rustfs itself
    # (init containers are one-shot and exit after completing).
    (cd "$ACCOUNT_DIR" && docker compose up -d rustfs rustfs-volume-init rustfs-init) || {
        log_error "Failed to start RustFS containers"
        return 1
    }

    # Wait for RustFS to become healthy
    local elapsed=0
    while [[ $elapsed -lt 60 ]]; do
        if curl -sf --connect-timeout 2 --max-time 3 http://localhost:9000/health &>/dev/null; then
            log_info "RustFS started on port 9000"

            # Wait briefly for bucket init to complete
            sleep 2
            return 0
        fi
        sleep 2
        elapsed=$((elapsed + 2))
    done

    log_error "RustFS failed to become healthy within 60s"
    return 1
}

# =============================================================================
# ENSURE S3 BROWSER
# =============================================================================

account_ensure_s3_browser() {
    log_step "Starting S3 browser on :${S3_BROWSER_PORT}..."
    (cd "$ACCOUNT_DIR" && S3_BROWSER_PORT="$S3_BROWSER_PORT" docker compose up -d s3-browser) 2>&1 | tail -1 || {
        log_warn "S3 browser failed to start (non-critical, continuing)"
        return 0
    }

    log_info "S3 browser available at http://localhost:${S3_BROWSER_PORT}"
}

# =============================================================================
# RESET S3 DATA
# =============================================================================

account_reset_data() {
    local endpoint="http://localhost:9000"
    local bucket="subscriptions"

    # Check if S3 is reachable
    if ! curl -sf --connect-timeout 2 --max-time 3 "$endpoint/health" &>/dev/null; then
        log_debug "S3 not reachable, nothing to reset" 2>/dev/null || true
        return 0
    fi

    log_step "Resetting S3 data (bucket: $bucket)..."

    # List and delete all objects using aws CLI from docker
    # This is faster than listing+deleting individually and handles pagination
    docker run --rm --network host \
        -e AWS_ACCESS_KEY_ID=rustfsadmin \
        -e AWS_SECRET_ACCESS_KEY=rustfsadmin \
        amazon/aws-cli:latest \
        s3 rm "s3://$bucket" --recursive \
        --endpoint-url "$endpoint" \
        --region us-east-1 2>&1 | tail -1 || true

    log_info "S3 data cleared"
}

# =============================================================================
# STRIPE AUTO-SETUP
# =============================================================================

account_stripe_auto() {
    local stripe_key="${STRIPE_SANDBOX_SECRET_KEY:-}"
    if [[ -z "$stripe_key" ]]; then
        return 0
    fi

    # Check stripe CLI
    if ! command -v stripe &>/dev/null; then
        log_warn "STRIPE_SANDBOX_SECRET_KEY is set but stripe CLI not found"
        log_info "Install from: https://docs.stripe.com/stripe-cli"
        log_info "Continuing without webhook forwarding"
        return 0
    fi

    log_step "Setting up Stripe sandbox..."

    # Kill any orphaned stripe listen forwarding to this worktree's gateway port.
    # This handles cases where a previous session crashed without cleanup.
    local stale_pids
    stale_pids=$(pgrep -f "stripe listen.*--forward-to http://localhost:${GATEWAY_PORT}/" 2>/dev/null || true)
    if [[ -n "$stale_pids" ]]; then
        log_info "Cleaning up stale stripe listen (PIDs: $stale_pids)"
        echo "$stale_pids" | xargs kill 2>/dev/null || true
        sleep 1
    fi

    # Sync products/prices (idempotent)
    log_info "Syncing Stripe products/prices..."
    (cd "$ACCOUNT_DIR" && STRIPE_SECRET_KEY="$stripe_key" npx tsx scripts/stripe-sync.ts 2>&1 | tail -5)

    # Start stripe listen in background
    local stripe_log
    stripe_log=$(mktemp)

    stripe listen \
        --api-key "$stripe_key" \
        --forward-to "http://localhost:${GATEWAY_PORT}/account/api/v1/webhooks/stripe" \
        >"$stripe_log" 2>&1 &
    local stripe_pid=$!
    ACCOUNT_PIDS+=("$stripe_pid")

    # Wait for webhook secret
    local webhook_secret=""
    local elapsed=0
    while [[ $elapsed -lt 30 ]]; do
        webhook_secret=$(grep -oP 'whsec_\S+' "$stripe_log" 2>/dev/null || true)
        if [[ -n "$webhook_secret" ]]; then
            break
        fi
        sleep 1
        elapsed=$((elapsed + 1))
    done
    rm -f "$stripe_log"

    if [[ -z "$webhook_secret" ]]; then
        log_warn "stripe listen did not output webhook secret within 30s"
        log_info "Stripe features may not work — check stripe CLI auth"
        return 0
    fi

    export STRIPE_SANDBOX_WEBHOOK_SECRET="$webhook_secret"
    log_info "Stripe webhook forwarding active (secret: ${webhook_secret:0:12}...)"
}

# =============================================================================
# PUBLIC COMMANDS
# =============================================================================

account_dev() {
    check_node_version
    check_docker

    log_step "Starting account development environment"

    # Allocate dynamic ports
    account_allocate_ports
    log_info "Ports: gateway=$GATEWAY_PORT vite=$VITE_PORT astro=$ASTRO_PORT s3-browser=$S3_BROWSER_PORT"

    # Infrastructure
    account_ensure_rustfs
    account_ensure_s3_browser
    account_reset_data
    account_ensure_env

    # Load environment
    set -a
    source "$ACCOUNT_DIR/.env"
    set +a

    # Dependencies
    ensure_deps

    # Install account + web deps if needed
    if [[ ! -d "$ACCOUNT_DIR/node_modules" ]] ||
        [[ "$ACCOUNT_DIR/package-lock.json" -nt "$ACCOUNT_DIR/node_modules" ]]; then
        log_step "Installing account dependencies..."
        (cd "$ACCOUNT_DIR" && npm install --prefer-offline --no-audit --no-fund 2>&1 | tail -1)
    fi

    if [[ ! -d "$ACCOUNT_DIR/web/node_modules" ]] ||
        [[ "$ACCOUNT_DIR/web/package-lock.json" -nt "$ACCOUNT_DIR/web/node_modules" ]]; then
        log_step "Installing account web dependencies..."
        (cd "$ACCOUNT_DIR/web" && npm install --prefer-offline --no-audit --no-fund 2>&1 | tail -1)
    fi

    # Ensure shared packages are built (account depends on @rediacc/shared)
    ensure_packages_built

    # Setup cleanup trap
    trap account_cleanup EXIT INT TERM

    # Create log directory
    mkdir -p "$ACCOUNT_LOG_DIR"

    # Start Astro dev server (marketing site)
    log_step "Starting Astro dev server on :${ASTRO_PORT}..."
    (cd "$CONSOLE_ROOT_DIR/packages/www" && npx astro dev --port "$ASTRO_PORT" --host 127.0.0.1) \
        >"$ACCOUNT_LOG_DIR/astro.log" 2>&1 &
    ACCOUNT_PIDS+=($!)

    # Start Vite dev server (account portal SPA)
    log_step "Starting Vite dev server on :${VITE_PORT}..."
    (cd "$ACCOUNT_DIR/web" && npx vite --port "$VITE_PORT" --host 127.0.0.1) \
        >"$ACCOUNT_LOG_DIR/vite.log" 2>&1 &
    ACCOUNT_PIDS+=($!)

    # Wait for both to be ready
    account_wait_port "$ASTRO_PORT" "Astro" 30 || exit 1
    account_wait_port "$VITE_PORT" "Vite" 30 || exit 1

    # Auto-setup Stripe if key is configured
    account_stripe_auto

    # Start gateway (foreground — keeps terminal alive)
    log_step "Starting dev gateway on :${GATEWAY_PORT}..."
    GATEWAY_PORT=$GATEWAY_PORT \
        VITE_PORT=$VITE_PORT \
        ASTRO_PORT=$ASTRO_PORT \
        S3_BROWSER_PORT="${S3_BROWSER_PORT:-9090}" \
        npx tsx "$ACCOUNT_DIR/src/entry/dev-gateway.ts"
}

account_stop() {
    log_step "Stopping account containers"
    (cd "$ACCOUNT_DIR" && docker compose down --remove-orphans) 2>/dev/null || true

    # Force remove if still around
    for container in account-server account-rustfs account-rustfs-init account-rustfs-volume-init; do
        if docker ps -a --format "{{.Names}}" 2>/dev/null | grep -q "^${container}$"; then
            docker stop "$container" 2>/dev/null || true
            docker rm "$container" 2>/dev/null || true
        fi
    done

    # Stop any dynamically-named S3 browser containers
    for container in $(docker ps -a --format "{{.Names}}" 2>/dev/null | grep "^account-s3-browser-"); do
        docker stop "$container" 2>/dev/null || true
        docker rm "$container" 2>/dev/null || true
    done

    rm -f "$ACCOUNT_STATE_FILE"
    log_info "Account containers stopped"
}

account_test() {
    check_node_version

    # Use the test docker-compose (port 9100)
    local test_compose="$ACCOUNT_DIR/tests/integration/setup/docker-compose.test.yml"

    if ! docker ps --format "{{.Names}}" 2>/dev/null | grep -q "^license-test-rustfs$"; then
        log_step "Starting test RustFS..."
        docker compose -f "$test_compose" up -d --wait || {
            log_error "Failed to start test RustFS"
            exit 1
        }
    fi

    ensure_packages_built

    log_step "Running account tests"
    (cd "$ACCOUNT_DIR" && npx vitest run "$@")
}

account_test_e2e() {
    check_node_version

    # Load backend .env to extract secrets for E2E tests
    local account_env="$ACCOUNT_DIR/.env"
    if [[ ! -f "$account_env" ]]; then
        log_error "Account .env not found. Run: ./run.sh account setup"
        exit 1
    fi

    set -a
    source "$account_env"
    set +a

    # Check dev gateway is running
    local gateway_port="${GATEWAY_PORT:-}"
    if [[ -z "$gateway_port" ]]; then
        # Try to detect from REDIACC_ACCOUNT_SERVER
        gateway_port=$(echo "${REDIACC_ACCOUNT_SERVER:-}" | grep -oP ':\K[0-9]+' || echo "")
    fi

    if [[ -z "$gateway_port" ]]; then
        log_error "Cannot determine gateway port"
        log_info "Start the dev gateway first: ./run.sh account dev"
        exit 1
    fi

    if ! is_port_in_use "$gateway_port"; then
        log_error "Dev gateway not running on port $gateway_port"
        log_info "Start it first: ./run.sh account dev"
        exit 1
    fi

    # Wire backend secrets → E2E env vars
    export E2E_PORT="$gateway_port"
    export E2E_BASE_URL="http://localhost:${gateway_port}/account/"
    export ADMIN_EMAIL="${ADMIN_EMAIL:-}"

    # Webhook simulation secret (matches backend's STRIPE_WEBHOOK_SECRET)
    if [[ -n "${STRIPE_WEBHOOK_SECRET:-}" ]]; then
        export E2E_WEBHOOK_SECRET="$STRIPE_WEBHOOK_SECRET"
        log_info "Webhook simulation: enabled (STRIPE_WEBHOOK_SECRET)"
    else
        log_warn "Webhook simulation: disabled (STRIPE_WEBHOOK_SECRET not set)"
    fi

    # Stripe sandbox key (for real Stripe E2E tests)
    if [[ -n "${STRIPE_SANDBOX_SECRET_KEY:-}" ]]; then
        export STRIPE_SANDBOX_SECRET_KEY
        log_info "Stripe sandbox E2E: enabled"
    else
        log_warn "Stripe sandbox E2E: disabled (STRIPE_SANDBOX_SECRET_KEY not set)"
    fi

    ensure_packages_built

    # Install E2E deps if needed
    local e2e_dir="$ACCOUNT_DIR/e2e"
    if [[ ! -d "$e2e_dir/node_modules" ]] ||
        [[ "$e2e_dir/package-lock.json" -nt "$e2e_dir/node_modules" ]]; then
        log_step "Installing E2E dependencies..."
        (cd "$e2e_dir" && npm install --prefer-offline --no-audit --no-fund 2>&1 | tail -1)
    fi

    log_step "Running account E2E tests (gateway on :${gateway_port})"
    (cd "$e2e_dir" && npx playwright test --project=chromium --reporter=list "$@")
}

account_setup() {
    check_node_version
    check_docker

    log_step "Account development setup"

    account_ensure_env
    account_ensure_rustfs

    echo ""
    log_info "Account setup complete!"
    log_info ""
    log_info "Start dev server with: ./run.sh account dev"
    log_info ""
    log_info "For Stripe sandbox, add to private/account/.env:"
    log_info "  STRIPE_SANDBOX_SECRET_KEY=sk_test_..."
}
