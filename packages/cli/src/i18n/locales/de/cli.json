{
  "cli": {
    "description": "Rediacc CLI - Befehlszeilenschnittstelle für Rediacc-Operationen"
  },
  "commands": {
    "audit": {
      "description": "Audit-Log-Befehle",
      "history": {
        "description": "Entitätsverlauf anzeigen",
        "fetching": "Entitätsverlauf wird abgerufen...",
        "success": "Verlauf abgerufen"
      },
      "list": {
        "description": "Audit-Log-Einträge auflisten",
        "fetching": "Audit-Logs werden abgerufen..."
      },
      "log": {
        "description": "Audit-Logs anzeigen",
        "fetching": "Audit-Logs werden abgerufen...",
        "success": "Audit-Logs abgerufen"
      },
      "trace": {
        "description": "Audit-Verlauf für eine Entität nachverfolgen",
        "fetching": "Entity-Audit-Verlauf wird abgerufen...",
        "success": "Audit-Verlauf abgerufen"
      }
    },
    "auth": {
      "activate": {
        "activated": "Konto aktiviert",
        "activating": "Konto wird aktiviert...",
        "description": "Konto mit Verifizierungscode aktivieren",
        "success": "Konto aktiviert! Sie können sich jetzt anmelden mit: rdc auth login"
      },
      "description": "Authentifizierungsbefehle",
      "login": {
        "authenticating": "Authentifizierung läuft...",
        "description": "Mit Rediacc authentifizieren",
        "success": "Anmeldung erfolgreich! Gespeichert im Kontext \"{{context}}\"",
        "tfaPrompt": "2FA-Code eingeben:",
        "tfaRequired": "Zwei-Faktor-Authentifizierung erforderlich",
        "tfaVerified": "2FA erfolgreich verifiziert",
        "verifyingTfa": "2FA wird überprüft..."
      },
      "logout": {
        "description": "Gespeicherte Anmeldedaten löschen",
        "loggingOut": "Meldung läuft...",
        "success": "Erfolgreich abgemeldet"
      },
      "register": {
        "description": "Ein neues Organisationskonto und Benutzerkonto registrieren",
        "nextStep": "Führen Sie dann aus: rdc auth activate -e <email> -p <password> --code <code>",
        "registering": "Konto wird registriert...",
        "submitted": "Registrierung eingereicht",
        "success": "Registrierung erfolgreich! Überprüfen Sie Ihre E-Mail auf den Aktivierungscode."
      },
      "status": {
        "authenticated": "Authentifiziert als: {{email}}",
        "description": "Aktuellen Authentifizierungsstatus prüfen",
        "notAuthenticated": "Nicht authentifiziert. Ausführen: rdc auth login"
      },
      "tfa": {
        "description": "Zwei-Faktor-Authentifizierung-Verwaltung",
        "disable": {
          "confirm": "Möchten Sie 2FA wirklich deaktivieren?",
          "description": "Zwei-Faktor-Authentifizierung deaktivieren",
          "disabling": "2FA wird deaktiviert...",
          "success": "2FA erfolgreich deaktiviert"
        },
        "enable": {
          "addToApp": "Fügen Sie dies zu Ihrer Authenticator-App hinzu",
          "description": "Zwei-Faktor-Authentifizierung aktivieren",
          "enabling": "2FA wird aktiviert...",
          "initiated": "2FA-Setup initiiert",
          "setupKey": "Setup-Schlüssel: {{key}}",
          "success": "2FA erfolgreich aktiviert"
        },
        "status": {
          "description": "2FA-Status prüfen",
          "disabled": "2FA ist nicht aktiviert",
          "enabled": "2FA ist aktiviert"
        }
      },
      "token": {
        "description": "Token-Verwaltung",
        "fork": {
          "creating": "Fork-Token wird erstellt...",
          "description": "Erstellen Sie einen Fork-Token für eine andere Anwendung",
          "success": "Token erfolgreich erstellt",
          "tokenValue": "Token: {{token}}"
        },
        "list": {
          "description": "Aktive Tokens/Sitzungen auflisten",
          "fetching": "Tokens werden abgerufen...",
          "noTokens": "Keine aktiven Tokens"
        },
        "revoke": {
          "description": "Ein bestimmtes Token widerrufen",
          "revoking": "Token wird widerrufen...",
          "success": "Token erfolgreich widerrufen"
        }
      }
    },
    "backup": {
      "description": "Repositories sichern und wiederherstellen",
      "list": {
        "description": "Verfügbare Backups auf Speicher oder Rechner auflisten",
        "listing": "Backups werden aufgelistet...",
        "optionFromMachine": "Name des Quellrechners",
        "optionFromStorage": "Name des Quellspeichers",
        "sourceRequired": "Geben Sie --from <storage> oder --from-machine <machine> an"
      },
      "pull": {
        "description": "Repository-Backup von Speicher oder Rechner abrufen",
        "optionForce": "Vorhandenes Repository überschreiben erzwingen",
        "optionFromMachine": "Name des Quellrechners",
        "optionFromStorage": "Name des Quellspeichers",
        "pulling": "Backup von \"{{repo}}\" wird abgerufen...",
        "sourceRequired": "Geben Sie --from <storage> oder --from-machine <machine> an"
      },
      "push": {
        "description": "Repository-Backup auf Speicher oder Rechner übertragen",
        "destIgnoredForStorage": "--dest {{provided}} ignoriert: Speicher-Backups verwenden Repository-GUID ({{dest}})",
        "destRequired": "Geben Sie --to <storage> oder --to-machine <machine> an",
        "optionCheckpoint": "Container-Checkpoint erstellen (Hot Backup)",
        "optionDest": "Zieldateiname",
        "optionForce": "Vorhandenes Backup überschreiben erzwingen",
        "optionTag": "Deployment-Tag für Versionierung",
        "optionToMachine": "Name des Zielrechners",
        "optionToStorage": "Name des Zielspeichers",
        "pushing": "Backup von \"{{repo}}\" wird nach {{dest}} übertragen..."
      },
      "schedule": {
        "description": "Konfiguration geplanter Backups verwalten",
        "push": {
          "description": "Backup-Zeitplan auf Remote-Rechner übertragen (systemd-Timer)",
          "success": "Backup-Zeitplan an {{machine}} übertragen"
        },
        "set": {
          "description": "Backup-Zeitplan-Einstellungen konfigurieren",
          "noOptions": "Geben Sie mindestens eine Option an: --destination, --cron, --enable oder --disable",
          "optionCron": "Cron-Ausdruck für den Backup-Zeitplan (z.B. \"0 2 * * *\")",
          "optionDestination": "Standard-Speicherzielname",
          "optionDisable": "Geplante Backups deaktivieren",
          "optionEnable": "Geplante Backups aktivieren",
          "saved": "Backup-Zeitplan-Konfiguration gespeichert"
        },
        "show": {
          "description": "Aktuelle Backup-Zeitplan-Konfiguration anzeigen",
          "destination": "Ziel: {{destination}}",
          "enabled": "Aktiviert: {{enabled}}",
          "notConfigured": "Kein Backup-Zeitplan konfiguriert",
          "schedule": "Zeitplan: {{schedule}}"
        }
      },
      "sync": {
        "description": "Alle Repositories massenhaft zum/vom Cloud-Speicher übertragen",
        "directionConflict": "--to und --from können nicht gleichzeitig angegeben werden",
        "directionRequired": "Geben Sie --to <storage> (Push) oder --from <storage> (Pull) an",
        "optionFrom": "Name des Quellspeichers (Pull-Modus)",
        "optionOverride": "Vorhandene nicht eingehängte Repos beim Pull überschreiben",
        "optionRepo": "Auf bestimmtes Repository filtern (wiederholbar)",
        "optionTo": "Name des Zielspeichers (Push-Modus)",
        "pullSuccess": "Synchronisierungs-Pull abgeschlossen",
        "pushSuccess": "Synchronisierungs-Push abgeschlossen"
      }
    },
    "bridge": {
      "description": "Bridge-Verwaltung",
      "list": {
        "description": "Bridges auflisten",
        "fetching": "Bridges werden abgerufen..."
      },
      "resetAuth": {
        "description": "Bridge-Autorisierungstoken zurücksetzen",
        "newToken": "Neues Token: {{token}}",
        "resetting": "Autorisierung für Bridge \"{{name}}\" wird zurückgesetzt...",
        "success": "Autorisierung zurückgesetzt"
      }
    },
    "ceph": {
      "clone": {
        "assign": {
          "assigning": "Maschinen werden Klon \"{{name}}\" zugewiesen...",
          "description": "Maschinen einem Klon zuweisen",
          "success": "Maschinen Klon \"{{name}}\" zugewiesen"
        },
        "create": {
          "creating": "RBD-Klon \"{{name}}\" wird erstellt...",
          "description": "Neuen RBD-Klon aus Snapshot erstellen",
          "success": "RBD-Klon \"{{name}}\" erstellt"
        },
        "delete": {
          "confirm": "RBD-Klon \"{{name}}\" löschen?",
          "deleting": "RBD-Klon \"{{name}}\" wird gelöscht...",
          "description": "RBD-Klon löschen",
          "success": "RBD-Klon \"{{name}}\" gelöscht"
        },
        "description": "Ceph RBD-Klon-Verwaltung",
        "list": {
          "description": "RBD-Klone auflisten",
          "fetching": "RBD-Klone werden abgerufen...",
          "success": "Klone abgerufen"
        },
        "machines": {
          "description": "Einem Klon zugewiesene Maschinen auflisten",
          "fetching": "Klon-Maschinen werden abgerufen...",
          "success": "Klon-Maschinen abgerufen"
        },
        "unassign": {
          "description": "Maschinen von einem Klon entfernen",
          "success": "Maschinen von Klon \"{{name}}\" entfernt",
          "unassigning": "Maschinen werden von Klon \"{{name}}\" entfernt..."
        }
      },
      "cluster": {
        "create": {
          "creating": "Ceph-Cluster \"{{name}}\" wird erstellt...",
          "description": "Neuen Ceph-Cluster erstellen",
          "success": "Ceph-Cluster \"{{name}}\" erstellt"
        },
        "delete": {
          "confirm": "Ceph-Cluster \"{{name}}\" löschen?",
          "deleting": "Ceph-Cluster \"{{name}}\" wird gelöscht...",
          "description": "Ceph-Cluster löschen",
          "success": "Ceph-Cluster \"{{name}}\" gelöscht"
        },
        "description": "Ceph-Cluster-Verwaltung",
        "list": {
          "description": "Ceph-Cluster auflisten",
          "fetching": "Ceph-Cluster werden abgerufen...",
          "success": "Cluster abgerufen"
        },
        "machines": {
          "description": "Maschinen in einem Ceph-Cluster auflisten",
          "fetching": "Cluster-Maschinen werden abgerufen...",
          "success": "Cluster-Maschinen abgerufen"
        },
        "vault": {
          "description": "Ceph-Cluster-Tresor-Verwaltung",
          "get": {
            "description": "Cluster-Tresor-Daten abrufen",
            "fetching": "Cluster-Tresor wird abgerufen...",
            "success": "Cluster-Tresor abgerufen"
          },
          "update": {
            "description": "Cluster-Tresor-Daten aktualisieren",
            "success": "Cluster-Tresor für \"{{name}}\" aktualisiert",
            "updating": "Cluster-Tresor für \"{{name}}\" wird aktualisiert..."
          }
        }
      },
      "description": "Ceph verteilte Speicherverwaltung",
      "image": {
        "create": {
          "creating": "RBD-Image \"{{name}}\" wird erstellt...",
          "description": "Neues RBD-Image erstellen",
          "success": "RBD-Image \"{{name}}\" erstellt"
        },
        "delete": {
          "confirm": "RBD-Image \"{{name}}\" löschen?",
          "deleting": "RBD-Image \"{{name}}\" wird gelöscht...",
          "description": "RBD-Image löschen",
          "success": "RBD-Image \"{{name}}\" gelöscht"
        },
        "description": "Ceph RBD-Image-Verwaltung",
        "list": {
          "description": "RBD-Images auflisten",
          "fetching": "RBD-Images werden abgerufen...",
          "success": "Images abgerufen"
        }
      },
      "pool": {
        "create": {
          "creating": "Ceph-Pool \"{{name}}\" wird erstellt...",
          "description": "Neuen Ceph-Pool erstellen",
          "success": "Ceph-Pool \"{{name}}\" erstellt"
        },
        "delete": {
          "confirm": "Ceph-Pool \"{{name}}\" löschen?",
          "deleting": "Ceph-Pool \"{{name}}\" wird gelöscht...",
          "description": "Ceph-Pool löschen",
          "success": "Ceph-Pool \"{{name}}\" gelöscht"
        },
        "description": "Ceph-Pool-Verwaltung",
        "list": {
          "description": "Ceph-Pools auflisten",
          "fetching": "Ceph-Pools werden abgerufen...",
          "success": "Pools abgerufen"
        },
        "vault": {
          "description": "Ceph-Pool-Tresor-Verwaltung",
          "get": {
            "description": "Pool-Tresor-Daten abrufen",
            "fetching": "Pool-Tresor wird abgerufen...",
            "success": "Pool-Tresor abgerufen"
          },
          "update": {
            "description": "Pool-Tresor-Daten aktualisieren",
            "success": "Pool-Tresor für \"{{name}}\" aktualisiert",
            "updating": "Pool-Tresor für \"{{name}}\" wird aktualisiert..."
          }
        }
      },
      "snapshot": {
        "create": {
          "creating": "RBD-Snapshot \"{{name}}\" wird erstellt...",
          "description": "Neuen RBD-Snapshot erstellen",
          "success": "RBD-Snapshot \"{{name}}\" erstellt"
        },
        "delete": {
          "confirm": "RBD-Snapshot \"{{name}}\" löschen?",
          "deleting": "RBD-Snapshot \"{{name}}\" wird gelöscht...",
          "description": "RBD-Snapshot löschen",
          "success": "RBD-Snapshot \"{{name}}\" gelöscht"
        },
        "description": "Ceph RBD-Snapshot-Verwaltung",
        "list": {
          "description": "RBD-Snapshots auflisten",
          "fetching": "RBD-Snapshots werden abgerufen...",
          "success": "Snapshots abgerufen"
        }
      }
    },
    "config": {
      "addMachine": {
        "description": "Eine Machine zur aktuellen Konfiguration hinzufügen",
        "success": "Machine \"{{name}}\" hinzugefügt ({{user}}@{{ip}})"
      },
      "addRepository": {
        "description": "Eine Repository-GUID-Zuordnung zur aktuellen Konfiguration hinzufügen",
        "networkIdAssigned": "Netzwerk-ID: {{networkId}}",
        "optionCredential": "Repository-Anmeldedaten (Verschlüsselungs-Passphrase)",
        "optionGuid": "Repository-GUID (UUID aus Speicher-Backup-Dateinamen)",
        "optionNetworkId": "Netzwerk-ID für Docker-Isolation (2816, 2880, ...). Wird automatisch vergeben, wenn nicht angegeben",
        "optionTag": "Repository-Tag",
        "success": "Repository \"{{name}}\" hinzugefügt ({{guid}}, Tag: {{tag}})"
      },
      "clear": {
        "allCleared": "Alle Standardwerte gelöscht",
        "description": "Standardwerte löschen (alle oder einen bestimmten Schlüssel)",
        "keyCleared": "\"{{key}}\" gelöscht"
      },
      "recover": {
        "description": "Konfiguration aus Sicherungsdatei (.bak) wiederherstellen",
        "noBackup": "Keine Sicherung für Konfiguration \"{{name}}\" gefunden",
        "confirm": "Konfiguration \"{{name}}\" aus Sicherung wiederherstellen?",
        "success": "Konfiguration \"{{name}}\" aus Sicherung wiederhergestellt (Version {{version}})",
        "failed": "Wiederherstellung der Konfiguration \"{{name}}\" aus Sicherung fehlgeschlagen"
      },
      "delete": {
        "description": "Eine Konfigurationsdatei löschen",
        "success": "Konfiguration \"{{name}}\" gelöscht"
      },
      "description": "CLI-Konfigurationsdateien verwalten",
      "importStorage": {
        "description": "Speicher aus einer rclone-Konfigurationsdatei importieren",
        "imported": "Speicher \"{{name}}\" importiert ({{type}})",
        "noConfigs": "Keine gültigen Speicherkonfigurationen in der Datei gefunden",
        "notFound": "Speicher \"{{name}}\" nicht in der Konfigurationsdatei gefunden",
        "optionName": "Nur diesen benannten Abschnitt importieren",
        "summary": "{{count}} Speicher importiert",
        "unsupported": "\"{{name}}\" wird übersprungen: nicht unterstützter Anbietertyp \"{{type}}\""
      },
      "init": {
        "alreadyExists": "Konfiguration \"{{name}}\" existiert bereits",
        "description": "Eine neue Konfigurationsdatei initialisieren",
        "optionMasterPassword": "Ressourcen mit einem Master-Passwort verschlüsseln",
        "optionS3AccessKeyId": "S3 Access Key ID",
        "optionS3Bucket": "S3-Bucket-Name",
        "optionS3Endpoint": "S3-Endpunkt-URL",
        "optionS3Prefix": "Schlüsselpräfix im S3-Bucket",
        "optionS3Region": "S3-Region",
        "optionS3SecretAccessKey": "S3 Secret Access Key",
        "promptS3SecretAccessKey": "S3 Secret Access Key:",
        "s3Required": "--s3-endpoint, --s3-bucket und --s3-access-key-id sind für den S3-Ressourcenstatus erforderlich",
        "s3SecretRequired": "S3 Secret Access Key ist erforderlich",
        "s3Verified": "S3-Zugriff verifiziert",
        "success": "Konfiguration \"{{name}}\" initialisiert",
        "verifyingS3": "S3-Zugriff wird überprüft..."
      },
      "list": {
        "description": "Alle Konfigurationsdateien auflisten",
        "noConfigs": "Keine Konfigurationsdateien gefunden. Erstellen Sie eine mit: rdc config init"
      },
      "machines": {
        "description": "Machines in der aktuellen Konfiguration auflisten",
        "noMachines": "Keine Machines konfiguriert. Fügen Sie eine hinzu mit: rdc config add-machine <name> --ip <ip> --user <user>"
      },
      "pushInfra": {
        "description": "Infrastrukturkonfiguration auf Remote-Machine übertragen",
        "installingProxy": "Proxy wird installiert und gestartet...",
        "proxyInstallWarning": "Proxy-Installation fehlgeschlagen (Code {{code}}). Manuell ausführen: sudo renet proxy install",
        "success": "Infrastrukturkonfiguration an \"{{name}}\" übertragen"
      },
      "removeMachine": {
        "description": "Eine Machine aus der aktuellen Konfiguration entfernen",
        "success": "Machine \"{{name}}\" entfernt"
      },
      "removeRepository": {
        "description": "Eine Repository-Zuordnung aus der aktuellen Konfiguration entfernen",
        "success": "Repository \"{{name}}\" entfernt"
      },
      "removeStorage": {
        "description": "Einen Speicher aus der aktuellen Konfiguration entfernen",
        "success": "Speicher \"{{name}}\" entfernt"
      },
      "repositories": {
        "description": "Repository-GUID-Zuordnungen in der aktuellen Konfiguration auflisten",
        "noRepositories": "Keine Repositories konfiguriert. Fügen Sie eines hinzu mit: rdc config add-repository <name> --guid <guid>"
      },
      "scanKeys": {
        "completed": "{{count}}/{{total}} Machines gescannt",
        "description": "SSH-Host-Schlüssel für Machines in der aktuellen Konfiguration scannen",
        "keysScanned": "Host-Schlüssel für \"{{name}}\" gescannt",
        "noKeys": "Host-Schlüssel für \"{{name}}\" konnten nicht gescannt werden"
      },
      "set": {
        "description": "Einen Standardwert setzen (Team, Region, Bridge, Machine)",
        "success": "\"{{key}}\" auf \"{{value}}\" gesetzt"
      },
      "setInfra": {
        "description": "Infrastrukturkonfiguration für eine Machine setzen",
        "invalidIPv4": "Ungültige IPv4-Adresse: {{ip}}",
        "invalidIPv6": "Ungültige IPv6-Adresse: {{ip}}",
        "noOptions": "Keine Optionen angegeben. Verwenden Sie --public-ipv4, --base-domain usw.",
        "optionBaseDomain": "Basis-Domain für Anwendungen",
        "optionCertEmail": "E-Mail für TLS-Zertifikat-Benachrichtigungen",
        "optionCfDnsToken": "Cloudflare DNS-API-Token für ACME DNS-01-Challenge",
        "optionPublicIPv4": "Öffentliche IPv4-Adresse",
        "optionPublicIPv6": "Öffentliche IPv6-Adresse",
        "optionTcpPorts": "Weiterzuleitende TCP-Ports (kommagetrennt, z.B. 25,143,465)",
        "optionUdpPorts": "Weiterzuleitende UDP-Ports (kommagetrennt, z.B. 53)",
        "success": "Infrastrukturkonfiguration für \"{{name}}\" aktualisiert"
      },
      "setRenet": {
        "description": "Pfad zur renet-Binärdatei für den lokalen Modus setzen",
        "success": "Renet-Pfad gesetzt auf: {{path}}"
      },
      "setSsh": {
        "description": "SSH-Konfiguration für die aktuelle Konfiguration aktualisieren",
        "success": "SSH-Konfiguration aktualisiert"
      },
      "setupMachine": {
        "completed": "Einrichtung von Machine '{{machine}}' erfolgreich abgeschlossen",
        "datastoreOption": "Datastore-Pfad auf der Remote-Machine",
        "datastoreSizeOption": "Datastore-Größe (z.B. 95%, 100G)",
        "description": "Einrichtung auf einer Remote-Machine ausführen (installiert btrfs, Docker usw.)",
        "failed": "Einrichtung von Machine '{{machine}}' fehlgeschlagen: {{error}}",
        "starting": "Machine '{{machine}}' wird eingerichtet..."
      },
      "show": {
        "description": "Aktuelle Konfigurationsdetails anzeigen",
        "noConfig": "Keine aktive Konfiguration. Erstellen Sie eine mit: rdc config init"
      },
      "showInfra": {
        "description": "Infrastrukturkonfiguration für eine Machine anzeigen",
        "noInfra": "Keine Infrastrukturkonfiguration für \"{{name}}\" gesetzt"
      },
      "storages": {
        "description": "Speicher in der aktuellen Konfiguration auflisten",
        "noStorages": "Keine Speicher konfiguriert. Importieren Sie mit: rdc config import-storage <file>"
      }
    },
    "doctor": {
      "allPassed": "Alle Prüfungen bestanden",
      "checks": {
        "activeConfig": "Aktive Konfiguration",
        "authStatus": "Status",
        "cliVersion": "CLI-Version",
        "contextMode": "Kontextmodus",
        "dockerAvailable": "Docker",
        "goInstalled": "Go",
        "machines": "Maschinen",
        "nodeVersion": "Node.js",
        "opsPrereqs": "OPS-Voraussetzungen",
        "renetBinary": "Binärdatei",
        "renetCriu": "Eingebettetes CRIU",
        "renetRsync": "Eingebettetes rsync",
        "renetVersion": "Version",
        "seaMode": "SEA-Modus",
        "sshKey": "SSH-Schlüssel"
      },
      "description": "CLI-Umgebung und Renet-Integration diagnostizieren",
      "devMode": "nein (Entwicklungsmodus)",
      "hasErrors": "{{count}} Fehler",
      "hasWarnings": "{{count}} Warnung(en)",
      "notAuthenticated": "nicht authentifiziert",
      "notConfigured": "nicht konfiguriert",
      "notInstalled": "nicht installiert",
      "opsNotSupported": "nicht unterstützt auf {{platform}}",
      "opsSkipped": "renet nicht verfügbar (übersprungen)",
      "seaActive": "ja (Single Executable Application)",
      "sections": {
        "authentication": "Authentifizierung",
        "configuration": "Konfiguration",
        "environment": "Umgebung",
        "renet": "Renet",
        "virtualization": "Virtualisierung"
      },
      "status": {
        "fail": "FEHLER",
        "ok": "OK",
        "warn": "WARNUNG"
      },
      "title": "Rediacc CLI-Diagnose"
    },
    "machine": {
      "containers": {
        "allHealthy": "Alle Container sind gesund",
        "description": "Docker-Container auf einer Machine auflisten",
        "fetched": "Container abgerufen",
        "fetching": "Container werden abgerufen...",
        "healthCheck": "Zustandsprüfungsmodus - beendet mit Code 2 bei ungesunden Containern",
        "noContainers": "Keine Container auf dieser Machine gefunden",
        "unhealthyFound": "{{count}} ungesunde(r) Container gefunden"
      },
      "create": {
        "creating": "Machine wird erstellt...",
        "description": "Eine neue Machine erstellen",
        "success": "Machine \"{{name}}\" erstellt"
      },
      "delete": {
        "confirm": "Möchten Sie die Machine \"{{name}}\" wirklich löschen?",
        "deleting": "Machine wird gelöscht...",
        "description": "Eine Machine löschen",
        "success": "Machine \"{{name}}\" gelöscht"
      },
      "description": "Machine-Verwaltung",
      "health": {
        "containersSection": "\nContainer:",
        "containersSummary": "  {{running}}/{{total}} laufen ({{healthy}} gesund, {{unhealthy}} ungesund)",
        "description": "Machine-Zustand für CI/CD-Pipelines prüfen",
        "exitCode": "\nExit-Code: {{code}}",
        "fetched": "Zustandsdaten abgerufen",
        "fetching": "Machine-Zustand wird abgerufen...",
        "header": "\nZustandsprüfung für {{name}}:",
        "issuesSection": "\nProbleme:",
        "noData": "Keine Statusdaten für Machine verfügbar",
        "repositoriesSection": "\nRepositories:",
        "repositoriesSummary": "  {{mounted}}/{{total}} eingebunden ({{docker}} mit Docker)",
        "servicesSection": "\nDienste:",
        "servicesSummary": "  {{active}}/{{total}} aktiv ({{failed}} fehlgeschlagen)",
        "statusCritical": "✗ Status: KRITISCH",
        "statusError": "✗ Status: FEHLER",
        "statusHealthy": "✓ Status: GESUND",
        "statusWarning": "⚠ Status: WARNUNG",
        "storageSection": "\nSpeicher:",
        "storageSmart": "  SMART: {{healthy}} gesund, {{failing}} ausfallend",
        "storageTemp": "  Max. Temperatur: {{temp}}°C",
        "systemDatastore": "  Datastore: {{percent}}",
        "systemDisk": "  Festplatte: {{percent}}",
        "systemMemory": "  Speicher: {{percent}}",
        "systemSection": "\nSystem:",
        "systemUptime": "  Betriebszeit: {{uptime}}"
      },
      "list": {
        "description": "Machines auflisten",
        "fetching": "Machines werden abgerufen..."
      },
      "repos": {
        "description": "Auf einer Machine bereitgestellte Repositories auflisten",
        "fetched": "Machine abgerufen",
        "fetching": "Machine wird abgerufen...",
        "noRepos": "Keine Repositories auf dieser Machine bereitgestellt"
      },
      "services": {
        "allStable": "Alle Dienste sind stabil",
        "description": "systemd-Dienste auf einer Machine auflisten",
        "fetched": "Dienste abgerufen",
        "fetching": "Dienste werden abgerufen...",
        "noServices": "Keine rediacc-Dienste auf dieser Machine gefunden",
        "stabilityCheck": "Stabilitätsprüfungsmodus - beendet mit Code 2 bei fehlgeschlagenen/neu startenden Diensten",
        "unstableFound": "{{count}} instabile(r) Dienst(e) gefunden"
      },
      "status": {
        "description": "Vollständigen Maschinenstatus anzeigen (System, Repos, Container, Dienste)",
        "fetched": "Status abgerufen",
        "fetching": "Status von {{machine}} wird abgerufen...",
        "noData": "Keine Statusdaten verfügbar"
      },
      "testConnection": {
        "authMethod": "  Auth-Methode: {{method}}",
        "created": "Task erstellt",
        "creating": "SSH-Test-Task wird erstellt...",
        "description": "SSH-Verbindung zu einer Machine testen und Host-Schlüssel erfassen",
        "error": "Fehler: {{error}}",
        "knownHosts": "  Known Hosts: {{entry}}",
        "message": "  Nachricht: {{message}}",
        "publicKeyDeployed": "  Öffentlicher Schlüssel bereitgestellt: {{status}}",
        "rawOutput": "Rohe Ausgabe:",
        "results": "SSH-Test-Ergebnisse:",
        "saved": "Known Hosts im Machine-Vault gespeichert",
        "saving": "known_hosts wird in Machine-Vault \"{{machine}}\" gespeichert...",
        "sshKeyConfigured": "  SSH-Schlüssel konfiguriert: {{status}}",
        "statusResult": "  Status: {{status}}",
        "taskId": "Task-ID: {{taskId}}",
        "testing": "SSH-Verbindung zu {{user}}@{{ip}}:{{port}} wird getestet...",
        "testResult": "SSH-Test {{result}}",
        "timeout": "Zeitüberschreitung beim Warten auf Ergebnis",
        "timeoutMessage": "Test-Verbindung hat Zeitüberschreitung. Prüfen Sie Queue-Nachverfolgung für Details.",
        "waiting": "Auf SSH-Test-Ergebnis wird gewartet...",
        "waitingTime": "Auf SSH-Test-Ergebnis wird gewartet... ({{seconds}}s)"
      },
      "update": {
        "description": "Machine-Konfiguration aktualisieren",
        "success": "Machine \"{{name}}\" aktualisiert",
        "updating": "Machine wird aktualisiert..."
      },
      "vaultStatus": {
        "deployedRepos": "\nBereitgestellte Repositories:",
        "description": "Parsed-Vault-Status für eine Machine anzeigen",
        "dockerRunning": "  Docker läuft: {{count}}",
        "fetched": "Machine abgerufen",
        "fetching": "Machine wird abgerufen...",
        "header": "\nVault-Status für {{name}}:",
        "mounted": "  Eingebunden: {{count}}",
        "repoDocker": "    Docker: {{status}}",
        "repoMounted": "    Eingebunden: {{mounted}}",
        "status": "  Status: {{status}}",
        "systemDatastore": "  Datastore: {{used}} / {{total}} ({{percent}})",
        "systemDisk": "  Festplatte: {{used}} / {{total}} ({{percent}})",
        "systemHostname": "  Hostname: {{hostname}}",
        "systemMemory": "  Speicher: {{used}} / {{total}} ({{percent}})",
        "systemSection": "\nSystem:",
        "systemUptime": "  Betriebszeit: {{uptime}}",
        "totalRepos": "  Gesamtzahl Repositories: {{count}}"
      }
    },
    "ops": {
      "check": {
        "allPassed": "Alle Voraussetzungen erfüllt",
        "description": "Virtualisierungsvoraussetzungen überprüfen",
        "hasMissing": "{{count}} Voraussetzung(en) fehlen",
        "localFallback": "(Lokale Prüfungen — renet nicht verfügbar)",
        "title": "OPS-Voraussetzungsprüfung"
      },
      "description": "Experimentelle VM-Operationen (bereitstellen, verwalten, zerstören)",
      "down": {
        "completed": "VM-Cluster erfolgreich zerstört",
        "description": "VM-Cluster zerstören",
        "failed": "Zerstörung des VM-Clusters fehlgeschlagen",
        "starting": "VM-Cluster wird zerstört..."
      },
      "setup": {
        "brewFailed": "Homebrew-Installation fehlgeschlagen",
        "completed": "Voraussetzungen erfolgreich installiert",
        "description": "Virtualisierungsvoraussetzungen installieren",
        "detecting": "Plattform wird erkannt...",
        "failed": "Installation fehlgeschlagen",
        "linux": "KVM-Voraussetzungen werden über renet installiert...",
        "macos": "QEMU wird über Homebrew installiert...",
        "unsupported": "Nicht unterstützte Plattform: {{platform}}",
        "windows": "Hyper-V-Voraussetzungen werden eingerichtet..."
      },
      "ssh": {
        "connecting": "Verbindung zu VM {{id}} wird hergestellt...",
        "description": "SSH-Verbindung zu einer VM",
        "vmNotFound": "VM mit ID {{id}} nicht gefunden oder nicht aktiv"
      },
      "status": {
        "description": "VM-Cluster-Status anzeigen",
        "fetching": "VM-Cluster-Status wird abgerufen...",
        "noVMs": "Keine VMs gefunden"
      },
      "up": {
        "completed": "VM-Cluster erfolgreich bereitgestellt",
        "description": "VM-Cluster lokal bereitstellen",
        "failed": "Bereitstellung des VM-Clusters fehlgeschlagen",
        "starting": "VM-Cluster-Bereitstellung wird gestartet..."
      }
    },
    "organization": {
      "dashboard": {
        "description": "Organisationsdaten für das Dashboard abrufen",
        "fetching": "Dashboard wird abgerufen...",
        "success": "Dashboard abgerufen"
      },
      "description": "Organisationsverwaltungsbefehle",
      "export": {
        "description": "Organisationsdaten exportieren",
        "exported": "Exportiert nach {{path}}",
        "exporting": "Organisationsdaten werden exportiert...",
        "success": "Export abgeschlossen"
      },
      "import": {
        "description": "Organisationsdaten importieren",
        "importing": "Organisationsdaten werden importiert...",
        "success": "Import abgeschlossen"
      },
      "info": {
        "description": "Organisationsinformationen abrufen",
        "fetching": "Organisationsinformationen werden abgerufen...",
        "notFound": "Keine Organisationsinformationen gefunden",
        "success": "Organisationsinformationen abgerufen"
      },
      "list": {
        "description": "Organisationen auflisten",
        "fetching": "Organisationen werden abgerufen..."
      },
      "maintenance": {
        "description": "Wartungsmodus aktivieren oder deaktivieren (blockiert Nicht-Admin-Anmeldungen)",
        "disabled": "Wartungsmodus deaktiviert",
        "disabling": "Wartungsmodus wird deaktiviert...",
        "enabled": "Wartungsmodus aktiviert",
        "enabling": "Wartungsmodus wird aktiviert..."
      },
      "vault": {
        "description": "Organisations-Vault-Verwaltung",
        "get": {
          "description": "Organisations-Vault-Daten abrufen",
          "fetching": "Organisations-Vault wird abgerufen...",
          "notFound": "Kein Organisations-Vault gefunden",
          "success": "Vault abgerufen"
        },
        "list": {
          "description": "Alle Vault-Typen auflisten",
          "fetching": "Vaults werden abgerufen...",
          "success": "Vaults abgerufen"
        },
        "update": {
          "description": "Organisations-Vault-Daten aktualisieren",
          "success": "Organisations-Vault aktualisiert",
          "updating": "Organisations-Vault wird aktualisiert..."
        }
      }
    },
    "permission": {
      "add": {
        "adding": "Berechtigung \"{{permission}}\" wird zur Gruppe \"{{group}}\" hinzugefügt...",
        "description": "Fügen Sie einer Gruppe eine Berechtigung hinzu",
        "success": "Berechtigung hinzugefügt"
      },
      "description": "Berechtigungsverwaltungsbefehle",
      "group": {
        "create": {
          "creating": "Berechtigungsgruppe \"{{name}}\" wird erstellt...",
          "description": "Eine neue Berechtigungsgruppe erstellen",
          "success": "Berechtigungsgruppe \"{{name}}\" erstellt"
        },
        "delete": {
          "confirm": "Berechtigungsgruppe \"{{name}}\" löschen?",
          "deleting": "Berechtigungsgruppe \"{{name}}\" wird gelöscht...",
          "description": "Eine Berechtigungsgruppe löschen",
          "success": "Berechtigungsgruppe \"{{name}}\" gelöscht"
        },
        "description": "Berechtigungsgruppen-Verwaltung",
        "list": {
          "description": "Alle Berechtigungsgruppen auflisten",
          "fetching": "Berechtigungsgruppen werden abgerufen...",
          "success": "Berechtigungsgruppen abgerufen"
        },
        "show": {
          "description": "Details zur Berechtigungsgruppe anzeigen",
          "fetching": "Details zur Berechtigungsgruppe werden abgerufen...",
          "success": "Details abgerufen"
        }
      },
      "list": {
        "description": "Berechtigungen auflisten",
        "fetching": "Berechtigungen werden abgerufen..."
      },
      "remove": {
        "description": "Entfernen Sie eine Berechtigung aus einer Gruppe",
        "removing": "Berechtigung \"{{permission}}\" wird aus Gruppe \"{{group}}\" entfernt...",
        "success": "Berechtigung entfernt"
      }
    },
    "protocol": {
      "build": {
        "description": "Erstellen Sie eine {{scheme}}://-URL aus Komponenten"
      },
      "description": "Verwaltung der {{scheme}}://-Protokollhandler-Registrierung und URL-Verarbeitung",
      "open": {
        "action": "Aktion:",
        "cliCommand": "\nÄquivalenter CLI-Befehl:",
        "description": "Öffnen Sie eine {{scheme}}://-URL und führen Sie die Aktion aus",
        "executing": "\nAktion wird ausgeführt...\n",
        "machine": "Machine:",
        "params": "Parameter:",
        "parsedUrl": "\nAnalysierte Protokoll-URL:",
        "repository": "Repository:",
        "team": "Team:",
        "token": "Token:"
      },
      "parse": {
        "cliCommand": "\nCLI-Befehl:",
        "description": "Analysieren Sie eine {{scheme}}://-URL und zeigen Sie Komponenten",
        "parsedUrl": "\nAnalysierte Protokoll-URL:"
      },
      "register": {
        "adminRequired": "Hinweis: Dies erfordert möglicherweise Administrator-/Root-Berechtigungen.",
        "currentUser": "Protokollhandler wird für aktuellen Benutzer registriert...",
        "description": "Registrieren Sie den Protokollhandler systemweit",
        "exampleUrls": "\nSie können jetzt URLs wie diese öffnen:",
        "registering": "Protokollhandler wird registriert...",
        "success": "\n{{scheme}}://-Protokollhandler erfolgreich registriert.",
        "systemWide": "Protokollhandler wird systemweit registriert..."
      },
      "status": {
        "description": "Registrierungsstatus des Protokollhandlers anzeigen",
        "error": "\nFehler: {{error}}",
        "handlerCommand": "Handler-Befehl:",
        "platform": "Plattform:",
        "registered": "Registriert:",
        "registerHint": "\nUm den Protokollhandler zu registrieren, führen Sie aus:",
        "supported": "Unterstützt:",
        "systemRegistration": "Systemregistrierung:",
        "title": "\nProtokollhandler-Status",
        "userRegistration": "Benutzerregistrierung:"
      },
      "unregister": {
        "description": "Deregistrieren Sie den Protokollhandler vom System",
        "success": "\n{{scheme}}://-Protokollhandler erfolgreich deregistriert.",
        "unregistering": "Protokollhandler wird deregistriert..."
      }
    },
    "queue": {
      "cancel": {
        "cancelling": "Task {{taskId}} wird abgebrochen...",
        "description": "Ein Queue-Item abbrechen",
        "success": "Task abgebrochen"
      },
      "create": {
        "buildingVault": "Queue-Vault wird erstellt...",
        "creating": "Queue-Item für Funktion '{{function}}' wird erstellt...",
        "description": "Ein Queue-Item erstellen",
        "success": "Queue-Item erstellt",
        "taskId": "Task-ID: {{taskId}}",
        "vaultBuilt": "Queue-Vault erstellt"
      },
      "delete": {
        "confirm": "Möchten Sie Task {{taskId}} wirklich löschen?",
        "deleting": "Task {{taskId}} wird gelöscht...",
        "description": "Ein Queue-Item löschen",
        "success": "Task gelöscht"
      },
      "description": "Queue-Verwaltung",
      "list": {
        "description": "Queue-Items auflisten",
        "fetching": "Queue-Items werden abgerufen...",
        "success": "Queue-Items abgerufen"
      },
      "retry": {
        "description": "Einen fehlgeschlagenen Queue-Item wiederholen",
        "retrying": "Task {{taskId}} wird wiederholt...",
        "success": "Task in Warteschlange zur Wiederholung eingereiht"
      },
      "trace": {
        "age": "Alter",
        "description": "Queue-Item-Ausführung nachverfolgen",
        "errorDetails": "Fehlerdetails:",
        "fetched": "Queue-Nachverfolgung abgerufen",
        "fetching": "Queue-Nachverfolgung wird abgerufen...",
        "finalStatus": "Endgültiger Status: {{status}}",
        "noTrace": "Keine Nachverfolgungsinformationen verfügbar",
        "watching": "Task-Fortschritt wird beobachtet..."
      }
    },
    "region": {
      "description": "Regionen-Verwaltung",
      "list": {
        "description": "Regionen auflisten",
        "fetching": "Regionen werden abgerufen..."
      }
    },
    "repo": {
      "autostart": {
        "description": "Automatischen Repository-Start beim Hochfahren verwalten",
        "disable": {
          "completed": "Autostart deaktiviert",
          "description": "Autostart für ein Repository deaktivieren",
          "failed": "Deaktivierung des Autostarts fehlgeschlagen",
          "starting": "Autostart für \"{{repository}}\" auf \"{{machine}}\" wird deaktiviert..."
        },
        "disableAll": {
          "completed": "Autostart für alle Repositories deaktiviert",
          "description": "Autostart für alle Repositories deaktivieren",
          "failed": "Deaktivierung des Autostarts für alle Repositories fehlgeschlagen",
          "starting": "Autostart für alle Repositories auf \"{{machine}}\" wird deaktiviert..."
        },
        "enable": {
          "completed": "Autostart aktiviert",
          "description": "Autostart für ein Repository aktivieren",
          "failed": "Aktivierung des Autostarts fehlgeschlagen",
          "starting": "Autostart für \"{{repository}}\" auf \"{{machine}}\" wird aktiviert..."
        },
        "enableAll": {
          "completed": "Autostart für alle Repositories aktiviert",
          "description": "Autostart für alle Repositories aktivieren",
          "failed": "Aktivierung des Autostarts für alle Repositories fehlgeschlagen",
          "starting": "Autostart für alle Repositories auf \"{{machine}}\" wird aktiviert..."
        },
        "list": {
          "completed": "Autostart-Liste abgerufen",
          "description": "Repositories mit aktiviertem Autostart auflisten",
          "failed": "Abrufen der Autostart-Liste fehlgeschlagen",
          "starting": "Autostart-Repositories auf \"{{machine}}\" werden aufgelistet..."
        }
      },
      "create": {
        "alreadyExists": "Repository \"{{name}}\" existiert bereits im Kontext",
        "completed": "Repository erstellt",
        "description": "Neues verschlüsseltes Repository erstellen",
        "failed": "Repository-Erstellung fehlgeschlagen",
        "registered": "\"{{repository}}\" registriert ({{guid}}, Netzwerk {{networkId}})",
        "rollback": "Konfiguration für \"{{repository}}\" zurückgesetzt",
        "sizeOption": "Repository-Größe (z.B. 10G, 100G, 1T)",
        "starting": "Repository \"{{repository}}\" ({{size}}) wird auf \"{{machine}}\" erstellt..."
      },
      "delete": {
        "completed": "Repository gelöscht",
        "description": "Repository löschen",
        "failed": "Repository-Löschung fehlgeschlagen",
        "removed": "\"{{repository}}\" aus der Konfiguration entfernt",
        "starting": "\"{{repository}}\" wird auf \"{{machine}}\" gelöscht..."
      },
      "description": "Repository-Lebenszyklus-Verwaltung (lokaler Modus)",
      "down": {
        "completed": "Dienste gestoppt",
        "description": "Repository-Dienste stoppen",
        "failed": "Stoppen der Dienste fehlgeschlagen",
        "grandOption": "Grand-Repository-Name (wird automatisch in GUID aufgelöst)",
        "starting": "Dienste für \"{{repository}}\" auf \"{{machine}}\" werden gestoppt...",
        "unmountOption": "Repository nach dem Stoppen unmounten"
      },
      "expand": {
        "completed": "Erweiterung abgeschlossen",
        "description": "Eingehängtes Repository online erweitern (ohne Ausfallzeit)",
        "failed": "Erweiterung fehlgeschlagen",
        "sizeOption": "Neue Repository-Größe (z.B. 10G, 100G, 1T)",
        "starting": "\"{{repository}}\" wird auf {{size}} auf \"{{machine}}\" erweitert..."
      },
      "fork": {
        "alreadyExists": "Repository \"{{name}}\" existiert bereits im Kontext",
        "completed": "Fork erstellt",
        "description": "CoW-Fork (Copy-on-Write) eines Repositorys erstellen",
        "failed": "Fork-Erstellung fehlgeschlagen",
        "registered": "Fork \"{{repository}}\" registriert ({{guid}}, Netzwerk {{networkId}})",
        "rollback": "Konfiguration für \"{{repository}}\" zurückgesetzt",
        "starting": "Fork von \"{{parent}}\" als \"{{repository}}\" auf \"{{machine}}\" wird erstellt...",
        "tagOption": "Fork-Name"
      },
      "list": {
        "completed": "Auflistung abgeschlossen",
        "description": "Repositories auf einer Maschine auflisten",
        "failed": "Auflistung fehlgeschlagen: {{error}}",
        "starting": "Repositories auf \"{{machine}}\" werden aufgelistet..."
      },
      "machineOption": "Name der Zielmaschine",
      "mount": {
        "checkpointOption": "Nach dem Mounten von Checkpoint wiederherstellen",
        "completed": "Mounten abgeschlossen",
        "description": "Repository mounten (LUKS-Container öffnen)",
        "failed": "Mounten fehlgeschlagen",
        "starting": "\"{{repository}}\" auf \"{{machine}}\" wird gemountet..."
      },
      "noCredential": "Warnung: Repository \"{{name}}\" hat keine Zugangsdaten. Operationen auf verschlüsselten Repositories können fehlschlagen.",
      "ownership": {
        "completed": "Besitz aktualisiert",
        "description": "Repository-Verzeichnis-Besitz ändern",
        "failed": "Besitz-Aktualisierung fehlgeschlagen",
        "starting": "Besitz von \"{{repository}}\" wird auf \"{{machine}}\" gesetzt...",
        "uidOption": "Besitzer-UID (Standard: 7111)"
      },
      "resize": {
        "completed": "Skalierung abgeschlossen",
        "description": "Repository offline skalieren (unterstützt Vergrößern und Verkleinern)",
        "failed": "Skalierung fehlgeschlagen",
        "sizeOption": "Neue Repository-Größe (z.B. 10G, 100G, 1T)",
        "starting": "\"{{repository}}\" wird auf {{size}} auf \"{{machine}}\" skaliert..."
      },
      "status": {
        "completed": "Status abgerufen",
        "description": "Repository-Status abrufen",
        "failed": "Statusabfrage fehlgeschlagen",
        "starting": "Status von \"{{repository}}\" auf \"{{machine}}\" wird abgerufen..."
      },
      "template": {
        "completed": "Vorlage angewendet",
        "description": "Vorlage auf ein Repository anwenden",
        "failed": "Vorlagen-Anwendung fehlgeschlagen",
        "fileNotFound": "Vorlagendatei nicht gefunden: {{path}}",
        "fileOption": "Pfad zur JSON-Vorlagendatei",
        "grandOption": "Grand-Repository-Name (wird automatisch in GUID aufgelöst)",
        "starting": "Vorlage wird auf \"{{repository}}\" auf \"{{machine}}\" angewendet..."
      },
      "unmount": {
        "checkpointOption": "Checkpoint vor dem Unmounten erstellen",
        "completed": "Unmounten abgeschlossen",
        "description": "Repository unmounten",
        "failed": "Unmounten fehlgeschlagen",
        "starting": "\"{{repository}}\" auf \"{{machine}}\" wird unmountet..."
      },
      "up": {
        "completed": "Dienste gestartet",
        "description": "Repository-Dienste starten (Rediaccfile-Orchestrierung)",
        "failed": "Starten der Dienste fehlgeschlagen",
        "grandOption": "Grand-Repository-Name (wird automatisch in GUID aufgelöst)",
        "mountOption": "Repository vorher mounten",
        "prepOnlyOption": "Nur den Vorbereitungsschritt ausführen",
        "starting": "Dienste für \"{{repository}}\" auf \"{{machine}}\" werden gestartet..."
      },
      "upAll": {
        "completed": "Alle Repositories gestartet",
        "concurrencyOption": "Maximale gleichzeitige Repositories (Standard: 3)",
        "description": "Alle Repository-Dienste auf einer Maschine starten",
        "dryRunOption": "Zeigen, was ausgeführt würde, ohne es tatsächlich auszuführen",
        "failed": "Sammelstart fehlgeschlagen",
        "includeForksOption": "Auch geforkte Repositories einbinden/starten",
        "mountOnlyOption": "Nur einbinden, keine Dienste starten",
        "parallelOption": "Repositories parallel starten",
        "starting": "Alle Repositories auf \"{{machine}}\" werden gestartet..."
      },
      "validate": {
        "completed": "Überprüfung abgeschlossen",
        "description": "Repository-Integrität überprüfen",
        "failed": "Überprüfung fehlgeschlagen",
        "starting": "\"{{repository}}\" wird auf \"{{machine}}\" überprüft..."
      }
    },
    "repository": {
      "create": {
        "creating": "Repository \"{{name}}:{{tag}}\" wird erstellt...",
        "description": "Ein neues Repository erstellen",
        "success": "Repository \"{{name}}:{{tag}}\" erstellt"
      },
      "delete": {
        "checkingRelationships": "Repository-Beziehungen werden überprüft...",
        "confirm": "Repository \"{{name}}:{{tag}}\" löschen? Dies kann nicht rückgängig gemacht werden.",
        "deleting": "Repository \"{{name}}:{{tag}}\" wird gelöscht...",
        "description": "Ein Repository löschen",
        "grandRepoWarning": "Dies ist ein Grand-Repository (Anmeldedaten). Das Löschen ist nicht umkehrbar.",
        "relationshipsChecked": "Repository-Beziehungen überprüft",
        "success": "Repository \"{{name}}:{{tag}}\" gelöscht"
      },
      "description": "Repository-Verwaltungsbefehle",
      "list": {
        "description": "Repositories auflisten",
        "fetching": "Repositories werden abgerufen...",
        "success": "Repositories abgerufen"
      },
      "promote": {
        "checkingRelationships": "Repository-Beziehungen werden überprüft...",
        "confirmPromote": "\nFortfahren mit der Beförderung?",
        "description": "Befördern Sie einen Fork zu Grand-Status",
        "promoting": "Repository \"{{name}}:{{tag}}\" wird befördert...",
        "relationshipsChecked": "Repository-Beziehungen überprüft",
        "separateInfo": "\nDies trennt \"{{name}}\" vom Grand-Repository \"{{grandName}}\"",
        "siblingsInfo": "\n{{count}} Sibling-Klon(e) bleiben mit dem ursprünglichen Grand verknüpft:",
        "success": "Repository \"{{name}}:{{tag}}\" zu Grand-Status befördert"
      },
      "rename": {
        "description": "Ein Repository umbenennen",
        "renaming": "Repository \"{{oldName}}\" wird in \"{{newName}}\" umbenannt...",
        "success": "Repository in \"{{name}}\" umbenannt"
      },
      "vault": {
        "description": "Repository-Vault-Verwaltung",
        "get": {
          "description": "Repository-Vault-Daten abrufen",
          "fetching": "Repository-Vault wird abgerufen...",
          "notFound": "Kein Repository-Vault gefunden",
          "success": "Vault abgerufen"
        },
        "update": {
          "description": "Repository-Vault-Daten aktualisieren",
          "success": "Repository-Vault aktualisiert",
          "updating": "Repository-Vault wird aktualisiert..."
        }
      }
    },
    "shortcuts": {
      "cancel": {
        "description": "Eine Aufgabe abbrechen (Kurzbefehl für: queue cancel)"
      },
      "retry": {
        "description": "Eine fehlgeschlagene Aufgabe wiederholen (Kurzbefehl für: queue retry)"
      },
      "run": {
        "completedLocal": "[lokal] In {{duration}}ms abgeschlossen",
        "description": "Führen Sie eine Funktion aus (Kurzform: queue create)",
        "executingLocal": "[lokal] Führe '{{function}}' auf {{machine}} aus...",
        "failedLocal": "[lokal] Fehlgeschlagen: {{error}}",
        "watching": "Auf Fertigstellung wird gewartet..."
      },
      "trace": {
        "description": "Eine Aufgabe verfolgen (Kurzbefehl für: queue trace)"
      }
    },
    "snapshot": {
      "create": {
        "creating": "Snapshot von \"{{repo}}\" auf {{machine}} wird erstellt...",
        "description": "BTRFS-Snapshot eines Repositorys erstellen",
        "optionSnapshotName": "Expliziter Snapshot-Name (wird automatisch generiert, wenn leer)",
        "success": "Snapshot erstellt: {{name}} ({{path}})"
      },
      "delete": {
        "description": "Snapshot von einem Remote-Rechner löschen",
        "success": "Snapshot gelöscht: {{name}}"
      },
      "description": "BTRFS-Snapshots auf Remote-Rechnern verwalten",
      "list": {
        "description": "Snapshots auf einem Remote-Rechner auflisten",
        "header": "{{count}} Snapshot(s) in {{path}}:",
        "noSnapshots": "Keine Snapshots gefunden."
      }
    },
    "storage": {
      "browse": {
        "description": "Dateien in einem Speichersystem durchsuchen",
        "failed": "Dateien konnten nicht aufgelistet werden: {{error}}",
        "listing": "Dateien in \"{{name}}\" werden aufgelistet...",
        "noFiles": "Keine Dateien gefunden",
        "pathOption": "Unterverzeichnispfad zum Auflisten"
      },
      "description": "Speicherverwaltung",
      "list": {
        "description": "Speicheranbieter auflisten",
        "fetching": "Speicheranbieter werden abgerufen..."
      },
      "pull": {
        "completed": "Download abgeschlossen in {{duration}}ms",
        "description": "Ein Backup aus dem Cloud-Speicher auf eine Maschine herunterladen",
        "failed": "Download fehlgeschlagen: {{error}}",
        "machineOption": "Name der Zielmaschine",
        "noCredential": "Warnung: Repository \"{{name}}\" hat keine Zugangsdaten. Der Download kann fehlschlagen, wenn das Backup verschlüsselt ist.",
        "repositoryOption": "Name des Repositories zum Herunterladen",
        "starting": "\"{{repository}}\" wird von \"{{storage}}\" auf \"{{machine}}\" heruntergeladen..."
      }
    },
    "store": {
      "add": {
        "addedButUnverified": "Store \"{{name}}\" hinzugefügt, aber Verbindung konnte nicht verifiziert werden",
        "alreadyExists": "Store \"{{name}}\" existiert bereits",
        "description": "Einen neuen Synchronisierungs-Store hinzufügen",
        "gitUrlRequired": "--git-url ist für Git-Stores erforderlich",
        "invalidType": "Ungültiger Store-Typ: \"{{type}}\". Gültige Typen: {{valid}}",
        "localPathRequired": "--local-path ist für Local-File-Stores erforderlich",
        "optionBwFolderId": "Bitwarden-Ordner-ID zum Organisieren von Konfigurationselementen (optional)",
        "optionEncryptionKey": "Verschlüsselungsschlüssel für diesen Store",
        "optionGitBranch": "Git-Branch-Name",
        "optionGitPath": "Pfad im Git-Repository",
        "optionGitUrl": "Git-Repository-URL",
        "optionLocalPath": "Lokaler Verzeichnispfad",
        "optionS3AccessKeyId": "S3 Access Key ID",
        "optionS3Bucket": "S3-Bucket-Name",
        "optionS3Endpoint": "S3-Endpunkt-URL",
        "optionS3Prefix": "S3-Schlüsselpräfix",
        "optionS3Region": "S3-Region",
        "optionS3SecretAccessKey": "S3 Secret Access Key",
        "optionType": "Store-Typ (s3, local-file, bitwarden, git, vault)",
        "optionVaultAddr": "Vault-Server-Adresse (z.B. http://127.0.0.1:8200)",
        "optionVaultMount": "Vault KV v2-Einhängepfad (Standard: secret)",
        "optionVaultNamespace": "Vault-Namespace (nur Enterprise)",
        "optionVaultPrefix": "Pfadpräfix im Vault KV-Engine (Standard: rdc/configs)",
        "optionVaultToken": "Vault-Authentifizierungstoken",
        "promptS3SecretAccessKey": "S3 Secret Access Key:",
        "promptVaultToken": "Vault-Token (oder VAULT_TOKEN-Umgebungsvariable setzen):",
        "s3Required": "--s3-endpoint, --s3-bucket und --s3-access-key-id sind für S3-Stores erforderlich",
        "s3SecretRequired": "S3 Secret Access Key ist erforderlich",
        "success": "Store \"{{name}}\" hinzugefügt ({{type}})",
        "vaultAddrRequired": "--vault-addr ist für Vault-Stores erforderlich",
        "vaultTokenRequired": "Vault-Token ist erforderlich (--vault-token übergeben oder VAULT_TOKEN-Umgebungsvariable setzen)"
      },
      "description": "Konfigurationssynchronisierungs-Stores verwalten (S3, lokale Datei, Bitwarden, Git, Vault)",
      "list": {
        "description": "Konfigurierte Stores auflisten",
        "noStores": "Keine Stores konfiguriert. Fügen Sie einen hinzu mit: rdc store add <name> --type <type>"
      },
      "pull": {
        "description": "Konfiguration von einem Store abrufen",
        "failed": "Abrufen von Store \"{{store}}\" fehlgeschlagen: {{error}}",
        "notFound": "Store \"{{name}}\" nicht gefunden",
        "optionConfig": "Name der Konfiguration, in die abgerufen werden soll",
        "optionStore": "Von einem bestimmten Store abrufen",
        "success": "Konfiguration \"{{config}}\" von Store \"{{store}}\" abgerufen"
      },
      "push": {
        "description": "Aktuelle Konfiguration an Stores übertragen",
        "failed": "Übertragung an Store \"{{store}}\" fehlgeschlagen: {{error}}",
        "noStores": "Keine Stores konfiguriert",
        "optionAll": "An alle Stores übertragen",
        "optionStore": "An einen bestimmten Store übertragen",
        "success": "Konfiguration \"{{config}}\" an Store \"{{store}}\" übertragen"
      },
      "remove": {
        "description": "Einen Synchronisierungs-Store entfernen",
        "success": "Store \"{{name}}\" entfernt"
      },
      "sync": {
        "description": "Konfiguration mit Stores synchronisieren (abrufen, dann übertragen)",
        "failed": "Synchronisierung für Store \"{{store}}\" fehlgeschlagen: {{error}}",
        "noStores": "Keine Stores konfiguriert",
        "optionAll": "Mit allen Stores synchronisieren",
        "optionStore": "Mit einem bestimmten Store synchronisieren",
        "pulled": "Neuere Version von Store \"{{store}}\" abgerufen",
        "pushed": "An Store \"{{store}}\" übertragen"
      }
    },
    "sync": {
      "cancelled": "Synchronisierung abgebrochen.",
      "description": "Dateisynchronisierung mit Repositories mit rsync",
      "download": {
        "completed": "Download abgeschlossen: {{count}} Dateien übertragen",
        "description": "Dateien aus einem Repository herunterladen",
        "failed": "Download fehlgeschlagen",
        "progress": "Herunterladen: {{percentage}}% - {{file}} ({{speed}})",
        "starting": "Download wird gestartet..."
      },
      "dryRunHeader": "\nProbelauf - zeigt, was übertragen würde:\n",
      "duration": "Dauer: {{seconds}}s",
      "errors": "Fehler:",
      "fetchingDetails": "Verbindungsdetails werden abgerufen...",
      "noChanges": "Keine Änderungen zum Synchronisieren.",
      "previewingChanges": "\nÄnderungen werden angezeigt...\n",
      "status": {
        "description": "Synchronisierungsstatus prüfen und lokale/Remote-Dateien vergleichen"
      },
      "totalSize": "Gesamtgröße: {{size}}",
      "upload": {
        "completed": "Upload abgeschlossen: {{count}} Dateien übertragen",
        "description": "Dateien in ein Repository hochladen",
        "failed": "Upload fehlgeschlagen",
        "progress": "Hochladen: {{percentage}}% - {{file}} ({{speed}})",
        "starting": "Upload wird gestartet..."
      }
    },
    "team": {
      "create": {
        "creating": "Team wird erstellt...",
        "description": "Ein Team erstellen",
        "success": "Team \"{{name}}\" erstellt"
      },
      "description": "Team-Verwaltung",
      "list": {
        "description": "Teams auflisten",
        "fetching": "Teams werden abgerufen..."
      },
      "member": {
        "add": {
          "adding": "{{email}} wird zum Team \"{{team}}\" hinzugefügt...",
          "description": "Fügen Sie einen Benutzer zu einem Team hinzu",
          "success": "Benutzer zum Team \"{{team}}\" hinzugefügt"
        },
        "description": "Team-Mitgliedschaftsverwaltung",
        "list": {
          "description": "Team-Mitglieder auflisten",
          "fetching": "Team-Mitglieder werden abgerufen...",
          "success": "Mitglieder abgerufen"
        },
        "remove": {
          "description": "Entfernen Sie einen Benutzer aus einem Team",
          "removing": "{{email}} wird aus Team \"{{team}}\" entfernt...",
          "success": "Benutzer aus Team \"{{team}}\" entfernt"
        }
      }
    },
    "term": {
      "connect": {
        "description": "Verbinden Sie sich über SSH mit einer Machine oder einem Repository"
      },
      "connecting": "Verbindung zu {{machine}} wird hergestellt...",
      "connectingTo": "Verbindung zu {{title}} wird hergestellt...",
      "description": "SSH-Terminal-Zugriff auf Machines und Repositories",
      "fetchingDetails": "Verbindungsdetails werden abgerufen...",
      "launchingTerminal": "{{type}}-Terminal wird gestartet...",
      "launchSuccess": "Terminal erfolgreich gestartet.",
      "testingConnectivity": "Konnektivität zu {{host}}:{{port}} wird getestet..."
    },
    "update": {
      "applyFailed": "Bereitgestelltes Update konnte nicht angewendet werden: {{error}}",
      "autoApplied": "Auf v{{version}} aktualisiert (vorher v{{from}}). Änderungen werden beim nächsten Start wirksam.",
      "available": "Update verfügbar: v{{version}} (aktuell: v{{current}})",
      "checking": "Suche nach Updates...",
      "checkOnly": "Nur auf Updates prüfen, ohne herunterzuladen",
      "description": "CLI-Updates prüfen und anwenden",
      "downloading": "Lade v{{version}} herunter...",
      "failed": "Update fehlgeschlagen: {{error}}",
      "force": "Update erzwingen, auch wenn bereits aktuell",
      "notSEA": "Update nicht möglich: Keine gepackte Binärdatei. Erst mit SEA bauen.",
      "progress": "Herunterladen... {{percent}}%",
      "releaseNotes": "Versionshinweise: {{url}}",
      "rollback": "Auf die vorherige Version zurücksetzen",
      "rollbackFailed": "Rollback fehlgeschlagen: {{error}}",
      "rollbackNoBackup": "Keine vorherige Version gefunden. Ein Rollback ist nur nach einem Update verfügbar.",
      "rollbackSuccess": "Erfolgreich zurückgesetzt. Starten Sie rdc neu, um die vorherige Version zu verwenden.",
      "staged": "Update v{{version}} bereitgestellt (wird beim nächsten Start angewendet)",
      "stagedFallback": "Update v{{version}} heruntergeladen und bereitgestellt. Es wird beim nächsten Start angewendet.",
      "statusDescription": "Auto-Update-Status und Diagnose anzeigen",
      "success": "Aktualisiert von v{{from}} auf v{{to}}",
      "unknownError": "Unbekannter Fehler",
      "upToDate": "Bereits aktuell (v{{version}})"
    },
    "user": {
      "activate": {
        "activating": "Benutzer \"{{email}}\" wird aktiviert...",
        "description": "Ein Benutzerkonto aktivieren",
        "success": "Benutzer aktiviert"
      },
      "create": {
        "activationCode": "Aktivierungscode: {{code}}",
        "creating": "Benutzer \"{{email}}\" wird erstellt...",
        "description": "Einen neuen Benutzer erstellen",
        "success": "Benutzer erstellt"
      },
      "deactivate": {
        "confirm": "Benutzer \"{{email}}\" deaktivieren?",
        "deactivating": "Benutzer \"{{email}}\" wird deaktiviert...",
        "description": "Ein Benutzerkonto deaktivieren",
        "success": "Benutzer deaktiviert"
      },
      "description": "Benutzerverwaltungsbefehle",
      "exists": {
        "description": "Prüfen Sie, ob ein Benutzer existiert",
        "exists": "Benutzer \"{{email}}\" existiert",
        "notExists": "Benutzer \"{{email}}\" existiert nicht"
      },
      "list": {
        "description": "Alle Benutzer auflisten",
        "fetching": "Benutzer werden abgerufen...",
        "success": "Benutzer abgerufen"
      },
      "permission": {
        "assign": {
          "assigning": "\"{{group}}\" wird dem Benutzer \"{{email}}\" zugewiesen...",
          "description": "Weisen Sie eine Berechtigungsgruppe einem Benutzer zu",
          "success": "Berechtigung zugewiesen"
        },
        "description": "Benutzerberechtigung-Verwaltung"
      },
      "reactivate": {
        "description": "Ein deaktiviertes Benutzerkonto erneut aktivieren",
        "reactivating": "Benutzer \"{{email}}\" wird erneut aktiviert...",
        "success": "Benutzer erneut aktiviert"
      },
      "updateEmail": {
        "description": "Die E-Mail-Adresse eines Benutzers ändern",
        "success": "E-Mail aktualisiert zu \"{{email}}\"",
        "updating": "E-Mail für \"{{email}}\" wird aktualisiert..."
      },
      "updateLanguage": {
        "description": "Legen Sie die bevorzugte Sprache des aktuellen Benutzers fest",
        "success": "Sprache aktualisiert zu \"{{language}}\"",
        "updating": "Spracheinstellung wird aktualisiert..."
      },
      "updatePassword": {
        "description": "Ändern Sie Ihr Passwort",
        "success": "Passwort aktualisiert",
        "updating": "Passwort wird aktualisiert..."
      },
      "vault": {
        "description": "Benutzervault-Verwaltung",
        "get": {
          "description": "Aktuelle Benutzervault-Daten abrufen",
          "fetching": "Benutzervault wird abgerufen...",
          "success": "Vault abgerufen"
        },
        "update": {
          "description": "Aktuelle Benutzervault-Daten aktualisieren",
          "success": "Benutzervault aktualisiert",
          "updating": "Benutzervault wird aktualisiert..."
        }
      }
    },
    "vscode": {
      "check": {
        "activeConnections": "Aktive Verbindungen: {{count}}",
        "configuration": "\nKonfiguration:",
        "configured": "  Konfiguriert: {{status}}",
        "description": "Überprüfen Sie die VS Code-Installation und Konfiguration",
        "installation": "Installation:",
        "installed": "Installiert",
        "missingSettings": "  Fehlende Einstellungen:",
        "no": "Nein",
        "notDetected": "Nicht erkannt",
        "remoteSSH": "  Remote-SSH-Erweiterung: {{status}}",
        "settingsPath": "  Einstellungspfad: {{path}}",
        "sshConfig": "\nSSH-Konfiguration: {{path}}",
        "title": "VS Code-Setup-Überprüfung\n",
        "variant": "  Variante: Insiders",
        "version": "  Version: {{version}}",
        "vscodeFound": "  VS Code: {{path}}",
        "vscodeNotFound": "  VS Code: Nicht gefunden",
        "yes": "Ja"
      },
      "cleanup": {
        "cleaned": "Bereinigt: {{connection}}",
        "cleanedAll": "{{count}} VS Code-SSH-Verbindung(en) bereinigt.",
        "description": "Entfernen Sie VS Code-SSH-Konfigurationen",
        "removedKeys": "Alle beibehaltenen SSH-Schlüssel entfernt."
      },
      "connect": {
        "configuringSSH": "SSH wird konfiguriert...",
        "configuringVSCode": "VS Code-Einstellungen werden konfiguriert...",
        "description": "Verbinden Sie sich mit einer Machine oder einem Repository in VS Code",
        "detecting": "VS Code wird erkannt...",
        "extensionWarning": "Warnung: Remote-SSH-Erweiterung möglicherweise nicht installiert.\nInstallieren Sie unter: https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-ssh\n",
        "fetchingDetails": "Verbindungsdetails werden abgerufen...",
        "opening": "VS Code wird geöffnet: {{connection}} → {{path}}",
        "persistingKey": "SSH-Schlüssel wird beibehalten...",
        "settingsWarning": "Warnung: Konnte VS Code-Einstellungen nicht konfigurieren: {{error}}",
        "settingUpEnv": "Remote-Umgebung wird eingerichtet...",
        "success": "VS Code erfolgreich gestartet.",
        "testingConnectivity": "Konnektivität zu {{host}}:{{port}} wird getestet..."
      },
      "description": "VS Code Remote-SSH-Integration",
      "list": {
        "configFile": "\nKonfigurationsdatei: {{path}}",
        "description": "Konfigurierte VS Code-SSH-Verbindungen auflisten",
        "header": "Konfigurierte VS Code-SSH-Verbindungen:\n",
        "keyPersisted": " (Schlüssel beibehalten)",
        "noConnections": "Keine VS Code-SSH-Verbindungen konfiguriert.",
        "total": "\nGesamt: {{count}} Verbindung(en)"
      }
    },
    "subscription": {
      "description": "Maschinenlizenzierung und Abonnement verwalten",
      "login": {
        "description": "Mit einem API-Token aus dem Webportal authentifizieren",
        "tokenPrompt": "Geben Sie Ihr API-Token ein (aus dem Webportal):",
        "tokenInvalid": "Token muss mit rdt_ beginnen",
        "validating": "Token wird überprüft...",
        "validated": "Token überprüft",
        "success": "Erfolgreich angemeldet",
        "plan": "Tarif: {{plan}}",
        "machines": "Maschinen: {{active}}/{{max}}",
        "openBrowser": "Besuchen Sie diese URL zur Autorisierung:",
        "waitingApproval": "Warte auf Browser-Autorisierung...",
        "polling": "Warte auf Genehmigung (drücken Sie Strg+C zum Abbrechen)...",
        "expired": "Autorisierung abgelaufen. Bitte versuchen Sie es erneut.",
        "browserFailed": "Browser konnte nicht automatisch geöffnet werden. Bitte besuchen Sie die obige URL.",
        "initFailed": "Anmeldung konnte nicht gestartet werden. Läuft der Server?"
      },
      "status": {
        "description": "Abonnement- und Lizenzstatus anzeigen",
        "localLicense": "Lokale Lizenz:",
        "plan": "  Tarif:    {{plan}}",
        "statusLabel": "  Zustand:  {{status}}",
        "machine": "  Maschine: {{machineId}}",
        "issued": "  Ausgestellt: {{issuedAt}}",
        "expires": "  Läuft ab:   {{expiresAt}}",
        "sequence": "  Sequenz:  {{sequenceNumber}}",
        "expired": "  Lizenz ist ABGELAUFEN — führen Sie `rdc subscription refresh` aus",
        "valid": "  Gültig (läuft in {{mins}} Minuten ab)",
        "parseFailed": "  Lizenzdatei konnte nicht gelesen werden",
        "noLicense": "Keine lokale Lizenz installiert.",
        "remote": "\nRemote-Abonnement:",
        "remotePlan": "  Tarif:    {{plan}}",
        "remoteStatus": "  Zustand:  {{status}}",
        "remoteMachines": "  Maschinen: {{active}}/{{max}}",
        "remoteMachine": "    - {{id}}... (zuletzt gesehen: {{lastSeen}})"
      },
      "refresh": {
        "description": "Maschinenlizenz erneuern",
        "refreshing": "Lizenz wird erneuert...",
        "refreshed": "Lizenz erneuert",
        "success": "Lizenz erneuert und installiert"
      }
    }
  },
  "common": {
    "completed": "Abgeschlossen",
    "failed": "Fehlgeschlagen",
    "inProgress": "In Bearbeitung",
    "no": "Nein",
    "running": "Läuft",
    "stopped": "Gestoppt",
    "success": "✓ Erfolg",
    "unknown": "Unbekannt",
    "yes": "Ja"
  },
  "docs": {
    "admonitions": {
      "note": "Hinweis",
      "tip": "Tipp",
      "warning": "Warnung"
    },
    "cloudFrontmatter": {
      "category": "Referenz",
      "description": "Cloud-exklusive Befehle für die Rediacc CLI — Authentifizierung, Teams, Organisationen und Multi-Tenant-Verwaltung",
      "title": "CLI-Anwendung (Cloud / Experimentell)"
    },
    "cloudOverview": {
      "heading": "Übersicht",
      "text": "Diese Befehle benötigen den **Cloud-Adapter** (experimentell) — aktiviert, wenn eine Konfiguration `apiUrl`- und `token`-Felder enthält. Für die Hauptreferenz der CLI siehe [CLI-Anwendung](/de/docs/cli-application)."
    },
    "cloudPageTitle": "Rediacc CLI-Referenz (Cloud / Experimentell)",
    "errors": {
      "heading": "Häufige Fehlermeldungen",
      "intro": "Wenn etwas schiefgeht, liefert die CLI klare Fehlermeldungen:",
      "meanings": {
        "authRequired": "Sie müssen sich zuerst anmelden",
        "machineRequired": "Geben Sie eine Maschine mit `--machine` an oder setzen Sie einen Kontextstandard",
        "noActiveConfig": "Keine Konfiguration aktiv — erstellen Sie eine mit `rdc config init`",
        "permissionDenied": "Ihr Konto verfügt nicht über die erforderlichen Berechtigungen",
        "regionRequired": "Geben Sie eine Region mit `--region` an oder setzen Sie einen Kontextstandard",
        "teamRequired": "Geben Sie ein Team mit `--team` an oder setzen Sie einen Kontextstandard"
      }
    },
    "frontmatter": {
      "category": "Referenz",
      "description": "Vollständige Anleitung zur Verwendung der Rediacc-Befehlszeilenschnittstelle für die Plattformverwaltung",
      "title": "CLI-Anwendung"
    },
    "globalOptions": {
      "heading": "Globale Optionen",
      "intro": "Jeder Befehl unterstützt diese globalen Flags:"
    },
    "installation": {
      "heading": "Installation",
      "text": "Laden Sie die neueste Version für Ihre Plattform von der [Rediacc-Releases-Seite](https://www.rediacc.com) herunter oder installieren Sie über Ihren Paketmanager:"
    },
    "optionLabels": {
      "no": "Nein",
      "yes": "Ja"
    },
    "outputFormats": {
      "closing": "Dies erleichtert die Integration der Rediacc CLI in Skripte, CI/CD-Pipelines und Automatisierungsworkflows.",
      "heading": "Ausgabeformate",
      "text": "Alle List/Get-Befehle unterstützen mehrere Ausgabeformate über `--output`:"
    },
    "overview": {
      "heading": "Überblick",
      "text": "Die **Rediacc CLI** (`rdc`) ist eine Befehlszeilenschnittstelle zur Verwaltung aller Aspekte der Rediacc-Plattform — Authentifizierung, Infrastruktur, Repositories, Warteschlangen, Speicher und mehr."
    },
    "pageTitle": "Rediacc CLI-Referenz",
    "sectionTitles": {
      "audit": "Audit und Compliance",
      "auth": "Authentifizierung",
      "backup": "Backup-Verwaltung",
      "bridge": "Bridge-Verwaltung",
      "ceph": "Ceph-Speicherverwaltung",
      "config": "Konfigurationsverwaltung",
      "doctor": "Systemdiagnose",
      "machine": "Maschinenverwaltung",
      "ops": "Experimentelle VM-Operationen",
      "organization": "Organisationsverwaltung",
      "permission": "Berechtigungsverwaltung",
      "protocol": "Protokoll-Handler",
      "queue": "Warteschlangenoperationen",
      "region": "Regionsverwaltung",
      "repo": "Repository-Lebenszyklus",
      "repository": "Repository-Verwaltung",
      "shortcuts": "Schnellbefehle (Shortcuts)",
      "snapshot": "Snapshot-Verwaltung",
      "storage": "Speicherverwaltung",
      "store": "Store-Verwaltung",
      "subscription": "Abonnementverwaltung",
      "sync": "Dateisynchronisation",
      "team": "Teamverwaltung",
      "term": "SSH-Terminalzugang",
      "update": "CLI-Updates",
      "user": "Benutzerverwaltung",
      "vscode": "VS Code-Integration"
    },
    "supplements": {
      "auth": {
        "register": {
          "afterDescription": "Überprüfen Sie nach der Registrierung Ihre E-Mail auf den Aktivierungscode."
        },
        "tip": "Ihr Authentifizierungstoken wird lokal in Ihrem Kontext gespeichert. Verwenden Sie `--save-as`, um Anmeldedaten unter einem benannten Kontext für mehrere Umgebungen zu speichern."
      },
      "config": {
        "afterDescription": "Konfigurationsdateien speichern Verbindungsdetails (API-URL, Anmeldedaten, Standard-Team/Region/Machine), damit Sie schnell zwischen Umgebungen wechseln können.",
        "init": {
          "afterDescription": "Im lokalen Modus können Sie Machines direkt hinzufügen:"
        },
        "set": {
          "tip": "Standardwerte zu setzen bedeutet, dass Sie nicht bei jedem Befehl `--team`, `--region` oder `--machine` angeben müssen."
        }
      },
      "machine": {
        "health": {
          "afterDescription": "Der Health-Befehl gibt Systemmetriken, Container-Status, Dienststabilität und Speicherinformationen aus — nützlich für CI/CD-Pipeline-Prüfungen."
        },
        "testConnection": {
          "tip": "Verwenden Sie `--save-known-hosts`, um den Host-Schlüssel nach einem erfolgreichen Test automatisch im Maschinen-Vault zu speichern."
        }
      },
      "organization": {
        "maintenance": {
          "warning": "Wenn der Wartungsmodus aktiviert ist, können sich Nicht-Admin-Benutzer nicht anmelden."
        }
      },
      "queue": {
        "afterDescription": "Das Warteschlangensystem ist das Herzstück der Rediacc-Aufgabenausführung. Jede Operation (Deployment, Backup, Skriptausführung) läuft über die Warteschlange.",
        "trace": {
          "tip": "Verwenden Sie `--watch`, um die Aufgabe in Echtzeit zu verfolgen, bis sie abgeschlossen ist."
        }
      },
      "repository": {
        "promote": {
          "note": "Das Heraufstufen eines Forks trennt ihn von seinem übergeordneten (Parent) Repository und macht ihn unabhängig."
        }
      }
    },
    "tableHeaders": {
      "default": "Standard",
      "description": "Beschreibung",
      "error": "Fehler",
      "flag": "Option",
      "meaning": "Bedeutung",
      "required": "Erforderlich"
    }
  },
  "errors": {
    "activationFailed": "Aktivierung fehlgeschlagen",
    "affectedChildClones": ". Betroffene untergeordnete Klone: {{clones}}. Löschen oder befördern Sie untergeordnete Klone zuerst.",
    "authFailed": "Authentifizierung fehlgeschlagen",
    "authRequired": "Authentifizierung erforderlich. Ausführen: rdc auth login",
    "bridgeRequired": "Bridge-Name erforderlich. Verwenden Sie --bridge oder stellen Sie den Kontext ein.",
    "cannotDeleteGrandRepo": "Kann Grand-Repository nicht löschen: {{reason}}",
    "cannotPromote": "Kann nicht befördern: {{reason}}",
    "clusterNotFound": "Ceph-Cluster \"{{name}}\" nicht gefunden",
    "contextNotFound": "Kontext \"{{name}}\" nicht gefunden",
    "failedCreateQueueItem": "Queue-Item konnte nicht erstellt werden",
    "invalidAction": "Ungültige Aktion \"{{action}}\". Verwenden Sie \"{{valid}}\".",
    "invalidCredentials": "Ungültige Anmeldedaten",
    "invalidEmail": "Bitte geben Sie eine gültige E-Mail-Adresse ein",
    "invalidExpiration": "Token-Ablauf muss zwischen 1 und 720 Stunden liegen",
    "invalidFunctionParams": "Ungültige Parameter für Funktion \"{{function}}\": {{errors}}",
    "invalidHost": "Ungültige IP-Adresse oder Hostname: \"{{host}}\". Muss eine gültige IPv4-, IPv6- oder Hostname sein.",
    "invalidJsonFile": "Die bereitgestellte Datei enthält kein gültiges JSON.",
    "invalidJsonVault": "Ungültige JSON-Vault-Daten.",
    "invalidKey": "Ungültiger Schlüssel. Gültige Schlüssel: {{keys}}",
    "invalidMasterPassword": "Ungültiges Master-Passwort für die Vault-Verschlüsselung",
    "invalidPort": "Ungültige Portnummer: \"{{port}}\". Muss zwischen 1 und 65535 liegen.",
    "invalidPriorityMax": "Ungültiger priority-max-Wert. Muss zwischen 1 und 5 liegen.",
    "invalidPriorityMin": "Ungültiger priority-min-Wert. Muss zwischen 1 und 5 liegen.",
    "machineNotFound": "Machine \"{{name}}\" nicht gefunden",
    "machineRequired": "Machine-Name erforderlich. Verwenden Sie --machine oder stellen Sie den Kontext ein.",
    "machineRequiredLocal": "Machine-Name erforderlich. Verwenden Sie --machine oder legen Sie den Standard fest mit: rdc config set machine <name>",
    "networkError": "Netzwerkfehler: {{message}}",
    "noActiveConfig": "Keine aktive Konfiguration. Erstellen Sie eine mit: rdc config init <name>",
    "notAuthenticated": "Nicht authentifiziert. Ausführen: rdc auth login",
    "passwordsMismatch": "Passwörter stimmen nicht überein",
    "permissionDenied": "Berechtigung verweigert",
    "poolNotFound": "Ceph-Pool \"{{name}}\" nicht gefunden",
    "protocol": {
      "commandExitCode": "Befehl mit Code {{code}} beendet",
      "invalidAction": "Ungültige Aktion '{{action}}'. Muss eine der folgenden sein: {{validActions}}",
      "invalidUrl": "Ungültige Protokoll-URL: {{error}}",
      "machineRequired": "Machine-Name erforderlich. Verwenden Sie --machine <name>",
      "notSupported": "Protokollregistrierung wird auf {{platform}} nicht unterstützt",
      "parseFailed": "URL konnte nicht analysiert werden: {{error}}",
      "teamRequired": "Team-Name erforderlich. Verwenden Sie --team <name>",
      "tokenRequired": "Token erforderlich. Verwenden Sie --token <token>"
    },
    "regionRequired": "Regionsname erforderlich. Verwenden Sie --region oder stellen Sie den Kontext ein.",
    "registrationFailed": "Registrierung fehlgeschlagen",
    "repositoryNotFound": "Repository \"{{name}}:{{tag}}\" nicht gefunden",
    "repositoryRequired": "Repository-Name erforderlich. Verwenden Sie --repository <name>.",
    "resourceNotFound": "{{resource}} nicht gefunden",
    "sshKeyNotFound": "SSH-Schlüssel nicht gefunden: {{path}}",
    "sync": {
      "localPathNotFound": "Lokaler Pfad existiert nicht: {{path}}",
      "noHostKey": "Machine '{{machine}}' hat keinen Host-Schlüssel im Vault konfiguriert",
      "noIpAddress": "Machine '{{machine}}' hat keine IP-Adresse konfiguriert",
      "noPrivateKey": "Team '{{team}}' hat keinen SSH-Private-Key konfiguriert"
    },
    "teamRequired": "Team-Name erforderlich. Verwenden Sie --team oder stellen Sie den Kontext ein.",
    "term": {
      "connectivityFailed": "Kann {{host}}:{{port}} nicht erreichen. {{error}}\n\nFehlerbehebung:\n  - Überprüfen Sie, ob die Machine eingeschaltet ist und mit dem Netzwerk verbunden ist\n  - Überprüfen Sie, ob die IP-Adresse im Machine-Vault korrekt ist\n  - Stellen Sie sicher, dass Port {{port}} nicht durch eine Firewall blockiert ist\n  - Versuchen Sie, die Machine zu pingen: ping {{host}}",
      "launchFailed": "Terminal konnte nicht gestartet werden: {{error}}",
      "noHostKey": "Machine '{{machine}}' hat keinen Host-Schlüssel im Vault konfiguriert",
      "noIpAddress": "Machine '{{machine}}' hat keine IP-Adresse konfiguriert",
      "noPrivateKey": "Team '{{team}}' hat keinen SSH-Private-Key konfiguriert",
      "sshCode1": "Generischer Fehler - Überprüfen Sie die Befehlssyntax oder Remote-Berechtigungen",
      "sshCode126": "Berechtigung verweigert - Befehl kann nicht auf Remote ausgeführt werden",
      "sshCode127": "Befehl auf Remote-Machine nicht gefunden",
      "sshCode130": "Verbindung vom Benutzer beendet (Strg+C)",
      "sshCode255": "SSH-Verbindung fehlgeschlagen - mögliche Ursachen:\n    - Authentifizierung fehlgeschlagen (SSH-Schlüssel-Berechtigungen überprüfen)\n    - Host-Schlüssel-Überprüfung fehlgeschlagen\n    - Netzwerkverbindung unterbrochen\n    - Remote-SSH-Service läuft nicht",
      "sshExitCode": "SSH mit Code {{code}} beendet"
    },
    "tfaVerificationFailed": "TFA-Verifizierung fehlgeschlagen",
    "tokenExpired": "Token abgelaufen. Bitte melden Sie sich erneut an.",
    "unexpectedError": "Unerwarteter Fehler: {{message}}",
    "unknownCommand": "Unbekannter Befehl \"{{command}}\". Verfügbare Befehle: {{available}}.",
    "unknownSubcommand": "Unbekannter Unterbefehl \"{{command}}\". Verfügbare {{parent}}-Unterbefehle: {{available}}.",
    "validationError": "Validierungsfehler: {{message}}",
    "vaultDataRequired": "Vault-Daten erforderlich. Verwenden Sie --vault <json> oder leiten Sie JSON über stdin weiter.",
    "vaultVersionRequired": "Vault-Version erforderlich. Verwenden Sie --vault-version <n>.",
    "vscode": {
      "cleanupRequired": "Geben Sie --all an, um alle Verbindungen zu entfernen, oder --connection <name> für eine spezifische.",
      "connectivityFailed": "Kann {{host}}:{{port}} nicht erreichen. {{error}}\n\nFehlerbehebung:\n  - Überprüfen Sie, ob die Machine eingeschaltet ist und mit dem Netzwerk verbunden ist\n  - Überprüfen Sie, ob die IP-Adresse im Machine-Vault korrekt ist\n  - Stellen Sie sicher, dass Port {{port}} nicht durch eine Firewall blockiert ist\n  - Versuchen Sie, die Machine zu pingen: ping {{host}}",
      "noHostKey": "Machine '{{machine}}' hat keinen Host-Schlüssel im Vault konfiguriert",
      "noIpAddress": "Machine '{{machine}}' hat keine IP-Adresse konfiguriert",
      "noPrivateKey": "Team '{{team}}' hat keinen SSH-Private-Key konfiguriert",
      "notFound": "VS Code nicht gefunden.\n\nBitte installieren Sie von: https://code.visualstudio.com/\nOder setzen Sie die REDIACC_VSCODE_PATH-Umgebungsvariable."
    },
    "subscription": {
      "notLoggedIn": "Nicht angemeldet. Führen Sie zuerst `rdc subscription login` aus."
    }
  },
  "options": {
    "activationCode": "Aktivierungscode aus E-Mail",
    "apiUrl": "API-URL",
    "bridge": "Bridge-Name",
    "cleanupAll": "Alle rediacc-SSH-Konfigurationen entfernen",
    "cluster": "Ceph-Cluster-Name",
    "command": "Ausführen eines Befehls statt interaktiver Shell",
    "config": "Bestimmte Konfiguration für diesen Befehl verwenden",
    "confirmPasswordNonInteractive": "Passwort bestätigen (nicht-interaktiver Modus)",
    "confirmSync": "Änderungen anzeigen und vor der Synchronisierung um Bestätigung bitten",
    "connectionName": "Spezifische Verbindung entfernen",
    "container": "Mit einem bestimmten Docker-Container verbinden",
    "containerAction": "Container-Aktion: Terminal, Logs, Stats, Exec",
    "datastore": "Datastore-Pfad auf Machine",
    "debug": "Debug-Ausgabe aktivieren (lokaler Modus)",
    "dryRun": "Anzeigen, was übertragen würde, ohne tatsächlich zu synchronisieren",
    "email": "E-Mail-Adresse",
    "endpoint": "API-Endpunkt-URL",
    "excludePatterns": "Von der Synchronisierung auszuschließende Muster",
    "experimental": "Experimentelle Cloud-Befehle aktivieren",
    "expires": "Ablauf in Stunden (1-720)",
    "external": "Erzwinge Start in externem Terminal-Fenster",
    "extraMachine": "Zusätzliche Maschine für Multi-Maschinen-Operationen (Name:IP:Benutzer)",
    "filterStatus": "Nach Status filtern",
    "folder": "Pfad zum Remote-Ordner zum Öffnen",
    "follow": "Logs-Ausgabe folgen",
    "force": "Bestätigungsaufforderungen überspringen",
    "functionName": "Funktionsname zum Ausführen",
    "image": "RBD-Image-Name",
    "importMode": "Importmodus (merge oder replace)",
    "insiders": "VS Code Insiders-Einstellungen verwenden",
    "lang": "Sprache überschreiben ({{languages}})",
    "limit": "Maximale Anzahl von Ergebnissen",
    "localPath": "Lokaler Verzeichnispfad (Standard: aktuelles Verzeichnis)",
    "logLines": "Anzahl der angezeigten Log-Zeilen (Standard: 50)",
    "machine": "Machine-Name",
    "machineForVault": "Machine-Name (zum Aktualisieren des Vault nach Test)",
    "machineIp": "Machine-IP-Adresse oder Hostname",
    "machineNames": "Machine-Namen (kommagetrennt)",
    "machineShorthand": "Machine-Name (Kurzform für --machine)",
    "masterPassword": "Master-Passwort für die Vault-Verschlüsselung",
    "mirrorDownload": "Spiegelmodus - lokale Dateien löschen, die nicht auf Remote vorhanden sind",
    "mirrorUpload": "Spiegelmodus - Remote-Dateien löschen, die nicht lokal vorhanden sind",
    "newPasswordNonInteractive": "Neues Passwort (nicht-interaktiver Modus)",
    "newWindow": "In neuem VS Code-Fenster öffnen",
    "opsBackend": "Virtualisierungs-Backend (kvm|qemu, automatisch erkannt)",
    "opsBasic": "Minimaler Cluster (Bridge + 1 Worker)",
    "opsForce": "Neustart aller VMs erzwingen",
    "opsLite": "VM-Bereitstellung überspringen (nur Status)",
    "opsOS": "VM-Betriebssystem (z.B. ubuntu-24.04, debian-12)",
    "opsParallel": "VMs parallel erstellen",
    "opsSkipOrchestration": "Cluster-Orchestrierung überspringen",
    "opsSSHUser": "SSH-Benutzername für VM-Verbindung",
    "organization": "Organisationsname",
    "output": "Ausgabeformat (table|json|yaml|csv)",
    "outputFormat": "Ausgabeformat (json)",
    "outputPath": "Pfad zum Speichern der Ausgabedatei",
    "param": "Funktionsparameter",
    "parentRepository": "Parent-Repository (für Forks)",
    "parentRepositoryTag": "Parent-Repository-Tag",
    "password": "Passwort (für nicht-interaktive Anmeldung)",
    "pollInterval": "Abrufintervall in Millisekunden",
    "pool": "Ceph-Pool-Name",
    "priority": "Priorität (1=höchste)",
    "priorityMax": "Maximale Priorität (1-5)",
    "priorityMin": "Mindestpriorität (1-5)",
    "protocolAction": "Aktion ({{actions}})",
    "protocolForce": "Neu-Registrierung erzwingen, auch wenn bereits registriert",
    "protocolParams": "Zusätzliche Parameter",
    "protocolSystem": "Systemweit registrieren (erfordert Admin-Rechte)",
    "protocolSystemUnregister": "Systemweite Registrierung deregistrieren (erfordert Admin-Rechte)",
    "protocolToken": "Authentifizierungs-Token",
    "rawVault": "Raw Vault JSON (für Scripts/CI)",
    "region": "Regionsname",
    "remotePath": "Remote-Unterverzichnis-Pfad innerhalb des Repository",
    "renetPath": "Pfad zur renet-Binärdatei (Standard: renet in PATH)",
    "repository": "Repository-Name (verbindet sich mit Repository-Umgebung)",
    "repositoryShorthand": "Repository-Name (Kurzform für --repository)",
    "repositoryTag": "Repository-Tag",
    "saveAs": "Anmeldedaten unter benanntem Kontext speichern",
    "saveKnownHosts": "known_hosts nach erfolgreichem Test im Machine-Vault speichern",
    "searchInField": "Suchen in {{field}}",
    "searchQueue": "In Task-ID, Team, Machine, Bridge suchen",
    "searchRepos": "Repositories nach Name filtern",
    "sessionName": "Sitzungsname",
    "skipEnvSetup": "Remote-Umgebungs-Setup überspringen",
    "skipRouterRestart": "Neustart des Route-Servers nach Binary-Update überspringen",
    "snapshot": "RBD-Snapshot-Name",
    "sortByField": "Sortieren nach Feld",
    "sortDesc": "In absteigender Reihenfolge sortieren",
    "sortDescending": "Absteigend sortieren",
    "sortField": "Nach Feld sortieren",
    "sshKey": "Pfad zum SSH-Private-Key (z. B. ~/.ssh/id_rsa)",
    "sshPassword": "SSH-Passwort für erste Authentifizierung",
    "sshPort": "SSH-Port",
    "sshPrivateKey": "Pfad zum SSH-Private-Key",
    "sshPublicKey": "Pfad zum SSH-Public-Key",
    "sshUser": "SSH-Benutzername",
    "subscriptionPlan": "Abonnementplan (COMMUNITY, PROFESSIONAL, BUSINESS, ENTERPRISE)",
    "switch": "Nach Erstellung zu diesem Kontext wechseln",
    "team": "Team-Name",
    "tfaCode": "Aktueller TFA-Code zur Überprüfung",
    "tokenName": "Token-Name",
    "urlOnly": "Drucke die VS Code-URI statt sie zu starten",
    "userPassword": "Passwort für den neuen Benutzer",
    "vaultContent": "Vault-Inhalt als JSON-String",
    "vaultJson": "Vault-Inhalt als JSON-String",
    "vaultJsonMachine": "Machine-Vault-Daten als JSON-String",
    "vaultVersion": "Aktuelle Vault-Version für optimistisches Locking",
    "verifyChecksum": "Dateien mit Prüfsummen nach der Synchronisierung überprüfen",
    "watch": "Auf Änderungen achten",
    "watchUpdates": "Auf Updates achten",
    "yes": "Bestätigungsaufforderung überspringen",
    "apiToken": "API-Token (rdt_...)",
    "serverUrl": "Account-Server-URL"
  },
  "prompts": {
    "apiUrl": "API-URL:",
    "cancelled": "Abgebrochen",
    "confirm": "Sind Sie sicher?",
    "confirmDelete": "Möchten Sie dies wirklich löschen?",
    "confirmNewPassword": "Neues Passwort bestätigen:",
    "confirmPassword": "Passwort bestätigen:",
    "email": "E-Mail:",
    "enterValue": "Geben Sie {{field}} ein:",
    "masterPassword": "Geben Sie Ihr Master-Passwort ein:",
    "masterPasswordForVault": "Geben Sie das Master-Passwort für die Vault-Verschlüsselung ein:",
    "newPassword": "Neues Passwort:",
    "password": "Passwort:",
    "passwordForUser": "Passwort für neuen Benutzer:",
    "selectOption": "Wählen Sie eine Option:",
    "setPassword": "Passwort für Benutzer festlegen:",
    "sshPassword": "SSH-Passwort (leer lassen, wenn Sie Schlüssel-Auth verwenden): ",
    "syncConfirm": "\nFortfahren mit Synchronisierung? [y/N/d(etails)] ",
    "syncConfirmHelp": "Bitte geben Sie y (ja), n (nein) oder d (details) ein"
  },
  "spinners": {
    "connecting": "Verbindung wird hergestellt...",
    "creating": "{{resource}} wird erstellt...",
    "deleting": "{{resource}} wird gelöscht...",
    "fetching": "{{resource}} wird abgerufen...",
    "loading": "Wird geladen...",
    "processing": "Wird verarbeitet...",
    "saving": "Wird gespeichert...",
    "updating": "{{resource}} wird aktualisiert..."
  },
  "status": {
    "cancelled": "Abgebrochen",
    "completed": "Abgeschlossen",
    "failed": "Fehlgeschlagen",
    "pending": "Ausstehend",
    "processing": "Wird verarbeitet",
    "success": "Erfolg"
  },
  "table": {
    "noData": "Keine Daten zum Anzeigen"
  }
}
