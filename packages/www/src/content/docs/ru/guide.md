---
title: "Пошаговое руководство"
description: "Разверните зашифрованную изолированную инфраструктуру на собственных серверах с использованием Rediacc в локальном режиме."
category: "Guides"
order: 2
language: ru
---

# Пошаговое руководство

Это руководство описывает процесс развертывания зашифрованной изолированной инфраструктуры на собственных серверах с использованием Rediacc в **локальном режиме**. По завершении у вас будет полностью рабочий репозиторий с контейнеризированными сервисами на удаленной машине, управляемый с вашей рабочей станции.

Локальный режим означает, что всё работает на инфраструктуре, которую вы контролируете. Никаких облачных аккаунтов, никаких SaaS-зависимостей. Ваша рабочая станция оркестрирует удаленные серверы по SSH, а все данные о состоянии хранятся локально на вашей машине и на самих серверах.

## Обзор архитектуры

Rediacc использует архитектуру из двух инструментов:

```
Your Workstation                    Remote Server
┌──────────────┐        SSH        ┌──────────────────────────┐
│              │ ──────────────▶   │  renet (Go binary)       │
│  rdc (CLI)   │                   │    ├── LUKS encryption   │
│              │ ◀──────────────   │    ├── Docker daemon     │
│  config.json │    stdout/stderr  │    ├── Rediaccfile exec  │
└──────────────┘                   │    └── Traefik proxy     │
                                   └──────────────────────────┘
```

- **rdc** работает на вашей рабочей станции (macOS или Linux). Он считывает локальную конфигурацию, подключается к удаленным машинам по SSH и вызывает команды renet.
- **renet** работает на удаленном сервере с привилегиями root. Он управляет LUKS-зашифрованными образами дисков, изолированными Docker-демонами, оркестрацией сервисов и конфигурацией обратного прокси.

Каждая команда, которую вы вводите локально, транслируется в SSH-вызов, выполняющий renet на удаленной машине. Вам никогда не нужно подключаться к серверам по SSH вручную.

## Шаг 1: Создание локального контекста

**Контекст** — это именованная конфигурация, хранящая ваши SSH-учетные данные, определения машин и привязки репозиториев. Воспринимайте его как рабочее пространство проекта.

```bash
rdc context create-local my-infra --ssh-key ~/.ssh/id_ed25519
```

| Опция | Обязательно | Описание |
|-------|-------------|----------|
| `--ssh-key <path>` | Да | Путь к вашему приватному SSH-ключу. Тильда (`~`) раскрывается автоматически. |
| `--renet-path <path>` | Нет | Пользовательский путь к бинарному файлу renet на удаленных машинах. По умолчанию используется стандартное расположение установки. |

Эта команда создает локальный контекст с именем `my-infra` и сохраняет его в `~/.rediacc/config.json`.

> Вы можете иметь несколько контекстов (например, `production`, `staging`, `dev`). Переключайтесь между ними с помощью флага `--context` в любой команде.

## Шаг 2: Добавление машины

Зарегистрируйте ваш удаленный сервер как машину в контексте:

```bash
rdc context add-machine server-1 --ip 203.0.113.50 --user deploy
```

| Опция | Обязательно | По умолчанию | Описание |
|-------|-------------|--------------|----------|
| `--ip <address>` | Да | - | IP-адрес или имя хоста удаленного сервера. |
| `--user <username>` | Да | - | Имя пользователя SSH на удаленном сервере. |
| `--port <port>` | Нет | `22` | Порт SSH. |
| `--datastore <path>` | Нет | `/mnt/rediacc` | Путь на сервере, где Rediacc хранит зашифрованные репозитории. |

После добавления машины rdc автоматически выполняет `ssh-keyscan` для получения ключей хоста сервера. Вы также можете выполнить это вручную:

```bash
rdc context scan-keys server-1
```

Для просмотра всех зарегистрированных машин:

```bash
rdc context machines
```

## Шаг 3: Настройка машины

Подготовьте удаленный сервер, установив все необходимые зависимости:

```bash
rdc context setup-machine server-1
```

Эта команда:
1. Загружает бинарный файл renet на сервер через SFTP
2. Устанавливает Docker, containerd и cryptsetup (если отсутствуют)
3. Создает директорию хранилища данных и подготавливает её для зашифрованных репозиториев

| Опция | Обязательно | По умолчанию | Описание |
|-------|-------------|--------------|----------|
| `--datastore <path>` | Нет | `/mnt/rediacc` | Директория хранилища данных на сервере. |
| `--datastore-size <size>` | Нет | `95%` | Какую долю доступного диска выделить для хранилища данных. |
| `--debug` | Нет | `false` | Включить подробный вывод для диагностики. |

> Настройку нужно выполнить только один раз для каждой машины. Повторный запуск безопасен при необходимости.

## Шаг 4: Создание репозитория

**Репозиторий** — это LUKS-зашифрованный образ диска на удаленном сервере. При монтировании он предоставляет:
- Изолированную файловую систему для данных вашего приложения
- Выделенный Docker-демон (отдельный от Docker хоста)
- Уникальные loopback IP-адреса для каждого сервиса в подсети /26

Создайте репозиторий:

```bash
rdc repo create my-app -m server-1 --size 10G
```

| Опция | Обязательно | Описание |
|-------|-------------|----------|
| `-m, --machine <name>` | Да | Целевая машина, на которой будет создан репозиторий. |
| `--size <size>` | Да | Размер зашифрованного образа диска (например, `5G`, `10G`, `50G`). |

В выводе будут показаны три автоматически сгенерированных значения:

- **GUID репозитория** — UUID, идентифицирующий зашифрованный образ диска на сервере.
- **Учетные данные** — случайная парольная фраза, используемая для шифрования/дешифрования тома LUKS.
- **Идентификатор сети** — целое число (начинается с 2816, увеличивается на 64), определяющее IP-подсеть для сервисов данного репозитория.

> **Сохраните учетные данные в надежном месте.** Это ключ шифрования вашего репозитория. При утере данные не могут быть восстановлены. Учетные данные хранятся в вашем локальном `config.json`, но не хранятся на сервере.

## Шаг 5: Rediaccfile

**Rediaccfile** — это Bash-скрипт, определяющий, как ваши сервисы подготавливаются, запускаются и останавливаются. Это основной механизм управления жизненным циклом сервисов.

### Что такое Rediaccfile?

Rediaccfile — это обычный Bash-скрипт, содержащий до трех функций: `prep()`, `up()` и `down()`. Он должен называться `Rediaccfile` или `rediaccfile` (регистр не имеет значения) и размещаться внутри смонтированной файловой системы репозитория.

Rediaccfile обнаруживается в двух местах:
1. В **корне** пути монтирования репозитория
2. В **поддиректориях первого уровня** пути монтирования (не рекурсивно)

Скрытые директории (имена начинаются с `.`) пропускаются.

### Функции жизненного цикла

| Функция | Когда выполняется | Назначение | Поведение при ошибке |
|---------|-------------------|------------|----------------------|
| `prep()` | Перед `up()` | Установка зависимостей, загрузка образов, выполнение миграций | **Немедленная остановка** — если любой `prep()` завершится с ошибкой, весь процесс немедленно останавливается. |
| `up()` | После завершения всех `prep()` | Запуск сервисов (например, `docker compose up -d`) | Ошибка корневого Rediaccfile — **критическая** (останавливает всё). Ошибки в поддиректориях — **некритические** (логируются, продолжение к следующему). |
| `down()` | При остановке | Остановка сервисов (например, `docker compose down`) | **Максимальные усилия** — ошибки логируются, но все Rediaccfile всегда обрабатываются. |

Все три функции необязательны. Если функция не определена в Rediaccfile, она тихо пропускается.

### Порядок выполнения

- **Запуск (`up`):** Сначала корневой Rediaccfile, затем поддиректории в **алфавитном порядке** (от A до Z).
- **Остановка (`down`):** Поддиректории в **обратном алфавитном порядке** (от Z до A), затем корневой последним.

### Переменные окружения

При выполнении функции Rediaccfile доступны следующие переменные окружения:

| Переменная | Описание | Пример |
|------------|----------|--------|
| `REPOSITORY_PATH` | Путь монтирования репозитория | `/mnt/rediacc/repos/abc123` |
| `REPOSITORY_NAME` | GUID репозитория | `a1b2c3d4-e5f6-...` |
| `REPOSITORY_NETWORK_ID` | Идентификатор сети (целое число) | `2816` |
| `DOCKER_HOST` | Docker-сокет для изолированного демона данного репозитория | `unix:///var/run/rediacc/docker-2816.sock` |
| `{SERVICE}_IP` | Loopback IP для каждого сервиса, определенного в `.rediacc.json` | `POSTGRES_IP=127.0.11.2` |

Переменные `{SERVICE}_IP` автоматически генерируются из `.rediacc.json` (см. Шаг 6). Соглашение об именовании преобразует имя сервиса в верхний регистр с заменой дефисов на подчеркивания, а затем добавляет `_IP`. Например, `listmonk-app` становится `LISTMONK_APP_IP`.

### Пример Rediaccfile

Простой Rediaccfile для веб-приложения:

```bash
#!/bin/bash

prep() {
    echo "Pulling latest images..."
    docker compose pull
}

up() {
    echo "Starting services..."
    docker compose up -d
}

down() {
    echo "Stopping services..."
    docker compose down
}
```

### Пример с несколькими сервисами

Для проектов с несколькими независимыми группами сервисов используйте поддиректории:

```
/mnt/rediacc/repos/my-app/
├── Rediaccfile              # Корневой: общая настройка (например, создание Docker-сетей)
├── docker-compose.yml       # Корневой compose-файл
├── database/
│   ├── Rediaccfile          # Сервисы базы данных
│   └── docker-compose.yml
├── backend/
│   ├── Rediaccfile          # API-сервер
│   └── docker-compose.yml
└── monitoring/
    ├── Rediaccfile          # Prometheus, Grafana и т.д.
    └── docker-compose.yml
```

Порядок выполнения для `up`: корневой, затем `backend`, `database`, `monitoring` (A-Z).
Порядок выполнения для `down`: `monitoring`, `database`, `backend`, затем корневой (Z-A).

## Шаг 6: Сетевое взаимодействие сервисов (.rediacc.json)

Каждый репозиторий получает подсеть /26 (64 IP-адреса) в loopback-диапазоне `127.x.x.x`. Сервисы привязываются к уникальным loopback IP-адресам, что позволяет им работать на одних и тех же портах без конфликтов. Например, два экземпляра PostgreSQL могут одновременно слушать порт 5432, каждый на своем IP-адресе.

### Файл .rediacc.json

Файл `.rediacc.json` сопоставляет имена сервисов с номерами **слотов**. Каждый слот соответствует уникальному IP-адресу в подсети репозитория.

```json
{
  "services": {
    "api": {"slot": 0},
    "postgres": {"slot": 1},
    "redis": {"slot": 2}
  }
}
```

Сервисы записываются в алфавитном порядке.

### Автоматическая генерация из Docker Compose

Вам не нужно создавать `.rediacc.json` вручную. При выполнении `rdc repo up` Rediacc автоматически:

1. Сканирует все директории, содержащие Rediaccfile, на наличие compose-файлов (`docker-compose.yml`, `docker-compose.yaml`, `compose.yml` или `compose.yaml`).
2. Извлекает имена сервисов из секции `services:` каждого compose-файла.
3. Назначает следующий доступный слот каждому новому сервису.
4. Сохраняет результат в `{repository}/.rediacc.json`.

### Вычисление IP-адресов

IP-адрес сервиса вычисляется из идентификатора сети репозитория и слота сервиса. Идентификатор сети распределяется по второму, третьему и четвёртому октетам loopback-адреса `127.x.y.z`. Каждый сервис получает смещение `slot + 2`, добавляемое к идентификатору сети (смещения 0 и 1 зарезервированы для сетевого адреса и шлюза).

Например, при идентификаторе сети `2816` (`0x0B00`) базовый адрес -- `127.0.11.0`, а сервисы начинаются с `127.0.11.2`.

**Пример** для идентификатора сети `2816`:

| Сервис | Слот | IP-адрес |
|--------|------|----------|
| api | 0 | `127.0.11.2` |
| postgres | 1 | `127.0.11.3` |
| redis | 2 | `127.0.11.4` |

Каждый репозиторий поддерживает до **61 сервиса** (слоты от 0 до 60).

### Использование IP-адресов сервисов в Docker Compose

Поскольку каждый репозиторий работает с изолированным Docker-демоном, сервисы используют `network_mode: host` и привязываются к назначенным loopback IP-адресам:

```yaml
services:
  postgres:
    image: postgres:16
    network_mode: host
    environment:
      PGDATA: /var/lib/postgresql/data
      POSTGRES_PASSWORD: secret
    command: -c listen_addresses=${POSTGRES_IP} -c port=5432

  api:
    image: my-api:latest
    network_mode: host
    environment:
      DATABASE_URL: postgresql://postgres:secret@${POSTGRES_IP}:5432/mydb
      LISTEN_ADDR: ${API_IP}:8080
```

Переменные `${POSTGRES_IP}` и `${API_IP}` автоматически экспортируются из `.rediacc.json` при запуске Rediaccfile.

## Шаг 7: Запуск сервисов

Смонтируйте репозиторий и запустите все сервисы:

```bash
rdc repo up my-app -m server-1 --mount
```

| Опция | Обязательно | Описание |
|-------|-------------|----------|
| `-m, --machine <name>` | Да | Целевая машина. |
| `--mount` | Нет | Сначала смонтировать репозиторий, если он еще не смонтирован. Без этого флага репозиторий уже должен быть смонтирован. |
| `--prep-only` | Нет | Выполнить только функции `prep()`, пропустить `up()`. Полезно для предварительной загрузки образов или выполнения миграций. |

Последовательность выполнения:

1. Монтирование LUKS-зашифрованного репозитория (если указан `--mount`)
2. Запуск изолированного Docker-демона для данного репозитория
3. Автоматическая генерация `.rediacc.json` из compose-файлов
4. Выполнение `prep()` во всех Rediaccfile (в алфавитном порядке, с немедленной остановкой при ошибке)
5. Выполнение `up()` во всех Rediaccfile (в алфавитном порядке)

## Шаг 8: Остановка сервисов

Остановите все сервисы в репозитории:

```bash
rdc repo down my-app -m server-1
```

| Опция | Обязательно | Описание |
|-------|-------------|----------|
| `-m, --machine <name>` | Да | Целевая машина. |
| `--unmount` | Нет | Размонтировать зашифрованный репозиторий после остановки сервисов. Это также останавливает изолированный Docker-демон и закрывает том LUKS. |

Последовательность выполнения:

1. Выполнение `down()` во всех Rediaccfile (в обратном алфавитном порядке, максимальные усилия)
2. Остановка изолированного Docker-демона (если указан `--unmount`)
3. Размонтирование и закрытие LUKS-зашифрованного тома (если указан `--unmount`)

## Другие распространенные операции

### Монтирование и размонтирование (без запуска сервисов)

```bash
rdc repo mount my-app -m server-1     # Расшифровать и смонтировать
rdc repo unmount my-app -m server-1   # Размонтировать и зашифровать
```

### Проверка статуса репозитория

```bash
rdc repo status my-app -m server-1
```

### Список всех репозиториев

```bash
rdc repo list -m server-1
```

### Изменение размера репозитория

```bash
rdc repo resize my-app -m server-1 --size 20G    # Установить точный размер
rdc repo expand my-app -m server-1 --size 5G      # Добавить 5G к текущему размеру
```

### Удаление репозитория

```bash
rdc repo delete my-app -m server-1
```

> Эта операция безвозвратно уничтожает зашифрованный образ диска и все данные внутри него.

### Создание копии (форк) репозитория

Создайте копию существующего репозитория в его текущем состоянии:

```bash
rdc repo fork my-app -m server-1 --tag my-app-staging
```

Эта команда создает новую зашифрованную копию с собственным GUID и идентификатором сети. Форк использует те же учетные данные LUKS, что и родительский репозиторий.

### Проверка целостности репозитория

Проверьте целостность файловой системы репозитория:

```bash
rdc repo validate my-app -m server-1
```

## Полный пример: развертывание веб-приложения

Этот сквозной пример развертывает веб-приложение с PostgreSQL, Redis и API-сервером.

### 1. Настройка окружения

```bash
# Install rdc
curl -fsSL https://get.rediacc.com | sh

# Create a local context
rdc context create-local production --ssh-key ~/.ssh/id_ed25519

# Register your server
rdc context add-machine prod-1 --ip 203.0.113.50 --user deploy

# Provision the server
rdc context setup-machine prod-1

# Create an encrypted repository (10 GB)
rdc repo create webapp -m prod-1 --size 10G
```

### 2. Монтирование и подготовка репозитория

```bash
rdc repo mount webapp -m prod-1
```

Подключитесь к серверу по SSH и создайте файлы приложения внутри смонтированного репозитория. Путь монтирования отображается в выводе (обычно `/mnt/rediacc/repos/{guid}`).

### 3. Создание файлов приложения

Внутри репозитория создайте следующие файлы:

**docker-compose.yml:**

```yaml
services:
  postgres:
    image: postgres:16
    network_mode: host
    restart: unless-stopped
    volumes:
      - ./data/postgres:/var/lib/postgresql/data
    environment:
      POSTGRES_DB: webapp
      POSTGRES_USER: app
      POSTGRES_PASSWORD: changeme
    command: -c listen_addresses=${POSTGRES_IP} -c port=5432

  redis:
    image: redis:7-alpine
    network_mode: host
    restart: unless-stopped
    command: redis-server --bind ${REDIS_IP} --port 6379

  api:
    image: myregistry/api:latest
    network_mode: host
    restart: unless-stopped
    environment:
      DATABASE_URL: postgresql://app:changeme@${POSTGRES_IP}:5432/webapp
      REDIS_URL: redis://${REDIS_IP}:6379
      LISTEN_ADDR: ${API_IP}:8080
```

**Rediaccfile:**

```bash
#!/bin/bash

prep() {
    echo "Creating data directories..."
    mkdir -p data/postgres

    echo "Pulling images..."
    docker compose pull
}

up() {
    echo "Starting webapp services..."
    docker compose up -d

    echo "Waiting for PostgreSQL to be ready..."
    for i in $(seq 1 30); do
        if docker compose exec postgres pg_isready -q 2>/dev/null; then
            echo "PostgreSQL is ready."
            return 0
        fi
        sleep 1
    done
    echo "Warning: PostgreSQL did not become ready within 30 seconds."
}

down() {
    echo "Stopping webapp services..."
    docker compose down
}
```

### 4. Запуск всего

```bash
rdc repo up webapp -m prod-1
```

Эта команда:
1. Автоматически сгенерирует `.rediacc.json` со слотами для `api`, `postgres` и `redis`
2. Выполнит `prep()` для создания директорий и загрузки образов
3. Выполнит `up()` для запуска всех контейнеров

### 5. Включение автозапуска

```bash
rdc repo autostart enable webapp -m prod-1
```

После перезагрузки сервера репозиторий автоматически смонтируется и запустит все сервисы.
